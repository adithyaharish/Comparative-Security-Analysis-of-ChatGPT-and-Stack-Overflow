id,index,code,category
421696,0,"byte[] digest = m.digest();
BigInteger bigInt = new BigInteger(1,digest);
String hashtext = bigInt.toString(16);
// Now we need to zero pad it if you actually want the full 32 chars.
while(hashtext.length() < 32 ){
  hashtext = ""0""+hashtext;
}
",4
992413,5,"public class sample{
 public void foo(){
/* Derive the key, given password and salt. */
SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA256"");
KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);
SecretKey tmp = factory.generateSecret(spec);
SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

}",2
992413,6,"Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, secret);
AlgorithmParameters params = cipher.getParameters();
byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();",2
992413,10,"public class sample{
 public void foo(){
/* Decrypt the message, given derived key and initialization vector. */
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
String plaintext = new String(cipher.doFinal(ciphertext), ""UTF-8"");
System.out.println(plaintext);

}",2
1205272,3,"byte[] encrypted= new byte[cipher.getOutputSize(input.length)];
int enc_len = cipher.update(input, 0, input.length, encrypted, 0);
enc_len += cipher.doFinal(encrypted, enc_len);
",2
1455702,0,"    ka.doPhase(server, true);
    byte[] raw = ka.generateSecret();
    SecretKeySpec secret;
    try {
      secret = new SecretKeySpec(raw, 0, 16, ""AES"");
    }
    finally {
      Arrays.fill(raw, (byte) 0);
    }
    /* Setup cipher for encryption with secret key. */
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");",2
1455702,0,"    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    /* Get the IV to be sent to server with ciphertext. */
    byte[] iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();
    /* Encrypt the message with the secret key. */",2
1455702,0,"    ka.doPhase(client, true);
    byte[] raw = ka.generateSecret();
    SecretKeySpec secret;
    try {
      secret = new SecretKeySpec(raw, 0, 16, ""AES"");
    }
    finally {
      Arrays.fill(raw, (byte) 0);
    }
    /* Setup cipher for decryption with secret key. */
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");",2
1710112,0,"        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
        keyGen.initialize(512);
        byte[] publicKey = keyGen.genKeyPair().getPublic().getEncoded();
        StringBuffer retString = new StringBuffer();",3
1710112,1,"        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(""RSA"");
        keyGen.initialize(512);
        byte[] publicKey = keyGen.genKeyPair().getPublic().getEncoded();
        StringBuffer retString = new StringBuffer();",3
1729907,0,"    KeyStore keystore = KeyStore.getInstance(keystoreType);
    keystore.load(keystoreLocation, keystorePassword);
    KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmfactory.init(keystore, keyPassword);

    InputStream truststoreLocation = null;
    char [] truststorePassword = null;",1
1794117,1,"        try {
            java.security.cert.Certificate[] certs = keyStore.getCertificateChain(alias);
            if (certs == null || certs.length == 0)
                return null;
            X509Certificate[] x509 = new X509Certificate[certs.length];
            for (int i = 0; i < certs.length; i++)
                x509[i] = (X509Certificate)certs[i];
            return x509;",1
2212400,0,"    public Crypto(String passphrase) {
        byte[] passwordKey = encodeDigest(passphrase);

        try {
            aesCipher = Cipher.getInstance(CIPHER_TRANSFORMATION);
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, ""No such algorithm "" + CIPHER_ALGORITHM, e);
        } catch (NoSuchPaddingException e) {
            Log.e(TAG, ""No such padding PKCS5"", e);
        }

        secretKey = new SecretKeySpec(passwordKey, CIPHER_ALGORITHM);
        ivParameterSpec = new IvParameterSpec(rawSecretKey);",2
2212400,0,"    public byte[] encrypt(byte[] clearData) {
        try {
            aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
        } catch (InvalidKeyException e) {
            Log.e(TAG, ""Invalid key"", e);
            return null;
        } catch (InvalidAlgorithmParameterException e) {
            Log.e(TAG, ""Invalid algorithm "" + CIPHER_ALGORITHM, e);
            return null;
        }

        byte[] encryptedData;
        try {
            encryptedData = aesCipher.doFinal(clearData);
        } catch (IllegalBlockSizeException e) {
            Log.e(TAG, ""Illegal block size"", e);
            return null;
        } catch (BadPaddingException e) {
            Log.e(TAG, ""Bad padding"", e);
            return null;
        }
        return encryptedData;
    }

    private byte[] encodeDigest(String text) {
        MessageDigest digest;
        try {
            digest = MessageDigest.getInstance(MESSAGEDIGEST_ALGORITHM);
            return digest.digest(text.getBytes());
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, ""No such algorithm "" + MESSAGEDIGEST_ALGORITHM, e);
        }

        return null;
    }",4
2212400,0,"        try {
            aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
        } catch (InvalidKeyException e) {
            Log.e(TAG, ""Invalid key"", e);
            return null;
        } catch (InvalidAlgorithmParameterException e) {
            Log.e(TAG, ""Invalid algorithm "" + CIPHER_ALGORITHM, e);
            return null;
        }
",2
2712518,0,"public boolean validate(X509Certificate certificate, CertPath certPath,
        PKIXParameters parameters) throws GeneralSecurityException {
    try {
        CertPathValidator cpv = CertPathValidator.getInstance(""PKIX"");
        PKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult) cpv
                .validate(certPath, parameters);
        Signature.LOG.debug(""Validation result is: "" + result);
        return true; // if no exception is thrown
    } catch (CertPathValidatorException cpve) {

        // if the exception is (or is caused by)
        // CertificateRevokedException, return false;
        // otherwise re-throw, because this indicates a failure to perform
        // the validation
        Throwable cause = ExceptionUtils.getRootCause(cpve);
        Class<? extends Throwable> exceptionClass = cause != null ? cause.getClass()
                : cpve.getClass();
        if (exceptionClass.getSimpleName().equals(""CertificateRevokedException"")) {
            return false;
        }
        throw cpve;
    }
}
",3
2789169,0,"public class sample{
 public void foo(){
Signature signer = Signature.getInstance(""SHA1withRSA"");
signer.initSign(privateKey);
signer.update(message);
byte[] signature = signer.sign();

}",4
2816218,0,"        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"");
        // NOTE: last argument is the key length, and it is 256
        KeySpec spec = new PBEKeySpec(password, salt, 1024, 256);
        SecretKey tmp = factory.generateSecret(spec);
        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
        return(secret);",2
2957053,1,"            byte[] message = digest.digest();

            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < message.length; i++) {
                hexString.append(Integer.toHexString(
                        0xFF & message[i]));
            }",4
2963279,0,"    cipher.init(false, keyParams);

    final byte[] processed = new byte[cipher.getOutputSize(bytes.length)];
    int outputLength = cipher.processBytes(bytes, 0, bytes.length, processed, 0);
    outputLength += cipher.doFinal(processed, outputLength);

    final byte[] results = new byte[outputLength];
    System.arraycopy(processed, 0, results, 0, outputLength);",2
2963279,0,"    final byte[] processed = new byte[cipher.getOutputSize(bytes.length)];
    int outputLength = cipher.processBytes(bytes, 0, bytes.length, processed, 0);
    outputLength += cipher.doFinal(processed, outputLength);
",2
3151077,1,"    byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
    int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
    ctLength += cipher.doFinal(cipherText, ctLength);",2
3152396,0,"public class sample{
 public void foo(){
Signature signature = Signature.getInstance(""SHA1withRSA"");
signature.initSign(privKey);
signature.update(message);
byte[] signatureValue = signature.sign();

}",4
3208472,0,"SecretKeySpec keySpec = new SecretKeySpec(
        ""qnscAdgRlkIhAUPY44oiexBKtQbGY0orf7OV1I50"".getBytes(),
        ""HmacSHA1"");

Mac mac = Mac.getInstance(""HmacSHA1"");
mac.init(keySpec);
byte[] result = mac.doFinal(""foo"".getBytes());
",4
3247929,0,"        keyStore.setCertificateEntry(""myCert"", myCert);

        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(""PKIX"");
        trustManagerFactory.init(keyStore);

        TrustManager trustManagers[] = trustManagerFactory.getTrustManagers();

        for(TrustManager trustManager : trustManagers) {
            if(trustManager instanceof X509TrustManager) {
                pkixTrustManager = (X509TrustManager) trustManager;
                return;
            }
        }

        throw new Exception(""Couldn't initialize"");",1
3247929,1,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    public boolean equals(Object obj) {
        return ((obj != null) && obj.getClass().equals(MySSLProtocolSocketFactory.class));
    }

    public int hashCode() {
        return MySSLProtocolSocketFactory.class.hashCode();
    }",1
3313312,0,"public class sample{
 public void foo(){
BASE64Encoder encoder = new BASE64Encoder();
out.println(X509Factory.BEGIN_CERT);
encoder.encodeBuffer(cert.getEncoded(), out);
out.println(X509Factory.END_CERT);

}",-1
3435462,0,"            TrustManager tms[] = tmf.getTrustManagers();

            /*
             * Iterate over the returned trustmanagers, look
             * for an instance of X509TrustManager.  If found,
             * use that as our ""default"" trust manager.
             */
            for (int i = 0; i < tms.length; i++) {
                if (tms[i] instanceof X509TrustManager) {
                    pkixTrustManager = (X509TrustManager) tms[i];
                    return;
                }
            }

            /*
             * Find some other way to initialize, or else we have to fail the
             * constructor.
             */
            throw new Exception(""Couldn't initialize"");",1
3435462,0,"            KeyManager kms[] = kmf.getKeyManagers();

            /*
             * Iterate over the returned keymanagers, look
             * for an instance of X509KeyManager.  If found,
             * use that as our ""default"" key manager.
             */
            for (int i = 0; i < kms.length; i++) {
                if (kms[i] instanceof X509KeyManager) {
                    pkixKeyManager = (X509KeyManager) kms[i];
                    return;
                }
            }

            /*
             * Find some other way to initialize, or else we have to fail the
             * constructor.
             */
            throw new Exception(""Couldn't initialize"");",1
3441659,1,"public class sample{
public static RSAPrivateKey getPrivateKey(File privateKeyFile) throws IOException, GeneralSecurityException {
    byte[] keyBytes = new byte[(int)privateKeyFile.length()];
    FileInputStream fis = new FileInputStream(privateKeyFile);
    fis.read(keyBytes);
    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    RSAPrivateKey privKey = (RSAPrivateKey) keyFactory.generatePrivate(spec);
    return privKey;
}
",3
3441659,3,"public class sample{
public static RSAPublicKey getPublicKey(File publicKeyFile) throws IOException, GeneralSecurityException {
    byte[] keyBytes = new byte[(int)publicKeyFile.length()];
    FileInputStream fis = new FileInputStream(publicKeyFile);
    fis.read(keyBytes);
    X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyBytes);
    KeyFactory factory = KeyFactory.getInstance(""RSA"");
    RSAPublicKey pubKey = (RSAPublicKey)factory.generatePublic(publicKeySpec);
    return pubKey;
}
",3
3485422,0,"    Mac mac = Mac.getInstance(""HmacSHA1"");
    SecretKeySpec secret = new SecretKeySpec(key.getBytes(), mac.getAlgorithm());
    mac.init(secret);
    byte[] digest = mac.doFinal(baseString.getBytes());",4
3485422,0,"    Mac mac = Mac.getInstance(""HmacSHA1"");
    SecretKeySpec secret = new SecretKeySpec(key.getBytes(), mac.getAlgorithm());
    mac.init(secret);
    byte[] digest = mac.doFinal(baseString.getBytes());",4
3873411,0,"            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);
            CipherInputStream cis = new CipherInputStream(is, cipher);
            InputStreamReader isr = new InputStreamReader(cis);
            BufferedReader reader = new BufferedReader(isr);
            String line;
            while ((line = reader.readLine()) != null) {
                stringBuilder.append(line).append(EOL);
            }
            is.close();",2
3873411,1,"            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);
            CipherInputStream cis = new CipherInputStream(fis, cipher);
            InputStreamReader isr = new InputStreamReader(cis);
            BufferedReader reader = new BufferedReader(isr);
            String line;
            while ((line = reader.readLine()) != null) {
                stringBuilder.append(line).append(EOL);
            }
            fis.close();",2
3934409,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i=0; i<messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
        return hexString.toString();
",4
3934409,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i=0; i<messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
        return hexString.toString();
",4
3934409,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i=0; i<messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));",4
3934409,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i=0; i<messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
        return hexString.toString();
",4
3964904,0,"    private static PGPPrivateKey findSecretKey(
            PGPSecretKeyRingCollection pgpSec, long keyID, char[] pass)
            throws PGPException, NoSuchProviderException {
        PGPSecretKey pgpSecKey = pgpSec.getSecretKey(keyID);

        if (pgpSecKey == null) {
            return null;
        }

        return pgpSecKey.extractPrivateKey(pass, ""BC"");
    }

    /**
     * decrypt the passed in message stream
     * 
     * @param encrypted
     *            The message to be decrypted.
     * @param passPhrase
     *            Pass phrase (key)
     * 
     * @return Clear text as a byte array. I18N considerations are not handled
     *         by this routine
     * @exception IOException
     * @exception PGPException
     * @exception NoSuchProviderException
     */
    public static byte[] decrypt(byte[] encrypted, InputStream keyIn, char[] password)
            throws IOException, PGPException, NoSuchProviderException {
        InputStream in = new ByteArrayInputStream(encrypted);

        in = PGPUtil.getDecoderStream(in);

        PGPObjectFactory pgpF = new PGPObjectFactory(in);
        PGPEncryptedDataList enc = null;
        Object o = pgpF.nextObject();

        //
        // the first object might be a PGP marker packet.
        //
        if (o instanceof PGPEncryptedDataList) {
            enc = (PGPEncryptedDataList) o;
        } else {
            enc = (PGPEncryptedDataList) pgpF.nextObject();
        }



        //
        // find the secret key
        //
        Iterator it = enc.getEncryptedDataObjects();
        PGPPrivateKey sKey = null;
        PGPPublicKeyEncryptedData pbe = null;
        PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(
                PGPUtil.getDecoderStream(keyIn));

        while (sKey == null && it.hasNext()) {
            pbe = (PGPPublicKeyEncryptedData) it.next();

            sKey = findSecretKey(pgpSec, pbe.getKeyID(), password);
        }

        if (sKey == null) {
            throw new IllegalArgumentException(
                    ""secret key for message not found."");
        }

        InputStream clear = pbe.getDataStream(sKey, ""BC"");



        PGPObjectFactory pgpFact = new PGPObjectFactory(clear);

        PGPCompressedData cData = (PGPCompressedData) pgpFact.nextObject();

        pgpFact = new PGPObjectFactory(cData.getDataStream());

        PGPLiteralData ld = (PGPLiteralData) pgpFact.nextObject();

        InputStream unc = ld.getInputStream();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int ch;

        while ((ch = unc.read()) >= 0) {
            out.write(ch);

        }

        byte[] returnBytes = out.toByteArray();
        out.close();
        return returnBytes;
    }

    /**
     * Simple PGP encryptor between byte[].
     * 
     * @param clearData
     *            The test to be encrypted
     * @param passPhrase
     *            The pass phrase (key). This method assumes that the key is a
     *            simple pass phrase, and does not yet support RSA or more
     *            sophisiticated keying.
     * @param fileName
     *            File name. This is used in the Literal Data Packet (tag 11)
     *            which is really inly important if the data is to be related to
     *            a file to be recovered later. Because this routine does not
     *            know the source of the information, the caller can set
     *            something here for file name use that will be carried. If this
     *            routine is being used to encrypt SOAP MIME bodies, for
     *            example, use the file name from the MIME type, if applicable.
     *            Or anything else appropriate.
     * 
     * @param armor
     * 
     * @return encrypted data.
     * @exception IOException
     * @exception PGPException
     * @exception NoSuchProviderException
     */
    public static byte[] encrypt(byte[] clearData, PGPPublicKey encKey,
            String fileName,boolean withIntegrityCheck, boolean armor)
            throws IOException, PGPException, NoSuchProviderException {
        if (fileName == null) {
            fileName = PGPLiteralData.CONSOLE;
        }

        ByteArrayOutputStream encOut = new ByteArrayOutputStream();

        OutputStream out = encOut;
        if (armor) {
            out = new ArmoredOutputStream(out);
        }

        ByteArrayOutputStream bOut = new ByteArrayOutputStream();

        PGPCompressedDataGenerator comData = new PGPCompressedDataGenerator(
                PGPCompressedDataGenerator.ZIP);
        OutputStream cos = comData.open(bOut); // open it with the final
        // destination
        PGPLiteralDataGenerator lData = new PGPLiteralDataGenerator();

        // we want to generate compressed data. This might be a user option
        // later,
        // in which case we would pass in bOut.
        OutputStream pOut = lData.open(cos, // the compressed output stream
                PGPLiteralData.BINARY, fileName, // ""filename"" to store
                clearData.length, // length of clear data
                new Date() // current time
                );
        pOut.write(clearData);

        lData.close();
        comData.close();

        PGPEncryptedDataGenerator cPk = new PGPEncryptedDataGenerator(
                PGPEncryptedData.CAST5, withIntegrityCheck, new SecureRandom(),
                ""BC"");

        cPk.addMethod(encKey);

        byte[] bytes = bOut.toByteArray();

        OutputStream cOut = cPk.open(out, bytes.length);

        cOut.write(bytes); // obtain the actual bytes from the compressed stream

        cOut.close();

        out.close();

        return encOut.toByteArray();
    }

    private static PGPPublicKey readPublicKey(InputStream in)
            throws IOException, PGPException {
        in = PGPUtil.getDecoderStream(in);

        PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection(in);

        //
        // we just loop through the collection till we find a key suitable for
        // encryption, in the real
        // world you would probably want to be a bit smarter about this.
        //

        //
        // iterate through the key rings.
        //
        Iterator rIt = pgpPub.getKeyRings();

        while (rIt.hasNext()) {
            PGPPublicKeyRing kRing = (PGPPublicKeyRing) rIt.next();
            Iterator kIt = kRing.getPublicKeys();

            while (kIt.hasNext()) {
                PGPPublicKey k = (PGPPublicKey) kIt.next();

                if (k.isEncryptionKey()) {
                    return k;
                }
            }
        }

        throw new IllegalArgumentException(
                ""Can't find encryption key in key ring."");
    }

    public static byte[] getBytesFromFile(File file) throws IOException {
        InputStream is = new FileInputStream(file);

        // Get the size of the file
        long length = file.length();

        if (length > Integer.MAX_VALUE) {
            // File is too large
        }

        // Create the byte array to hold the data
        byte[] bytes = new byte[(int)length];

        // Read in the bytes
        int offset = 0;
        int numRead = 0;
        while (offset < bytes.length
               && (numRead=is.read(bytes, offset, bytes.length-offset)) >= 0) {
            offset += numRead;
        }

        // Ensure all the bytes have been read in
        if (offset < bytes.length) {
            throw new IOException(""Could not completely read file ""+file.getName());
        }

        // Close the input stream and return bytes
        is.close();
        return bytes;
    }
",43
3964904,0,"        Object o = pgpF.nextObject();

        //
        // the first object might be a PGP marker packet.
        //
        if (o instanceof PGPEncryptedDataList) {
            enc = (PGPEncryptedDataList) o;
        } else {
            enc = (PGPEncryptedDataList) pgpF.nextObject();
        }



        //
        // find the secret key
        //
        Iterator it = enc.getEncryptedDataObjects();
        PGPPrivateKey sKey = null;
        PGPPublicKeyEncryptedData pbe = null;
        PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(
                PGPUtil.getDecoderStream(keyIn));
",4
3964904,0,"        if (o instanceof PGPEncryptedDataList) {
            enc = (PGPEncryptedDataList) o;
        } else {
            enc = (PGPEncryptedDataList) pgpF.nextObject();
        }



        //
        // find the secret key
        //
        Iterator it = enc.getEncryptedDataObjects();
        PGPPrivateKey sKey = null;
        PGPPublicKeyEncryptedData pbe = null;",4
3964904,0,"        PGPObjectFactory pgpFact = new PGPObjectFactory(clear);

        PGPCompressedData cData = (PGPCompressedData) pgpFact.nextObject();

        pgpFact = new PGPObjectFactory(cData.getDataStream());

        PGPLiteralData ld = (PGPLiteralData) pgpFact.nextObject();

        InputStream unc = ld.getInputStream();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int ch;

        while ((ch = unc.read()) >= 0) {
            out.write(ch);

        }

        byte[] returnBytes = out.toByteArray();
        out.close();",3
3964904,0,"    private static PGPPublicKey readPublicKey(InputStream in)
            throws IOException, PGPException {
        in = PGPUtil.getDecoderStream(in);

        PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection(in);

        //
        // we just loop through the collection till we find a key suitable for
        // encryption, in the real
        // world you would probably want to be a bit smarter about this.
        //

        //
        // iterate through the key rings.
        //
        Iterator rIt = pgpPub.getKeyRings();

        while (rIt.hasNext()) {
            PGPPublicKeyRing kRing = (PGPPublicKeyRing) rIt.next();
            Iterator kIt = kRing.getPublicKeys();

            while (kIt.hasNext()) {
                PGPPublicKey k = (PGPPublicKey) kIt.next();

                if (k.isEncryptionKey()) {
                    return k;
                }
            }
        }

        throw new IllegalArgumentException(
                ""Can't find encryption key in key ring."");
    }
",4
3964904,0,"        Iterator rIt = pgpPub.getKeyRings();

        while (rIt.hasNext()) {
            PGPPublicKeyRing kRing = (PGPPublicKeyRing) rIt.next();
            Iterator kIt = kRing.getPublicKeys();

            while (kIt.hasNext()) {
                PGPPublicKey k = (PGPPublicKey) kIt.next();

                if (k.isEncryptionKey()) {
                    return k;
                }
            }
        }

        throw new IllegalArgumentException(
                ""Can't find encryption key in key ring."");",4
3964904,0,"            Iterator kIt = kRing.getPublicKeys();

            while (kIt.hasNext()) {
                PGPPublicKey k = (PGPPublicKey) kIt.next();

                if (k.isEncryptionKey()) {
                    return k;
                }
            }",4
3997580,0,"Mac mac = Mac.getInstance(""HmacSha256"");
SecretKeySpec secret = new SecretKeySpec(key.getBytes(), ""HmacSha256"");
mac.init(secret);
byte[] shaDigest = mac.doFinal(phrase.getBytes());",4
3998257,5,"public class MyHttpClient extends DefaultHttpClient {

  final Context context;

  public MyHttpClient(Context context) {
      this.context = context;
  }

  @Override
  protected ClientConnectionManager createClientConnectionManager() {
      SchemeRegistry registry = new SchemeRegistry();
      registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
      // Register for port 443 our SSLSocketFactory with our keystore
      // to the ConnectionManager
      registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
      return new SingleClientConnManager(getParams(), registry);
  }

  private SSLSocketFactory newSslSocketFactory() {
      try {
          // Get an instance of the Bouncy Castle KeyStore format
          KeyStore trusted = KeyStore.getInstance(""BKS"");
          // Get the raw resource, which contains the keystore with
          // your trusted certificates (root and any intermediate certs)
          InputStream in = context.getResources().openRawResource(R.raw.mykeystore);
          try {
              // Initialize the keystore with the provided trusted certificates
              // Also provide the password of the keystore
              trusted.load(in, ""mysecret"".toCharArray());
          } finally {
              in.close();
          }
          // Pass the keystore to the SSLSocketFactory. The factory is responsible
          // for the verification of the server certificate.
          SSLSocketFactory sf = new SSLSocketFactory(trusted);
          // Hostname verification from certificate
          // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506
          sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
          return sf;
      } catch (Exception e) {
          throw new AssertionError(e);
      }
  }
}",1
3998257,5,"  protected ClientConnectionManager createClientConnectionManager() {
      SchemeRegistry registry = new SchemeRegistry();
      registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
      // Register for port 443 our SSLSocketFactory with our keystore
      // to the ConnectionManager
      registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
      return new SingleClientConnManager(getParams(), registry);
  }

  private SSLSocketFactory newSslSocketFactory() {
      try {
          // Get an instance of the Bouncy Castle KeyStore format
          KeyStore trusted = KeyStore.getInstance(""BKS"");
          // Get the raw resource, which contains the keystore with
          // your trusted certificates (root and any intermediate certs)
          InputStream in = context.getResources().openRawResource(R.raw.mykeystore);
          try {
              // Initialize the keystore with the provided trusted certificates
              // Also provide the password of the keystore
              trusted.load(in, ""mysecret"".toCharArray());
          } finally {
              in.close();
          }
          // Pass the keystore to the SSLSocketFactory. The factory is responsible
          // for the verification of the server certificate.",1
3998257,5,"  private SSLSocketFactory newSslSocketFactory() {
      try {
          // Get an instance of the Bouncy Castle KeyStore format
          KeyStore trusted = KeyStore.getInstance(""BKS"");
          // Get the raw resource, which contains the keystore with
          // your trusted certificates (root and any intermediate certs)
          InputStream in = context.getResources().openRawResource(R.raw.mykeystore);
          try {
              // Initialize the keystore with the provided trusted certificates
              // Also provide the password of the keystore
              trusted.load(in, ""mysecret"".toCharArray());
          } finally {
              in.close();
          }
          // Pass the keystore to the SSLSocketFactory. The factory is responsible
          // for the verification of the server certificate.
          SSLSocketFactory sf = new SSLSocketFactory(trusted);
          // Hostname verification from certificate
          // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506
          sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
          return sf;
      } catch (Exception e) {
          throw new AssertionError(e);
      }
  }",1
3998257,5,"          KeyStore trusted = KeyStore.getInstance(""BKS"");
          // Get the raw resource, which contains the keystore with
          // your trusted certificates (root and any intermediate certs)
          InputStream in = context.getResources().openRawResource(R.raw.mykeystore);
          try {
              // Initialize the keystore with the provided trusted certificates
              // Also provide the password of the keystore
              trusted.load(in, ""mysecret"".toCharArray());
          } finally {
              in.close();
          }
          // Pass the keystore to the SSLSocketFactory. The factory is responsible
          // for the verification of the server certificate.",1
4184866,0,"final MessageDigest mDigest = MessageDigest.getInstance(""SHA-224"");
byte[] messageDigest = mDigest.digest(toEncrypt.getBytes());
final BigInteger number = new BigInteger(1, messageDigest);
final String sha = number.toString(16);",4
4200195,2,"    private SSLSocketFactory newSslSocketFactory() {
    try {
        // Get an instance of the Bouncy Castle KeyStore format
        KeyStore trusted = KeyStore.getInstance(""BKS"");
        // Get the raw resource, which contains the keystore with
        // your trusted certificates (root and any intermediate certs)
        InputStream in = context.getResources().openRawResource(R.raw.mykeystore);
        try {
            // Initialize the keystore with the provided trusted certificates
            // Also provide the password of the keystore
            trusted.load(in, ""testtest"".toCharArray());
        } finally {
            in.close();
        }
        // Pass the keystore to the SSLSocketFactory. The factory is responsible
        // for the verification of the server certificate.
        SSLSocketFactory sf = new SSLSocketFactory(trusted);
        // Hostname verification from certificate
        // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506
        sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
        return sf;
    } catch (Exception e) {
        throw new AssertionError(e);
    }
}
",1
4200195,2,"        KeyStore trusted = KeyStore.getInstance(""BKS"");
        // Get the raw resource, which contains the keystore with
        // your trusted certificates (root and any intermediate certs)
        InputStream in = context.getResources().openRawResource(R.raw.mykeystore);
        try {
            // Initialize the keystore with the provided trusted certificates
            // Also provide the password of the keystore
            trusted.load(in, ""testtest"".toCharArray());
        } finally {
            in.close();
        }
        // Pass the keystore to the SSLSocketFactory. The factory is responsible
        // for the verification of the server certificate.",1
4246280,11,"public class sample{
private static byte[] cipherData(PaddedBufferedBlockCipher cipher, byte[] data)
        throws Exception
{
    int minSize = cipher.getOutputSize(data.length);
    byte[] outBuf = new byte[minSize];
    int length1 = cipher.processBytes(data, 0, data.length, outBuf, 0);
    int length2 = cipher.doFinal(outBuf, length1);
    int actualLength = length1 + length2;
    byte[] result = new byte[actualLength];
    System.arraycopy(outBuf, 0, result, 0, result.length);
    return result;
}

private static byte[] decrypt(byte[] cipher, byte[] key, byte[] iv) throws Exception
{
    PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher(new CBCBlockCipher(
            new AESEngine()));
    CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(key), iv);
    aes.init(false, ivAndKey);
    return cipherData(aes, cipher);
}

private static byte[] encrypt(byte[] plain, byte[] key, byte[] iv) throws Exception
{
    PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher(new CBCBlockCipher(
            new AESEngine()));
    CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(key), iv);
    aes.init(true, ivAndKey);
    return cipherData(aes, plain);
}
",2
4246280,11,"    int minSize = cipher.getOutputSize(data.length);
    byte[] outBuf = new byte[minSize];
    int length1 = cipher.processBytes(data, 0, data.length, outBuf, 0);
    int length2 = cipher.doFinal(outBuf, length1);
    int actualLength = length1 + length2;
    byte[] result = new byte[actualLength];",2
4246280,11,"private static byte[] decrypt(byte[] cipher, byte[] key, byte[] iv) throws Exception
{
    PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher(new CBCBlockCipher(
            new AESEngine()));
    CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(key), iv);
    aes.init(false, ivAndKey);
    return cipherData(aes, cipher);
}
",2
4246280,11,"private static byte[] encrypt(byte[] plain, byte[] key, byte[] iv) throws Exception
{
    PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher(new CBCBlockCipher(
            new AESEngine()));
    CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(key), iv);
    aes.init(true, ivAndKey);
    return cipherData(aes, plain);
}
",2
4534430,0,"SecretKeySpec key = new SecretKeySpec((keyString).getBytes(""UTF-8""), ""HmacSHA1"");
Mac mac = Mac.getInstance(""HmacSHA1"");
mac.init(key);

byte[] bytes = mac.doFinal(s.getBytes(""UTF-8""));
",4
4573447,0,"            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);
            SecretKey tmp = factory.generateSecret(pbeKeySpec);
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
            byte[] key = secret.getEncoded();",2
4599267,0,"    byte[] out = new byte[cipher.getOutputSize(cryptoBytes.length)];
    int offset = cipher.processBytes(cryptoBytes, 0, cryptoBytes.length, out, 0);
    cipher.doFinal(out, offset);",2
4716304,0,"public class ValicertX509TrustManager implements X509TrustManager {

    X509TrustManager pkixTrustManager;

    ValicertX509TrustManager() throws Exception {

        String valicertFile = ""/certificates/ValicertRSAPublicRootCAv1.cer"";
        String commwebDRFile = ""/certificates/DR_10570.migs.mastercard.com.au.crt"";
        String commwebPRODFile = ""/certificates/PROD_10549.migs.mastercard.com.au.new.crt"";

        Certificate valicert = CertificateFactory.getInstance(""X509"").generateCertificate(this.getClass().getResourceAsStream(valicertFile));
        Certificate commwebDR = CertificateFactory.getInstance(""X509"").generateCertificate(this.getClass().getResourceAsStream(commwebDRFile));
        Certificate commwebPROD = CertificateFactory.getInstance(""X509"").generateCertificate(this.getClass().getResourceAsStream(commwebPRODFile));

        KeyStore keyStore = KeyStore.getInstance(""JKS"");
        keyStore.load(null, """".toCharArray());
        keyStore.setCertificateEntry(""valicert"", valicert);
        keyStore.setCertificateEntry(""commwebDR"", commwebDR);
        keyStore.setCertificateEntry(""commwebPROD"", commwebPROD);

        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(""PKIX"");
        trustManagerFactory.init(keyStore);

        TrustManager trustManagers[] = trustManagerFactory.getTrustManagers();

        for(TrustManager trustManager : trustManagers) {
            if(trustManager instanceof X509TrustManager) {
                pkixTrustManager = (X509TrustManager) trustManager;
                return;
            }
        }

        throw new Exception(""Couldn't initialize"");
    }

    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        pkixTrustManager.checkServerTrusted(chain, authType);
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        pkixTrustManager.checkServerTrusted(chain, authType);
    }

    public X509Certificate[] getAcceptedIssuers() {
        return pkixTrustManager.getAcceptedIssuers();
    }
}",1
4716304,0,"        keyStore.setCertificateEntry(""commwebPROD"", commwebPROD);

        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(""PKIX"");
        trustManagerFactory.init(keyStore);

        TrustManager trustManagers[] = trustManagerFactory.getTrustManagers();

        for(TrustManager trustManager : trustManagers) {
            if(trustManager instanceof X509TrustManager) {
                pkixTrustManager = (X509TrustManager) trustManager;
                return;
            }
        }

        throw new Exception(""Couldn't initialize"");",1
4716304,1,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    public boolean equals(Object obj) {
        return ((obj != null) && obj.getClass().equals(ValicertSSLProtocolSocketFactory.class));
    }

    public int hashCode() {
        return ValicertSSLProtocolSocketFactory.class.hashCode();
    }",1
4716304,2,"public class sample{
 public void foo(){
Protocol.registerProtocol(""vhttps"", new Protocol(""vhttps"", new ValicertSSLProtocolSocketFactory(), 443));
PostMethod postMethod = new PostMethod(url);
for (Map.Entry<String, String> entry : params.entrySet()) {
    postMethod.addParameter(entry.getKey(), StringUtils.Nz(entry.getValue()));
}

HttpClient client = new HttpClient();
int status = client.executeMethod(postMethod);
if (status == 200) {
    StringBuilder resultBuffer = new StringBuilder();
    resultBuffer.append(postMethod.getResponseBodyAsString());
    return new HttpResponse(resultBuffer.toString(), """");
} else {
    throw new IOException(""Invalid response code: "" + status);
}

}",1
4837230,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
4897062,1,"        mac = Mac.getInstance(""HmacSHA256"");
        SecretKeySpec secret = new SecretKeySpec(key.getBytes(), mac.getAlgorithm());
        mac.init(secret);
        byte[] digest = mac.doFinal(baseString.getBytes());",4
5161527,1,"    public boolean validate(X509Certificate certificate, CertPath certPath,
            PKIXParameters parameters) throws GeneralSecurityException {
        try {
            CertPathValidator cpv = CertPathValidator.getInstance(""PKIX"");
            PKIXCertPathValidatorResult result = (PKIXCertPathValidatorResult) cpv
                    .validate(certPath, parameters);
            Signature.LOG.debug(""Validation result is: "" + result);
            return true; // if no exception is thrown
        } catch (CertPathValidatorException cpve) {

            // if the exception is (or is caused by)
            // CertificateRevokedException, return false;
            // otherwise re-throw, because this indicates a failure to perform
            // the validation
            Throwable cause = ExceptionUtils.getRootCause(cpve);
            Class<? extends Throwable> exceptionClass = cause != null ? cause.getClass()
                    : cpve.getClass();
            if (exceptionClass.getSimpleName().equals(""CertificateRevokedException"")) {
                return false;
            }
            throw cpve;
        }
    }
",3
5449971,0,"    Mac mac = Mac.getInstance(""HmacSHA1"");
    SecretKeySpec sk = new SecretKeySpec(key.getBytes(),mac.getAlgorithm());  
    mac.init(sk);
    byte[] result = mac.doFinal(src.getBytes());

",4
5449971,0,"    Mac mac = Mac.getInstance(""HmacSHA1"");
    SecretKeySpec sk = new SecretKeySpec(key.getBytes(),mac.getAlgorithm());  
    mac.init(sk);
    byte[] result = mac.doFinal(src.getBytes());

",4
5518901,2,"    public void encrypt(SecretKey key, File from, File to)
        throws  Exception
    {
        Cipher ourCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        ourCipher.init(Cipher.ENCRYPT_MODE, key, params );
        crypt(ourCipher, from, to);
    }
",2
5518901,2,"    public void decrypt(SecretKey key, File from, File to)
        throws Exception
    {
        Cipher ourCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        ourCipher.init(Cipher.DECRYPT_MODE, key, params );
        crypt(ourCipher, from, to);
    }

",2
5520786,0,"        IvParameterSpec ivSpec = new IvParameterSpec(iv);

        // hash keyString with SHA-256 and crop the output to 128-bit for key
        MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
        digest.update(keyString.getBytes());
        byte[] key = new byte[16];
        System.arraycopy(digest.digest(), 0, key, 0, key.length);
        SecretKeySpec keySpec = new SecretKeySpec(key, ""AES"");

        // encrypt
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);",4
5641932,0,"    cipher.init(false, params);

    // create a temporary buffer to decode into (it'll include padding)
    byte[] buf = new byte[cipher.getOutputSize(encData.length)];
    int len = cipher.processBytes(encData, 0, encData.length, buf, 0);
    len += cipher.doFinal(buf, len);

    // remove padding
    byte[] out = new byte[len];
    System.arraycopy(buf, 0, out, 0, len);

    // return string representation of decoded bytes",2
5641932,0,"    byte[] buf = new byte[cipher.getOutputSize(encData.length)];
    int len = cipher.processBytes(encData, 0, encData.length, buf, 0);
    len += cipher.doFinal(buf, len);

    // remove padding",2
5756322,0,"        BASE64Decoder decoder = new BASE64Decoder();

        byte[] publicKeyBytes = decoder.decodeBuffer(base64PubKey);

        EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);
        RSAPublicKey publicKey = (RSAPublicKey) KeyFactory.getInstance(""RSA"").generatePublic(publicKeySpec);

        byte[] modulusBytes = publicKey.getModulus().toByteArray();
        byte[] exponentBytes = publicKey.getPublicExponent().toByteArray();

        modulusBytes = stripLeadingZeros(modulusBytes);

        BASE64Encoder encoder = new BASE64Encoder();
        String modulusB64 = encoder.encode(modulusBytes);
        String exponentB64 = encoder.encode(exponentBytes);
",3
5757055,0,"public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException  { 
    MessageDigest md = MessageDigest.getInstance(""SHA-1"");
    byte[] sha1hash = new byte[40];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    sha1hash = md.digest();
    return convertToHex(sha1hash);
} 
",4
5757055,0,"    MessageDigest md = MessageDigest.getInstance(""SHA-1"");
    byte[] sha1hash = new byte[40];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    sha1hash = md.digest();",4
5793865,0,"        SSLSocket sslsock = (SSLSocket) ( ( sock != null ) ? sock
            : createSocket() );

        if ( ( localAddress != null ) || ( localPort > 0 ) ) {

            // we need to bind explicitly
            if ( localPort < 0 ) {
                localPort = 0; // indicates ""any""
            }

            InetSocketAddress isa = new InetSocketAddress(localAddress,
                localPort);
            sslsock.bind(isa);
        }
",1
5831501,1,"KeyStore certStore = KeyStore.getInstance(""BKS"");
InputStream in = context.getResources().openRawResource(R.raw.signature_certstore);
try {
    certStore.load(in, ""some_password"".toCharArray());
} finally {
    in.close();
}
",1
5951605,3,"      InputStream clientTruststoreIs = getResources().openRawResource(R.raw.truststore);
      KeyStore trustStore = null;
      trustStore = KeyStore.getInstance(""BKS"");
      trustStore.load(clientTruststoreIs, ""MyPassword"".toCharArray());

      System.out.println(""Loaded server certificates: "" + trustStore.size());

      // initialize trust manager factory with the read truststore
      TrustManagerFactory trustManagerFactory = null;
      trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());",2
5951605,3,"      InputStream keyStoreStream = getResources().openRawResource(R.raw.client);
      KeyStore keyStore = null;
      keyStore = KeyStore.getInstance(""BKS"");
      keyStore.load(keyStoreStream, ""MyPassword"".toCharArray());

      System.out.println(""Loaded client certificates: "" + keyStore.size());

      // initialize key manager factory with the read client certificate
      KeyManagerFactory keyManagerFactory = null;
      keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());",2
5968994,0,"    Mac mac = Mac.getInstance(""HmacSHA1"");
    SecretKeySpec secret = new SecretKeySpec(llave.getBytes(), ""HmacSHA1"");
    mac.init(secret);
    byte[] digest = mac.doFinal(cadena.getBytes());",4
5980789,0,"public class AeSimpleSHA1 {
    private static String convertToHex(byte[] data) {
        StringBuilder buf = new StringBuilder();
        for (byte b : data) {
            int halfbyte = (b >>> 4) & 0x0F;
            int two_halfs = 0;
            do {
                buf.append((0 <= halfbyte) && (halfbyte <= 9) ? (char) ('0' + halfbyte) : (char) ('a' + (halfbyte - 10)));
                halfbyte = b & 0x0F;
            } while (two_halfs++ < 1);
        }
        return buf.toString();
    }

    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] textBytes = text.getBytes(""iso-8859-1"");
        md.update(textBytes, 0, textBytes.length);
        byte[] sha1hash = md.digest();
        return convertToHex(sha1hash);
    }
}",4
5980789,0,"        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] textBytes = text.getBytes(""iso-8859-1"");
        md.update(textBytes, 0, textBytes.length);
        byte[] sha1hash = md.digest();",4
6120698,0,"public class Sha1Hex {

    public String makeSHA1Hash(String input)
            throws NoSuchAlgorithmException, UnsupportedEncodingException
        {
            MessageDigest md = MessageDigest.getInstance(""SHA1"");
            md.reset();
            byte[] buffer = input.getBytes(""UTF-8"");
            md.update(buffer);
            byte[] digest = md.digest();

            String hexStr = """";
            for (int i = 0; i < digest.length; i++) {
                hexStr +=  Integer.toString( ( digest[i] & 0xff ) + 0x100, 16).substring( 1 );
            }
            return hexStr;
        }
}",4
6164414,0,"SecureRandom random = new SecureRandom();
byte[] salt = new byte[8];
random.nextBytes(salt);

// Create PBE parameter set
PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, count);
PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());",2
6169889,1,"    public static String encrypt(String seed, String cleartext) throws Exception {
            byte[] rawKey = getRawKey(seed.getBytes());
            byte[] result = encrypt(rawKey, cleartext.getBytes());
            return toBase64(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
            byte[] rawKey = getRawKey(seed.getBytes());
            byte[] enc = fromBase64(encrypted);
            byte[] result = decrypt(rawKey, enc);
            return new String(result);
    }
",2
6169889,1,"    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        IvParameterSpec ivParameterSpec = new IvParameterSpec(raw);

        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivParameterSpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }
",2
6169889,1,"    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        IvParameterSpec ivParameterSpec = new IvParameterSpec(raw);

        cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivParameterSpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toBase64(byte[] buf)
    {
        return Base64.encodeBytes(buf);
    }

    public static byte[] fromBase64(String str) throws Exception
    {
        return Base64.decode(str);
    }",2
6229899,0,"_cipher.init(true, new KeyParameter(keyByte));

           // Determine the minimum output buffer size
byte[] outBytes = new byte[_cipher.getOutputSize(inBytes.length)];

        // 'len' is the actual size returned
     int len = _cipher.processBytes(inBytes, 0, inBytes.length, outBytes, 0);
",2
6229899,0,"byte[] outBytes = new byte[_cipher.getOutputSize(inBytes.length)];

        // 'len' is the actual size returned
     int len = _cipher.processBytes(inBytes, 0, inBytes.length, outBytes, 0);

_cipher.doFinal(outBytes,len);
",2
6252501,0,"public class sample{
 public void foo(){
final Cipher cipher = Cipher.getInstance(""AES/CFB/NoPadding"", ""SunJCE"");
final SecretKey skeySpec = KeyGenerator.getInstance(""AES"")
        .generateKey();
cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
System.out.println(Arrays.toString(cipher.doFinal(new byte[] { 0, 1, 2,
            3 })));

}",2
6293816,1,"public byte[] createSha1(File file) throws Exception  {
    MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
    InputStream fis = new FileInputStream(file);
    int n = 0;
    byte[] buffer = new byte[8192];
    while (n != -1) {
        n = fis.read(buffer);
        if (n > 0) {
            digest.update(buffer, 0, n);
        }
    }
    return digest.digest();
}
",4
6347150,0,"  @Override protected ClientConnectionManager createClientConnectionManager() {
    SchemeRegistry registry = new SchemeRegistry();
    registry.register(
        new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
    registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
    return new SingleClientConnManager(getParams(), registry);
  }

  private SSLSocketFactory newSslSocketFactory() {
    try {
      KeyStore trusted = KeyStore.getInstance(""BKS"");
      InputStream in = context.getResources().openRawResource(R.raw.mystore);
      try {
        trusted.load(in, ""ez24get"".toCharArray());
      } finally {
        in.close();
      }",1
6347150,0,"      KeyStore trusted = KeyStore.getInstance(""BKS"");
      InputStream in = context.getResources().openRawResource(R.raw.mystore);
      try {
        trusted.load(in, ""ez24get"".toCharArray());
      } finally {
        in.close();
      }",1
6378872,6,"public class sample{
protected org.apache.http.conn.ssl.SSLSocketFactory createAdditionalCertsSSLSocketFactory() {
    try {
        final KeyStore ks = KeyStore.getInstance(""BKS"");

        // the bks file we generated above
        final InputStream in = context.getResources().openRawResource( R.raw.mystore);  
        try {
            // don't forget to put the password used above in strings.xml/mystore_password
            ks.load(in, context.getString( R.string.mystore_password ).toCharArray());
        } finally {
            in.close();
        }

        return new AdditionalKeyStoresSSLSocketFactory(ks);

    } catch( Exception e ) {
        throw new RuntimeException(e);
    }
}
",1
6378872,7,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }



    /**
     * Based on http://download.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#X509TrustManager
     */",1
6378872,7,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }



    /**
     * Based on http://download.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#X509TrustManager
     */
    public static class AdditionalKeyStoresTrustManager implements X509TrustManager {

        protected ArrayList<X509TrustManager> x509TrustManagers = new ArrayList<X509TrustManager>();


        protected AdditionalKeyStoresTrustManager(KeyStore... additionalkeyStores) {
            final ArrayList<TrustManagerFactory> factories = new ArrayList<TrustManagerFactory>();

            try {
                // The default Trustmanager with default keystore
                final TrustManagerFactory original = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                original.init((KeyStore) null);
                factories.add(original);

                for( KeyStore keyStore : additionalkeyStores ) {
                    final TrustManagerFactory additionalCerts = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                    additionalCerts.init(keyStore);
                    factories.add(additionalCerts);
                }

            } catch (Exception e) {
                throw new RuntimeException(e);
            }



            /*
             * Iterate over the returned trustmanagers, and hold on
             * to any that are X509TrustManagers
             */
            for (TrustManagerFactory tmf : factories)
                for( TrustManager tm : tmf.getTrustManagers() )
                    if (tm instanceof X509TrustManager)
                        x509TrustManagers.add( (X509TrustManager)tm );


            if( x509TrustManagers.size()==0 )
                throw new RuntimeException(""Couldn't find any X509TrustManagers"");

        }

        /*
         * Delegate to the default trust manager.
         */
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            final X509TrustManager defaultX509TrustManager = x509TrustManagers.get(0);
            defaultX509TrustManager.checkClientTrusted(chain, authType);
        }

        /*
         * Loop over the trustmanagers until we find one that accepts our server
         */
        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            for( X509TrustManager tm : x509TrustManagers ) {
                try {
                    tm.checkServerTrusted(chain,authType);
                    return;
                } catch( CertificateException e ) {
                    // ignore
                }
            }
            throw new CertificateException();
        }

        public X509Certificate[] getAcceptedIssuers() {
            final ArrayList<X509Certificate> list = new ArrayList<X509Certificate>();
            for( X509TrustManager tm : x509TrustManagers )
                list.addAll(Arrays.asList(tm.getAcceptedIssuers()));
            return list.toArray(new X509Certificate[list.size()]);
        }
    }
",1
6378872,7,"            } catch (Exception e) {
                throw new RuntimeException(e);
            }



            /*
             * Iterate over the returned trustmanagers, and hold on
             * to any that are X509TrustManagers
             */
            for (TrustManagerFactory tmf : factories)
                for( TrustManager tm : tmf.getTrustManagers() )
                    if (tm instanceof X509TrustManager)
                        x509TrustManagers.add( (X509TrustManager)tm );

",1
6378872,7,"        public X509Certificate[] getAcceptedIssuers() {
            final ArrayList<X509Certificate> list = new ArrayList<X509Certificate>();
            for( X509TrustManager tm : x509TrustManagers )
                list.addAll(Arrays.asList(tm.getAcceptedIssuers()));
            return list.toArray(new X509Certificate[list.size()]);
        }",1
6386992,1,"        KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM);
        keyGen.init(AES_KEY_SIZE); //set the key size

        //generate the key
        SecretKey skey = keyGen.generateKey();

        //convert to binary
        byte[] rawAesKey = skey.getEncoded();

        //initialize the secret key with the appropriate algorithm
        SecretKeySpec skeySpec = new SecretKeySpec(rawAesKey, ALGORITHM);

        //get an instance of the symmetric cipher",2
6484679,0,"            for (Signature signature : info.signatures) {
                MessageDigest md;

                    md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    String something = new String(Base64.encode(md.digest(), 0));
                    Log.e(""hash key"", something);
        } ",4
6484679,0,"            for (Signature signature : info.signatures) {
                MessageDigest md;

                    md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    String something = new String(Base64.encode(md.digest(), 0));
                    Log.e(""hash key"", something);
        } 
        }
        catch (NameNotFoundException e1) {
            // TODO Auto-generated catch block
            Log.e(""name not found"", e1.toString());
        }

             catch (NoSuchAlgorithmException e) {
                // TODO Auto-generated catch block
                 Log.e(""no such an algorithm"", e.toString());
            }
             catch (Exception e){
                 Log.e(""exception"", e.toString());
             }
",4
6512854,0,"        for (Signature signature : info.signatures) {
            MessageDigest md;

                md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String something = new String(Base64.encode(md.digest(), 0));
                Log.e(""hash key"", something);
        } ",4
6512854,0,"        for (Signature signature : info.signatures) {
            MessageDigest md;

                md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String something = new String(Base64.encode(md.digest(), 0));
                Log.e(""hash key"", something);
        } 
    } catch (NameNotFoundException e1) {            
        Log.e(""name not found"", e1.toString());
    } catch (NoSuchAlgorithmException e) {
             Log.e(""no such an algorithm"", e.toString());
     }catch (Exception e){
             Log.e(""exception"", e.toString());
     }
",4
6541643,0,"    try {

        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, iterationCount);
        SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);

        ecipher = Cipher.getInstance(key.getAlgorithm());
        dcipher = Cipher.getInstance(key.getAlgorithm());

        // Prepare the parameters to the cipthers
        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);

        ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
        dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
",2
6553036,0,"    {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception
    {
        if(text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)
        {           
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;
    }
",2
6553036,0,"    {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception
    {
        if(text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)
        {           
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception
    {
        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)
        {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }



    public static String bytesToHex(byte[] data)
    {
        if (data==null)
        {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i=0; i<len; i++) {
            if ((data[i]&0xFF)<16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i]&0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        } else if (str.length() < 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i<len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            }
            return buffer;
        }
    }



    private static String padString(String source)
    {
      char paddingChar = ' ';
      int size = 16;
      int x = source.length() % size;
      int padLength = size - x;

      for (int i = 0; i < padLength; i++)
      {
          source += paddingChar;
      }

      return source;
    }",2
6553036,0,"        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }",2
6553036,0,"        if(text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)",2
6553036,0,"        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)
        {           
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;",2
6553036,0,"    public byte[] decrypt(String code) throws Exception
    {
        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)
        {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }



    public static String bytesToHex(byte[] data)
    {
        if (data==null)
        {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i=0; i<len; i++) {
            if ((data[i]&0xFF)<16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i]&0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        } else if (str.length() < 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i<len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            }
            return buffer;
        }
    }


",2
6553036,0,"        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)",2
6553036,0,"        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)
        {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }



    public static String bytesToHex(byte[] data)
    {
        if (data==null)
        {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i=0; i<len; i++) {
            if ((data[i]&0xFF)<16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i]&0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        } else if (str.length() < 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i<len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            }
            return buffer;
        }
    }



    private static String padString(String source)
    {
      char paddingChar = ' ';
      int size = 16;
      int x = source.length() % size;
      int padLength = size - x;

      for (int i = 0; i < padLength; i++)
      {
          source += paddingChar;
      }

      return source;
    }",2
6565597,0,"        byte[] array = md.digest(md5.getBytes());
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < array.length; ++i) {
          sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3));
       }
        return sb.toString();",4
6573640,0,"    KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITHM);
    keyGen.init(AES_KEY_SIZE); // set the key size

    // generate the key
    SecretKey skey = keyGen.generateKey();

    // convert to binary
    byte[] rawAesKey = skey.getEncoded();

    // initialize the secret key with the appropriate algorithm
    SecretKeySpec skeySpec = new SecretKeySpec(rawAesKey, ALGORITHM);

    // get an instance of the symmetric cipher",2
6628120,1,"            sGen.initSign(PGPSignature.BINARY_DOCUMENT, pgpPrivKey);

            Iterator it = pgpSec.getPublicKey().getUserIDs();
            if (it.hasNext()) {
                PGPSignatureSubpacketGenerator spGen = new PGPSignatureSubpacketGenerator();
                spGen.setSignerUserID(false, (String)it.next());
                sGen.setHashedSubpackets(spGen.generate());
            }
",4
6631656,0,"      TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());  
      factory.init(keystore);  
      TrustManager[] trustmanagers = factory.getTrustManagers();  
      if (trustmanagers.length == 0) 
      {  
        throw new NoSuchAlgorithmException(""no trust manager found"");  
      }  
      this.standardTrustManager = (X509TrustManager) trustmanagers[0];  ",1
6631656,0,"            boolean foundNext = false;
            for (int nextIndex = currIndex + 1;
                           nextIndex < certificates.length;
                           ++nextIndex) 
            {
              if (certificates[currIndex].getIssuerDN().equals(
                            certificates[nextIndex].getSubjectDN())) 
              {
                foundNext = true;
                // Exchange certificates so that 0 through currIndex + 1 are in proper order
                if (nextIndex != currIndex + 1) 
                {
                  X509Certificate tempCertificate = certificates[nextIndex];
                  certificates[nextIndex] = certificates[currIndex + 1];
                  certificates[currIndex + 1] = tempCertificate;
                }
                break;
            }
            }
            if (!foundNext) break;
      }

          // 2. we exam if the last traced certificate is self issued and it is expired.
          // If so, we drop it and pass the rest to checkServerTrusted(), hoping we might
          // have a similar but unexpired trusted root.
          chainLength = currIndex + 1;
          X509Certificate lastCertificate = certificates[chainLength - 1];
          Date now = new Date();
          if (lastCertificate.getSubjectDN().equals(lastCertificate.getIssuerDN())
                  && now.after(lastCertificate.getNotAfter())) 
          {
            --chainLength;
          }",1
6631656,1,"      SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());  

      if ((localAddress != null) || (localPort > 0)) 
      {  
        // we need to bind explicitly  
        if (localPort < 0) 
        {  
          localPort = 0; // indicates ""any""  
        }  
        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);  
        sslsock.bind(isa);  
      }  
",1
6631656,1,"    public Socket createSocket(Socket socket,
                                   String host, 
                                   int port,
                                   boolean autoClose) throws IOException,  
                                                             UnknownHostException 
    {  
      return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);  
    }  

    // -------------------------------------------------------------------  
    // javadoc in org.apache.http.conn.scheme.SocketFactory says :  
    // Both Object.equals() and Object.hashCode() must be overridden  
    // for the correct operation of some connection managers  
    // -------------------------------------------------------------------  

    public boolean equals(Object obj) {  
        return ((obj != null) && obj.getClass().equals(EasySSLSocketFactory.class));  
    }  

    public int hashCode() {  
        return EasySSLSocketFactory.class.hashCode();  
    }  ",1
6725651,2,"        try {
            // Create the key
            KeySpec keySpec = new PBEKeySpec(passPhrase.toCharArray(), salt,
                    iterationCount);
            SecretKey key = SecretKeyFactory.getInstance(
                    ""PBEWITHSHA256AND128BITAES-CBC-BC"").generateSecret(keySpec);
            ecipher = Cipher.getInstance(key.getAlgorithm());
            dcipher = Cipher.getInstance(key.getAlgorithm());

            // Prepare the parameter to the ciphers
            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt,
                    iterationCount);

            // Create the ciphers
            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);",2
6788456,1,"KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
sr.setSeed(keyStart);
kgen.init(128, sr); // 192 and 256 bits may not be available
SecretKey skey = kgen.generateKey();
byte[] key = skey.getEncoded();    

// encrypt",5
6843390,0,"public class sample{
public byte[] hash(String password) throws NoSuchAlgorithmException {
    MessageDigest sha256 = MessageDigest.getInstance(""SHA-256"");        
    byte[] passBytes = password.getBytes();
    byte[] passHash = sha256.digest(passBytes);
    return passHash;
}
",4
6968930,1,"      BASE64Decoder decoder = new BASE64Decoder();

      byte[] publicKeyBytes = decoder.decodeBuffer(base64PubKey);

      EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyBytes);
      RSAPublicKey publicKey = (RSAPublicKey) KeyFactory.getInstance(""RSA"").generatePublic(publicKeySpec);

      byte[] modulusBytes = publicKey.getModulus().toByteArray();
      byte[] exponentBytes = publicKey.getPublicExponent().toByteArray();

      modulusBytes = stripLeadingZeros1(modulusBytes);

      BASE64Encoder encoder = new BASE64Encoder();
      String modulusB64 = encoder.encode(modulusBytes);
      String exponentB64 = encoder.encode(exponentBytes);",3
7005253,2,"TrustManagerFactory tmf = TrustManagerFactory
                    .getInstance(TrustManagerFactory.getDefaultAlgorithm());
tmf.init((KeyStore) null);
X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];",1
7006036,0,"    private byte[] generateSalt(int size) {
        byte[] salt = new byte[size];
        rand.nextBytes(salt);

        return salt;
    }

    private SecretKey generateKey(String algorithm, int keySize, byte[] salt) throws NoSuchProviderException, NoSuchAlgorithmException, InvalidKeySpecException{
        SecretKeyFactory factory = SecretKeyFactory.getInstance(KEY_ALGORITHM);
        PBEKeySpec pbeKeySpec = new PBEKeySpec(passwd.toCharArray(), salt, 100000);
        SecretKey tmpKey = factory.generateSecret(pbeKeySpec);
        byte[] keyBytes = new byte[keySize / 8];
        System.arraycopy(tmpKey.getEncoded(), 0, keyBytes, 0, keyBytes.length);

        return new SecretKeySpec(keyBytes, algorithm);
    }

    private byte[] generateIV(Cipher cipher) {
        byte[] iv = new byte[cipher.getBlockSize()];
        rand.nextBytes(iv);

        return iv;
    }

    private byte[] appendArrays(byte[] firstArray, byte[] secondArray) {
        final byte[] result = new byte[firstArray.length + secondArray.length];

        System.arraycopy(firstArray, 0, result, 0, firstArray.length);
        System.arraycopy(secondArray, 0, result, firstArray.length, secondArray.length);

            return result;
    }


    public byte[] encrypt(String algorithm, int keySize, final byte[] message) throws Exception {
        Cipher cipher = Cipher.getInstance(algorithm + MODE_PADDING);

        // The salt size for the chosen algorithm is set to be equal 
        // to the algorithm's block size (if it is a block algorithm).
        int saltSizeBytes = DEFAULT_SALT_SIZE_BYTES;
        int algorithmBlockSize = cipher.getBlockSize();
        if (algorithmBlockSize > 0) {
            saltSizeBytes = algorithmBlockSize;
        }

        // Create salt
        final byte[] salt = generateSalt(saltSizeBytes);

        SecretKey key = generateKey(algorithm, keySize, salt);

        // create a new IV for each encryption
        final IvParameterSpec ivParamSpec = new IvParameterSpec(generateIV(cipher));

        // Perform encryption using the Cipher
        cipher.init(Cipher.ENCRYPT_MODE, key, ivParamSpec);
        byte[] encryptedMessage = cipher.doFinal(message);

        // append the IV and salt
        encryptedMessage = appendArrays(ivParamSpec.getIV(), encryptedMessage);
        encryptedMessage = appendArrays(salt, encryptedMessage);

        return encryptedMessage;
    }
",2
7006036,0,"        byte[] decryptedMessage = engine.decrypt(""AES"", 128, encryptedMessage);
        if (message.equals(new String(decryptedMessage))) {
            System.out.println(""AES OK"");
        }

        encryptedMessage = engine.encrypt(""Serpent"", 256, message.getBytes());
        decryptedMessage = engine.decrypt(""Serpent"", 256, encryptedMessage);
        if (message.equals(new String(decryptedMessage))) {
            System.out.println(""Serpent OK"");
        }
",2
7006036,0,"        decryptedMessage = engine.decrypt(""Serpent"", 256, encryptedMessage);
        if (message.equals(new String(decryptedMessage))) {
            System.out.println(""Serpent OK"");
        }

        encryptedMessage = engine.encrypt(""TwoFish"", 256, message.getBytes());
        decryptedMessage = engine.decrypt(""TwoFish"", 256, encryptedMessage);
        if (message.equals(new String(decryptedMessage))) {
            System.out.println(""TwoFish OK"");
        }",2
7016969,0,"        KeyStore clientStore = KeyStore.getInstance(""PKCS12"");
        clientStore.load(new FileInputStream(""test.p12""), ""testPass"".toCharArray());

        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        kmf.init(clientStore, ""testPass"".toCharArray());
        KeyManager[] kms = kmf.getKeyManagers();

        KeyStore trustStore = KeyStore.getInstance(""JKS"");
        trustStore.load(new FileInputStream(""cacerts""), ""changeit"".toCharArray());

        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init(trustStore);
        TrustManager[] tms = tmf.getTrustManagers();
",1
7016969,0,"        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        kmf.init(clientStore, ""testPass"".toCharArray());
        KeyManager[] kms = kmf.getKeyManagers();

        KeyStore trustStore = KeyStore.getInstance(""JKS"");
        trustStore.load(new FileInputStream(""cacerts""), ""changeit"".toCharArray());

        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init(trustStore);
        TrustManager[] tms = tmf.getTrustManagers();
",-1
7146381,0,"  public static byte[] sha1Digest(byte[] data) {
    MessageDigest mdSha1 = null;
    try {
      mdSha1 = MessageDigest.getInstance(""SHA-1"");
    } catch (NoSuchAlgorithmException e1) {
      Log.e(LOG_TAG, ""Error initializing SHA1 message digest"");
    }
    mdSha1.update(data);
    byte[] sha1hash = mdSha1.digest();
    return sha1hash;
  }


  /**
   * Generates SHA-256 digest of the provided data.
   * 
   * @param data the data to digest
   * @return SHA-256 digest of the provided data.
   */",4
7146381,0,"  public static byte[] sha256Digest(byte[] data) {
    MessageDigest mdSha256 = null;
    try {
      mdSha256 = MessageDigest.getInstance(""SHA-256"");
    } catch (NoSuchAlgorithmException e1) {
      Log.e(LOG_TAG, ""Error initializing SHA1 message digest"");
    }
    mdSha256.update(data);
    byte[] sha256hash = mdSha256.digest();
    return sha256hash;
  }

  /**
   * Encoded byte arrays into Base64 strings.
   * 
   * @param data the byte array to encode
   * @param wrapLines <code>true</code> to add \r\n
   * @return base64 encoded string
   */",4
7224852,0,"        KeyPair keyPair = getKeyPair();

        byte[] data = ""test"".getBytes(""UTF8"");

        Signature sig = Signature.getInstance(""SHA1WithRSA"");
        sig.initSign(keyPair.getPrivate());
        sig.update(data);
        byte[] signatureBytes = sig.sign();
        System.out.println(""Singature:"" + new BASE64Encoder().encode(signatureBytes));

        sig.initVerify(keyPair.getPublic());
        sig.update(data);

        System.out.println(sig.verify(signatureBytes));",34
7253396,0,"        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
            return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
        }

        @Override
        public Socket createSocket() throws IOException {
            return sslContext.getSocketFactory().createSocket();
        }",1
7303391,1,"    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
    // this is wrong!
    sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();",5
7304633,0,"public class UseKeyTool {

    private static final int keysize = 1024;
    private static final String commonName = ""www.test.de"";
    private static final String organizationalUnit = ""IT"";
    private static final String organization = ""test"";
    private static final String city = ""test"";
    private static final String state = ""test"";
    private static final String country = ""DE"";
    private static final long validity = 1096; // 3 years
    private static final String alias = ""tomcat"";
    private static final char[] keyPass = ""changeit"".toCharArray();

    // copied most ideas from sun.security.tools.KeyTool.java

    @SuppressWarnings(""restriction"")
    public static void main(String[] args) throws Exception {

        KeyStore keyStore = KeyStore.getInstance(""JKS"");
        keyStore.load(null, null);

        CertAndKeyGen keypair = new CertAndKeyGen(""RSA"", ""SHA1WithRSA"", null);

        X500Name x500Name = new X500Name(commonName, organizationalUnit, organization, city, state, country);

        keypair.generate(keysize);
        PrivateKey privKey = keypair.getPrivateKey();

        X509Certificate[] chain = new X509Certificate[1];

        chain[0] = keypair.getSelfCertificate(x500Name, new Date(), (long) validity * 24 * 60 * 60);

        keyStore.setKeyEntry(alias, privKey, keyPass, chain);

        keyStore.store(new FileOutputStream("".keystore""), keyPass);



    }
}",3
7523169,0,"            Coded = aesCipher.doFinal(toCode2);

            /* byte[] --> char[] kai ektypwsh*/
            Coded2 = new char[Coded.length];
            for(int i=0;i<Coded.length;i++)
                Coded2[i] = (char)Coded[i];
            System.out.println(""Test Encrypt: "" + new String(Coded2));

",2
7523169,0,"            decoded = aesCipher2.doFinal(Coded);

            /* byte[] --> char[] kai ektypwsh*/
            deco2 = new char[decoded.length];
            for(int i=0;i<decoded.length;i++)
                deco2[i] = (char)decoded[i];
            System.out.println(""Test Decrypt: "" + new String(deco2));",2
7551293,0,"    SecretKey key = new SecretKeySpec(
            ApplicationServerConstants.FacebookSecretKey.getBytes(),
            ""hmacSHA256"");

    Mac hmacSha256 = Mac.getInstance(""hmacSHA256"");
    hmacSha256.init(key);
    // decode the info.
    byte[] mac = hmacSha256.doFinal(encodedPayload.getBytes());
",4
7636810,1,"     public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
         return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
     }

     @Override
     public Socket createSocket() throws IOException {
         return sslContext.getSocketFactory().createSocket();
     }",1
7647732,0,"byte[] digest = m.digest();
//Decoding
BigInteger bigInt = new BigInteger(1,digest);
String hashtext = bigInt.toString(16);
while(hashtext.length() < 32 ){
  hashtext = ""0""+hashtext;
}
",4
7715212,0,"public class sample{
 public void foo(){
X509TrustManager manager = null;
FileInputStream fs = null;

TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());

try
{
    fs = new FileInputStream(System.getProperty(""javax.net.ssl.trustStore"")); 
    keyStore.load(fs, null);
}
finally
{
    if (fs != null) { fs.close(); }
}

trustManagerFactory.init(keyStore);
TrustManager[] managers = trustManagerFactory.getTrustManagers();

for (TrustManager tm : managers)
{
    if (tm instanceof X509TrustManager) 
    {
        manager = (X509TrustManager) tm;
        break;
    }
}

}",1
7762892,0,"    Key key = generateKey();
    Cipher c = Cipher.getInstance(ALGORITHM);
    c.init(Cipher.ENCRYPT_MODE, key);
    byte[] encValue = c.doFinal(valueToEnc.getBytes());",2
7762892,0,"public String decrypt(String encryptedValue) throws Exception {
    Key key = generateKey();
    Cipher c = Cipher.getInstance(ALGORITHM);
    c.init(Cipher.DECRYPT_MODE, key);
    byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);
    byte[] decValue = c.doFinal(decordedValue);
    String decryptedValue = new String(decValue);
    return decryptedValue;
}

private static Key generateKey() throws Exception {
    Key key = new SecretKeySpec(keyValue, ALGORITHM);
    return key;
}
",2
7762892,0,"    Cipher c = Cipher.getInstance(ALGORITHM);
    c.init(Cipher.DECRYPT_MODE, key);
    byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);
    byte[] decValue = c.doFinal(decordedValue);",2
7801027,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i=0; i<messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
        return hexString.toString();
",4
7801027,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i=0; i<messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
        return hexString.toString();
",4
7801027,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i=0; i<messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));",4
7801027,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i=0; i<messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
        return hexString.toString();
",4
8029555,3,"RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(modulus, pubExp);
RSAPublicKey key = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);

Cipher cipher = Cipher.getInstance(""RSA/ECB/NoPadding"");
cipher.init(Cipher.ENCRYPT_MODE, key);
",3
8056056,1,"public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException  { 
    MessageDigest md = MessageDigest.getInstance(""SHA-1"");
    byte[] sha1hash = new byte[40];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    sha1hash = md.digest();
    return convertToHex(sha1hash);
} 
",4
8056056,1,"    MessageDigest md = MessageDigest.getInstance(""SHA-1"");
    byte[] sha1hash = new byte[40];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    sha1hash = md.digest();",4
8093905,1,"int numRead = 0;
        while ((numRead = fin.read(buf)) >= 0) {
            if (numRead == 1024) {
                byte[] plainTemp = new byte[aesCipher.getUpdateOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);

                final byte[] plain = new byte[offset];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            } else {
                byte[] plainTemp = new byte[aesCipher.getOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                int last = aesCipher.doFinal(plainTemp, offset);
                final byte[] plain = new byte[offset + last];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            }
        }
",2
8102852,0,"public class sample{
 public void foo(){
RSAPrivateCrtKey privateKey = (RSAPrivateCrtKey) ks.getKey(keyAlias, ksPassword.trim().toCharArray());
RSAPublicKeySpec spec = new RSAPublicKeySpec(privateKey.getModulus(),privateKey.getPrivateExponent());
Key fakePublicKey = KeyFactory.getInstance(""RSA"").generatePublic(spec);
encryptCipher.init(Cipher.ENCRYPT_MODE, fakePublicKey);

}",3
8223757,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

",1
8254278,0,"  public static byte[] sha1Digest(byte[] data) {
    MessageDigest mdSha1 = null;
    try {
      mdSha1 = MessageDigest.getInstance(""SHA-1"");
    } catch (NoSuchAlgorithmException e1) {
      Log.e(LOG_TAG, ""Error initializing SHA1 message digest"");
    }
    mdSha1.update(data);
    byte[] sha1hash = mdSha1.digest();
    return sha1hash;
  }
",4
8396600,0,"            SecretKeySpec key = new SecretKeySpec((keyString).getBytes(""UTF-8""), ""HmacMD5"");
            Mac mac = Mac.getInstance(""HmacMD5"");
            mac.init(key);

            byte[] bytes = mac.doFinal(s.getBytes(""ASCII""));
",4
8397354,0,"public class SimpleCrypto {

    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }


    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }
    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length()/2;
        byte[] result = new byte[len];
        for (int i = 0; i < len; i++)
            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
        return result;
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2*buf.length);
        for (int i = 0; i < buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }
    private final static String HEX = ""0123456789ABCDEF"";
    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));
    }

}",5
8397354,0,"    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }
",2
8397465,0,"public class SecureCredentialsCrypto {

            public static String encrypt(String seed, String cleartext) throws Exception {
                    byte[] rawKey = getRawKey(seed.getBytes());
                    byte[] result = encrypt(rawKey, cleartext.getBytes());
                    return toHex(result);
            }

            public static String decrypt(String seed, String encrypted) throws Exception {
                    byte[] rawKey = getRawKey(seed.getBytes());
                    byte[] enc = toByte(encrypted);
                    byte[] result = decrypt(rawKey, enc);
                    return new String(result);
            }

            private static byte[] getRawKey(byte[] seed) throws Exception {
                    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
                    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
                    sr.setSeed(seed);
                kgen.init(128, sr); // 192 and 256 bits may not be available
                SecretKey skey = kgen.generateKey();
                byte[] raw = skey.getEncoded();
                return raw;
            }


            private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
                SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
                    Cipher cipher = Cipher.getInstance(""AES"");
                cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
                byte[] encrypted = cipher.doFinal(clear);
                    return encrypted;
            }

            private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
                SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
                    Cipher cipher = Cipher.getInstance(""AES"");
                cipher.init(Cipher.DECRYPT_MODE, skeySpec);
                byte[] decrypted = cipher.doFinal(encrypted);
                    return decrypted;
            }

            public static String toHex(String txt) {
                    return toHex(txt.getBytes());
            }
            public static String fromHex(String hex) {
                    return new String(toByte(hex));
            }

            public static byte[] toByte(String hexString) {
                    int len = hexString.length()/2;
                    byte[] result = new byte[len];
                    for (int i = 0; i < len; i++)
                            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
                    return result;
            }

            public static String toHex(byte[] buf) {
                    if (buf == null)
                            return """";
                    StringBuffer result = new StringBuffer(2*buf.length);
                    for (int i = 0; i < buf.length; i++) {
                            appendHex(result, buf[i]);
                    }
                    return result.toString();
            }
            private final static String HEX = ""0123456789ABCDEF"";
            private static void appendHex(StringBuffer sb, byte b) {
                    sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));
            }

    }

//for storing encrypt it
String crypto_email = SecureCredentialsCrypto.encrypt(""secure"", email.toString().trim());

//for reading  decrypt it
//crypto is object name to read 


String correctEmail=SecureCredentialsCrypto.decrypt(""secure"", crypto);",5
8397465,0,"            public static String encrypt(String seed, String cleartext) throws Exception {
                    byte[] rawKey = getRawKey(seed.getBytes());
                    byte[] result = encrypt(rawKey, cleartext.getBytes());
                    return toHex(result);
            }

            public static String decrypt(String seed, String encrypted) throws Exception {
                    byte[] rawKey = getRawKey(seed.getBytes());
                    byte[] enc = toByte(encrypted);
                    byte[] result = decrypt(rawKey, enc);
                    return new String(result);
            }
",2
8397465,0,"                    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
                    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
                    sr.setSeed(seed);
                kgen.init(128, sr); // 192 and 256 bits may not be available
                SecretKey skey = kgen.generateKey();
                byte[] raw = skey.getEncoded();",5
8455058,2,"    try {
        // Create the key
        KeySpec keySpec = new PBEKeySpec(passPhase.toCharArray(), salt, iterationCount);
        SecretKey key = SecretKeyFactory.getInstance(""PBEWITHSHA256AND128BITAES-CBC-BC"").generateSecret(keySpec);
        ecipher = Cipher.getInstance(key.getAlgorithm()); 
        dcipher = Cipher.getInstance(key.getAlgorithm());

        AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);

        ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
        dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
",2
8547513,0,"public class sample{
public static byte[] signer(byte[] data, PrivateKey key) {
    Signature signer = Signature.getInstance(""SHA256WithRSA"", ""BC"");
    signer.initSign(key);
    signer.update(data);
    return signer.sign();
}
",4
8612959,0,"                  Store certStore = sp.getCertificates(); 

                  SignerInformationStore signers = sp.getSignerInfos(); 
                    Collection c = signers.getSigners();
                    Iterator it = c.iterator();
                    while (it.hasNext()) 
                    { 
                        SignerInformation signer = (SignerInformation)it.next(); 
                        Collection certCollection = certStore.getMatches(signer.getSID()); 

                        Iterator certIt = certCollection.iterator(); 

                        X509CertificateHolder certHolder = (X509CertificateHolder)certIt.next(); 



",3
8684273,0,"public void encrypt(InputStream fin, OutputStream fout, String password) {
    try {
        PKCS12ParametersGenerator pGen = new PKCS12ParametersGenerator(new SHA256Digest());
        char[] passwordChars = password.toCharArray();
        final byte[] pkcs12PasswordBytes = PBEParametersGenerator.PKCS12PasswordToBytes(passwordChars);
        pGen.init(pkcs12PasswordBytes, salt.getBytes(), iterationCount);
        CBCBlockCipher aesCBC = new CBCBlockCipher(new AESEngine());
        ParametersWithIV aesCBCParams = (ParametersWithIV) pGen.generateDerivedParameters(256, 128);
        aesCBC.init(true, aesCBCParams);
        PaddedBufferedBlockCipher aesCipher = new PaddedBufferedBlockCipher(aesCBC, new PKCS7Padding());
        aesCipher.init(true, aesCBCParams);

        // Read in the decrypted bytes and write the cleartext to out
        int numRead = 0;
        while ((numRead = fin.read(buf)) >= 0) {
            if (numRead == 1024) {
                byte[] plainTemp = new byte[aesCipher.getUpdateOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                final byte[] plain = new byte[offset];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            } else {
                byte[] plainTemp = new byte[aesCipher.getOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                int last = aesCipher.doFinal(plainTemp, offset);
                final byte[] plain = new byte[offset + last];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            }
        }
        fout.close();
        fin.close();
    } catch (Exception e) {
        e.printStackTrace();
    }

}
",2
8684273,0,"        int numRead = 0;
        while ((numRead = fin.read(buf)) >= 0) {
            if (numRead == 1024) {
                byte[] plainTemp = new byte[aesCipher.getUpdateOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                final byte[] plain = new byte[offset];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            } else {
                byte[] plainTemp = new byte[aesCipher.getOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                int last = aesCipher.doFinal(plainTemp, offset);
                final byte[] plain = new byte[offset + last];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            }
        }",2
8684273,0,"public void decrypt(InputStream fin, OutputStream fout, String password) {
    try {
        PKCS12ParametersGenerator pGen = new PKCS12ParametersGenerator(new SHA256Digest());
        char[] passwordChars = password.toCharArray();
        final byte[] pkcs12PasswordBytes = PBEParametersGenerator.PKCS12PasswordToBytes(passwordChars);
        pGen.init(pkcs12PasswordBytes, salt.getBytes(), iterationCount);
        CBCBlockCipher aesCBC = new CBCBlockCipher(new AESEngine());
        ParametersWithIV aesCBCParams = (ParametersWithIV) pGen.generateDerivedParameters(256, 128);
        aesCBC.init(false, aesCBCParams);
        PaddedBufferedBlockCipher aesCipher = new PaddedBufferedBlockCipher(aesCBC, new PKCS7Padding());
        aesCipher.init(false, aesCBCParams);

        // Read in the decrypted bytes and write the cleartext to out
        int numRead = 0;
        while ((numRead = fin.read(buf)) >= 0) {
            if (numRead == 1024) {
                byte[] plainTemp = new byte[aesCipher.getUpdateOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                // int last = aesCipher.doFinal(plainTemp, offset);
                final byte[] plain = new byte[offset];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            } else {
                byte[] plainTemp = new byte[aesCipher.getOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                int last = aesCipher.doFinal(plainTemp, offset);
                final byte[] plain = new byte[offset + last];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            }
        }
        fout.close();
        fin.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
",2
8684273,0,"        int numRead = 0;
        while ((numRead = fin.read(buf)) >= 0) {
            if (numRead == 1024) {
                byte[] plainTemp = new byte[aesCipher.getUpdateOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                // int last = aesCipher.doFinal(plainTemp, offset);
                final byte[] plain = new byte[offset];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            } else {
                byte[] plainTemp = new byte[aesCipher.getOutputSize(numRead)];
                int offset = aesCipher.processBytes(buf, 0, numRead, plainTemp, 0);
                int last = aesCipher.doFinal(plainTemp, offset);
                final byte[] plain = new byte[offset + last];
                System.arraycopy(plainTemp, 0, plain, 0, plain.length);
                fout.write(plain, 0, plain.length);
            }
        }",2
8691102,0,"Mac mac = Mac.getInstance(""HmacSHA1"");
SecretKeySpec secret = new SecretKeySpec(key.getBytes(), mac.getAlgorithm());
mac.init(secret);
byte[] digest = mac.doFinal(baseString.getBytes());",4
8791701,7,"    SecretKeySpec sessionKey = new SecretKeySpec(rawKey, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
    cipher.init(Cipher.DECRYPT_MODE, sessionKey, new IvParameterSpec(new byte[16]));

    byte[] decryptedBlocks = cipher.doFinal(encryptedMessage);

    // check versus expected message",2
8806425,0,"public class sample{
 public void foo(){
SchemeRegistry schReg = new SchemeRegistry();
schReg.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
schReg.register(new Scheme(""https"",SSLSocketFactory.getSocketFactory(), 443));
SingleClientConnManager conMgr = new SingleClientConnManager(params,post.getParams());

}",1
8828196,6,"            final byte[] ivData = new byte[blockSize];
            final SecureRandom rnd = SecureRandom.getInstance(""SHA1PRNG"");
            rnd.nextBytes(ivData);
            final IvParameterSpec iv = new IvParameterSpec(ivData);

            cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);

            final byte[] encryptedMessage = cipher.doFinal(encodedMessage);

            // concatenate IV and encrypted message
            final byte[] ivAndEncryptedMessage = new byte[ivData.length
                    + encryptedMessage.length];
            System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);
            System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage,
                    blockSize, encryptedMessage.length);
",2
8944552,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
",1
9001116,0,"public class sample{
private static byte[] cipherData(PaddedBufferedBlockCipher cipher, byte[] data)
        throws Exception
{
    int minSize = cipher.getOutputSize(data.length);
    byte[] outBuf = new byte[minSize];
    int length1 = cipher.processBytes(data, 0, data.length, outBuf, 0);
    int length2 = cipher.doFinal(outBuf, length1);
    int actualLength = length1 + length2;
    byte[] result = new byte[actualLength];
    System.arraycopy(outBuf, 0, result, 0, result.length);
    return result;
}

private static byte[] decrypt(byte[] cipher, byte[] key, byte[] iv) throws Exception
{
    PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher(new CBCBlockCipher(
            new AESEngine()));
    CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(key), iv);
    aes.init(false, ivAndKey);
    return cipherData(aes, cipher);
}

private static byte[] encrypt(byte[] plain, byte[] key, byte[] iv) throws Exception
{
    PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher(new CBCBlockCipher(
            new AESEngine()));
    CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(key), iv);
    aes.init(true, ivAndKey);
    return cipherData(aes, plain);
}
",2
9001116,0,"    int minSize = cipher.getOutputSize(data.length);
    byte[] outBuf = new byte[minSize];
    int length1 = cipher.processBytes(data, 0, data.length, outBuf, 0);
    int length2 = cipher.doFinal(outBuf, length1);
    int actualLength = length1 + length2;
    byte[] result = new byte[actualLength];",2
9001116,0,"private static byte[] decrypt(byte[] cipher, byte[] key, byte[] iv) throws Exception
{
    PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher(new CBCBlockCipher(
            new AESEngine()));
    CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(key), iv);
    aes.init(false, ivAndKey);
    return cipherData(aes, cipher);
}
",2
9001116,0,"private static byte[] encrypt(byte[] plain, byte[] key, byte[] iv) throws Exception
{
    PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher(new CBCBlockCipher(
            new AESEngine()));
    CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(key), iv);
    aes.init(true, ivAndKey);
    return cipherData(aes, plain);
}
",2
9063005,1,"        SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

        if ((localAddress != null) || (localPort > 0)) {
            // we need to bind explicitly
            if (localPort < 0) {
                localPort = 0; // indicates ""any""
            }
            InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);
            sslsock.bind(isa);
        }
",1
9063005,1,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException,
            UnknownHostException {
        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    // -------------------------------------------------------------------
    // javadoc in org.apache.http.conn.scheme.SocketFactory says :
    // Both Object.equals() and Object.hashCode() must be overridden
    // for the correct operation of some connection managers
    // -------------------------------------------------------------------

    public boolean equals(Object obj) {
        return ((obj != null) && obj.getClass().equals(EasySSLSocketFactory.class));
    }

    public int hashCode() {
        return EasySSLSocketFactory.class.hashCode();
    }
",1
9081096,0,"   for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.i(""PXR"", Base64.encodeBytes(md.digest()));
   }",4
9100324,0,"        CipherParameters cipherParameters = new ParametersWithIV(new KeyParameter(keyBytes), iv);
        RijndaelEngine rijndael = new RijndaelEngine(256);
        SICBlockCipher ctrMode = new SICBlockCipher(rijndael);
        PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(ctrMode, new ZeroBytePadding());
        cipher.init(false, cipherParameters);

        int size = cipher.getOutputSize(newEncrypt.length);
        byte[] padded = new byte[size];",2
9100324,0,"        CipherParameters cipherParameters = new ParametersWithIV(new KeyParameter(keyBytes), iv);
        RijndaelEngine rijndael = new RijndaelEngine(256);
        SICBlockCipher ctrMode = new SICBlockCipher(rijndael);
        PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(ctrMode, new ZeroBytePadding());
        cipher.init(true, cipherParameters);

        int size = cipher.getOutputSize(newDecrypt.length);
        byte[] decrypted = new byte[size];
",2
9100324,0,"        SecretKeySpec secret = new SecretKeySpec(key.getBytes(/*CHARSET*/), algorithm);
        Mac mac = Mac.getInstance(algorithm);
        mac.init(secret);
        byte[] digest = mac.doFinal(data.getBytes(/*CHARSET*/));",4
9124638,1,"private PublicKey readPublicKeyFromFile(String keyFileName) throws Exception {
  InputStream in = new FileInputStream(keyFileName);
  ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(in));
  try {
    BigInteger m = (BigInteger) oin.readObject();
    BigInteger e = (BigInteger) oin.readObject();
    RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);
    KeyFactory fact = KeyFactory.getInstance(""RSA"");
    PublicKey pubKey = fact.generatePublic(keySpec);
    return pubKey;
  } catch (Exception e) {
    throw new RuntimeException(""Spurious serialisation error"", e);
  } finally {
    oin.close();
  }
}
",3
9124638,1,"  InputStream in = new FileInputStream(keyFileName);
  ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(in));
  try {
    BigInteger m = (BigInteger) oin.readObject();
    BigInteger e = (BigInteger) oin.readObject();
    RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);
    KeyFactory fact = KeyFactory.getInstance(""RSA"");
    PublicKey pubKey = fact.generatePublic(keySpec);
    return pubKey;",4
9124638,1,"private PrivateKey readPrivateKeyFromFile(String keyFileName) throws Exception {
  InputStream in = new FileInputStream(keyFileName);
  ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(in));
  try {
    BigInteger m = (BigInteger) oin.readObject();
    BigInteger e = (BigInteger) oin.readObject();
    RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(m, e);
    KeyFactory fact = KeyFactory.getInstance(""RSA"");
    PrivateKey pubKey = fact.generatePrivate(keySpec);
    return pubKey;
  } catch (Exception e) {
    throw new RuntimeException(""Spurious serialisation error"", e);
  } finally {
    oin.close();
  }
}

/**
* Decrypts an AES key from a file using an RSA private key
*/",3
9124638,1,"  InputStream in = new FileInputStream(keyFileName);
  ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(in));
  try {
    BigInteger m = (BigInteger) oin.readObject();
    BigInteger e = (BigInteger) oin.readObject();
    RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(m, e);
    KeyFactory fact = KeyFactory.getInstance(""RSA"");
    PrivateKey pubKey = fact.generatePrivate(keySpec);
    return pubKey;",4
9175004,0,"     public class SimpleCrypto {

public  String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
}

public  String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
}

//done
private  byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}


private  byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
}

private  byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
}

public  String toHex(String txt) {
        return toHex(txt.getBytes());
}
public  String fromHex(String hex) {
        return new String(toByte(hex));
}

public  byte[] toByte(String hexString) {
        int len = hexString.length()/2;
        byte[] result = new byte[len];
        for (int i = 0; i < len; i++)
                result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
        return result;
}

public  String toHex(byte[] buf) {
        if (buf == null)
                return """";
        StringBuffer result = new StringBuffer(2*buf.length);
        for (int i = 0; i < buf.length; i++) {
                appendHex(result, buf[i]);
        }
        return result.toString();
}
private final static String HEX = ""0123456789ABCDEF"";
private  void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));
}

  }",5
9175004,0,"public  String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
}

public  String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
}

//done",2
9175004,0,"        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();",5
9225813,0,"public class sample{
 public void foo(){
    Provider[] providers = Security.getProviders();
    for (Provider provider : providers) {
        for (Object entry : provider.keySet()) {
            String name = String.valueOf(entry);
            if (name.startsWith(""Cipher"")) {
                Log.d(""Cipher"", ""Supports: "" + name.substring(7));
            }
        }
    }

}",2
9232585,0,"        final byte[] ivData = new byte[blockSize];
        final SecureRandom rnd = SecureRandom.getInstance(""SHA1PRNG"");
        rnd.nextBytes(ivData);
        final IvParameterSpec iv = new IvParameterSpec(ivData);

        cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);

        final byte[] encryptedMessage = cipher.doFinal(encodedMessage);

        // concatenate IV and encrypted message
        final byte[] ivAndEncryptedMessage = new byte[ivData.length
                + encryptedMessage.length];
        System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);
        System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage,
                blockSize, encryptedMessage.length);
",2
9391980,0,"public class AeSimpleSHA1 { 

    private static String convertToHex(byte[] data) { 
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < data.length; i++) { 
            int halfbyte = (data[i] >>> 4) & 0x0F;
            int two_halfs = 0;
            do { 
                if ((0 <= halfbyte) && (halfbyte <= 9)) 
                    buf.append((char) ('0' + halfbyte));
                else 
                    buf.append((char) ('a' + (halfbyte - 10)));
                halfbyte = data[i] & 0x0F;
            } while(two_halfs++ < 1);
        } 
        return buf.toString();
    } 

    public static String SHA1(String text) 
            throws NoSuchAlgorithmException, UnsupportedEncodingException  { 
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA-1"");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes(""iso-8859-1""), 0, text.length());
        sha1hash = md.digest();
        return convertToHex(sha1hash);
    } 
}",4
9391980,0,"        md = MessageDigest.getInstance(""SHA-1"");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes(""iso-8859-1""), 0, text.length());
        sha1hash = md.digest();",4
9534898,0,"    int minSize = cipher.getOutputSize(data.length);
    byte[] outBuf = new byte[minSize];
    int length1 = cipher.processBytes(data, 0, data.length, outBuf, 0);
    int length2 = cipher.doFinal(outBuf, length1);
    int actualLength = length1 + length2;
    byte[] result = new byte[actualLength];",2
9534898,0,"private static byte[] encrypt(byte[] plain, byte[] key, byte[] iv) throws Exception
{       
    PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher(new CBCBlockCipher(
            new AESEngine()));

    CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(key), iv);

    aes.init(true, ivAndKey);

    return cipherData(aes, plain);
}
",2
9537017,0,"Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, secret);

byte[] iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();",2
9544705,0,"public class sample{
 public void foo(){
SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);
SecretKey tmp = factory.generateSecret(spec);
SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

}",2
9594149,2,"public class sample{
 public void foo(){
System.setProperty(""javax.net.ssl.keyStore"",""mySrvKeystore"");
System.setProperty(""javax.net.ssl.keyStorePassword"",""123456"");

ServerSocketFactory ssocketFactory = SSLServerSocketFactory.getDefault();
ServerSocket ssocket = null;
System.out.println(""SSL_Server started"");

}",1
9601581,0,"    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

    if ((localAddress != null) || (localPort > 0)) {
        // we need to bind explicitly
        if (localPort < 0) {
            localPort = 0; // indicates ""any""
        }
        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);
        sslsock.bind(isa);
    }
",1
9601581,0,"public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException,
        UnknownHostException {
    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
}

// -------------------------------------------------------------------
// javadoc in org.apache.http.conn.scheme.SocketFactory says :
// Both Object.equals() and Object.hashCode() must be overridden
// for the correct operation of some connection managers
// -------------------------------------------------------------------

public boolean equals(Object obj) {
    return ((obj != null) && obj.getClass().equals(EasySSLSocketFactory.class));
}

public int hashCode() {
    return EasySSLSocketFactory.class.hashCode();
}
",1
9601581,1,"public class EasyX509TrustManager implements X509TrustManager {

private X509TrustManager standardTrustManager = null;

/**
 * Constructor for EasyX509TrustManager.
 */
public EasyX509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException {
    super();
    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keystore);
    TrustManager[] trustmanagers = factory.getTrustManagers();
    if (trustmanagers.length == 0) {
        throw new NoSuchAlgorithmException(""no trust manager found"");
    }
    this.standardTrustManager = (X509TrustManager) trustmanagers[0];
}

/**
 * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],String authType)
 */
public void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException {
    standardTrustManager.checkClientTrusted(certificates, authType);
}

/**
 * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],String authType)
 */
public void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException {
    if ((certificates != null) && (certificates.length == 1)) {
        certificates[0].checkValidity();
    } else {
        standardTrustManager.checkServerTrusted(certificates, authType);
    }
}

/**
 * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
 */
public X509Certificate[] getAcceptedIssuers() {
    return this.standardTrustManager.getAcceptedIssuers();
}

}",1
9601581,1,"    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keystore);
    TrustManager[] trustmanagers = factory.getTrustManagers();
    if (trustmanagers.length == 0) {
        throw new NoSuchAlgorithmException(""no trust manager found"");
    }
    this.standardTrustManager = (X509TrustManager) trustmanagers[0];",1
9664340,0,"public class sample{
/**
 * Perform SHA-256 hash on the given string.
 * It returns a hashed string as Base64 string.
 * @param str String to be hashed in SHA-256
 * @return Base64 string if hashed successfully, else NULL
 */
public static String getHashSHA256(String str){
    String hash = null;

    try{
        MessageDigest digest = null;

        try { digest = MessageDigest.getInstance(""SHA-256""); }
        catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return hash;
        }

        digest.reset();
        hash = Base64.encodeToString(digest.digest(str.getBytes()),
                  Base64.DEFAULT).trim();
        digest = null;
    }
    catch (Exception e) {
        Log.e(""SHA-256"", ""Error in getHashSHA256() due to -> "" + e.toString());
    }

    return hash;
}
",4
9683889,0,"            SSLSocketFactory ssf = new SSLSocketFactory(ctx);
            ssf.setHostnameVerifier(verifier);
            ClientConnectionManager ccm = base.getConnectionManager();
            SchemeRegistry sr = ccm.getSchemeRegistry();
            sr.register(new Scheme(""https"", ssf, 443));
            return new DefaultHttpClient(ccm, base.getParams());",1
9829632,0,"public class sample{
public static byte[] pemToPKCS12(final String keyFile, final String cerFile, final String password) throws Exception {
    // Get the private key
    FileReader reader = new FileReader(keyFile);

    PEMReader pem = new PEMReader(reader, new PasswordFinder() {
        @Override public char[] getPassword() {
            return password.toCharArray();
        }
    });

    PrivateKey key = ((KeyPair)pem.readObject()).getPrivate();

    pem.close();
    reader.close();

    // Get the certificate      
    reader = new FileReader(cerFile);
    pem = new PEMReader(reader);

    X509Certificate cert = (X509Certificate)pem.readObject();

    pem.close();
    reader.close();

    // Put them into a PKCS12 keystore and write it to a byte[]
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    KeyStore ks = KeyStore.getInstance(""PKCS12"");
    ks.load(null);
    ks.setKeyEntry(""alias"", (Key)key, password.toCharArray(), new java.security.cert.Certificate[]{cert});
    ks.store(bos, password.toCharArray());
    bos.close();
    return bos.toByteArray();
}
",3
9829632,0,"    pem.close();
    reader.close();

    // Put them into a PKCS12 keystore and write it to a byte[]
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    KeyStore ks = KeyStore.getInstance(""PKCS12"");
    ks.load(null);
    ks.setKeyEntry(""alias"", (Key)key, password.toCharArray(), new java.security.cert.Certificate[]{cert});
    ks.store(bos, password.toCharArray());
    bos.close();
    return bos.toByteArray();",1
9829632,0,"    ks.load(null);
    ks.setKeyEntry(""alias"", (Key)key, password.toCharArray(), new java.security.cert.Certificate[]{cert});
    ks.store(bos, password.toCharArray());
    bos.close();",1
9839841,0,"public class sample{
public static byte[] pemToPKCS12(final String keyFile, final String cerFile, final String password) throws Exception {
    // Get the private key
    FileReader reader = new FileReader(keyFile);

    PEMReader pem = new PEMReader(reader, new PasswordFinder() {
        @Override public char[] getPassword() {
            return password.toCharArray();
        }
    });

    PrivateKey key = ((KeyPair)pem.readObject()).getPrivate();

    pem.close();
    reader.close();

    // Get the certificate      
    reader = new FileReader(cerFile);
    pem = new PEMReader(reader);

    X509Certificate cert = (X509Certificate)pem.readObject();

    pem.close();
    reader.close();

    // Put them into a PKCS12 keystore and write it to a byte[]
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    KeyStore ks = KeyStore.getInstance(""PKCS12"");
    ks.load(null);
    ks.setKeyEntry(""alias"", (Key)key, password.toCharArray(), new java.security.cert.Certificate[]{cert});
    ks.store(bos, password.toCharArray());
    bos.close();
    return bos.toByteArray();
}
",3
9839841,0,"    pem.close();
    reader.close();

    // Put them into a PKCS12 keystore and write it to a byte[]
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    KeyStore ks = KeyStore.getInstance(""PKCS12"");
    ks.load(null);
    ks.setKeyEntry(""alias"", (Key)key, password.toCharArray(), new java.security.cert.Certificate[]{cert});
    ks.store(bos, password.toCharArray());
    bos.close();
    return bos.toByteArray();",1
9839841,0,"    ks.load(null);
    ks.setKeyEntry(""alias"", (Key)key, password.toCharArray(), new java.security.cert.Certificate[]{cert});
    ks.store(bos, password.toCharArray());
    bos.close();",1
9890863,2,"    InputStream in = new FileInputStream(PUBLIC_KEY_FILE);
    ObjectInputStream oin =
            new ObjectInputStream(new BufferedInputStream(in));
    try {
        BigInteger m = (BigInteger) oin.readObject();
        BigInteger e = (BigInteger) oin.readObject();
        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);
        KeyFactory fact = KeyFactory.getInstance(""RSA"");
        PublicKey pubKey = fact.generatePublic(keySpec);
        return pubKey;",4
9911579,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();",4
9911579,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < mdbytes.length; i++) {
          sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
        }

        System.out.println(""Digest(in hex format):: "" + sb.toString());

        //convert the byte to hex format method 2",4
9911579,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < mdbytes.length; i++) {
          sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
        }

        System.out.println(""Digest(in hex format):: "" + sb.toString());

        //convert the byte to hex format method 2
        StringBuffer hexString = new StringBuffer();",4
9911579,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < mdbytes.length; i++) {
          sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
        }

        System.out.println(""Digest(in hex format):: "" + sb.toString());

        //convert the byte to hex format method 2
        StringBuffer hexString = new StringBuffer();
        for (int i=0;i<mdbytes.length;i++) {
            String hex=Integer.toHexString(0xff & mdbytes[i]);
            if(hex.length()==1) hexString.append('0');
            hexString.append(hex);
        }
        System.out.println(""Digest(in hex format):: "" + hexString.toString());",4
9926312,0,"public static void main(String args[]) throws Exception {

    Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());

    new EmailAgent().sendSSLMessage(sendTo, emailSubjectTxt, emailMsgTxt,
            emailFromAddress);
    System.out.println(""Sucessfully Sent mail to All Users"");",1
9940572,0,"    InputStream in = RSACrypt.class.getClassLoader().getResourceAsStream(keyFileName);
    ObjectInputStream oin = new ObjectInputStream(new BufferedInputStream(
            in));
    try {
        BigInteger m = (BigInteger) oin.readObject();
        BigInteger e = (BigInteger) oin.readObject();
        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);
        KeyFactory fact = KeyFactory.getInstance(""RSA"");
        PublicKey pubKey = fact.generatePublic(keySpec);
        return pubKey;",4
10026598,0,"    protected ClientConnectionManager createClientConnectionManager() {
        SchemeRegistry registry = new SchemeRegistry();

        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));

        // Register for port 443 our SSLSocketFactory with our keystore to the ConnectionManager
        registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
        return new SingleClientConnManager(getParams(), registry);
    }

    private SSLSocketFactory newSslSocketFactory() {
        try {
            // Get an instance of the Bouncy Castle KeyStore format
            KeyStore trusted = KeyStore.getInstance(""BKS"");

            // Get the raw resource, which contains the keystore with your trusted certificates (root and any intermediate certs)
            InputStream in = context.getResources().openRawResource(R.raw.aglite);
            try {
                // Initialize the keystore with the provided trusted certificates.
                // Also provide the password of the keystore
                trusted.load(in, ""aglite"".toCharArray());
            } finally {
                in.close();
            }

            // Pass the keystore to the SSLSocketFactory. The factory is responsible for the verification of the server certificate.",1
10026598,0,"            KeyStore trusted = KeyStore.getInstance(""BKS"");

            // Get the raw resource, which contains the keystore with your trusted certificates (root and any intermediate certs)
            InputStream in = context.getResources().openRawResource(R.raw.aglite);
            try {
                // Initialize the keystore with the provided trusted certificates.
                // Also provide the password of the keystore
                trusted.load(in, ""aglite"".toCharArray());
            } finally {
                in.close();
            }

            // Pass the keystore to the SSLSocketFactory. The factory is responsible for the verification of the server certificate.",1
10026814,0,"    protected ClientConnectionManager createClientConnectionManager() {
        SchemeRegistry registry = new SchemeRegistry();

        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));

        // Register for port 443 our SSLSocketFactory with our keystore to the ConnectionManager
        registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
        return new SingleClientConnManager(getParams(), registry);
    }

    private SSLSocketFactory newSslSocketFactory() {
        try {
            // Get an instance of the Bouncy Castle KeyStore format
            KeyStore trusted = KeyStore.getInstance(""BKS"");

            // Get the raw resource, which contains the keystore with your trusted certificates (root and any intermediate certs)
            InputStream in = context.getResources().openRawResource(R.raw.aglite);
            try {
                // Initialize the keystore with the provided trusted certificates.
                // Also provide the password of the keystore
                trusted.load(in, ""aglite"".toCharArray());
            } finally {
                in.close();
            }

            // Pass the keystore to the SSLSocketFactory. The factory is responsible for the verification of the server certificate.",1
10026814,0,"            KeyStore trusted = KeyStore.getInstance(""BKS"");

            // Get the raw resource, which contains the keystore with your trusted certificates (root and any intermediate certs)
            InputStream in = context.getResources().openRawResource(R.raw.aglite);
            try {
                // Initialize the keystore with the provided trusted certificates.
                // Also provide the password of the keystore
                trusted.load(in, ""aglite"".toCharArray());
            } finally {
                in.close();
            }

            // Pass the keystore to the SSLSocketFactory. The factory is responsible for the verification of the server certificate.",1
10041314,0,"public class AeSimpleSHA1 { 

    private static String convertToHex(byte[] data) { 
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < data.length; i++) { 
            int halfbyte = (data[i] >>> 4) & 0x0F;
            int two_halfs = 0;
            do { 
                if ((0 <= halfbyte) && (halfbyte <= 9)) 
                    buf.append((char) ('0' + halfbyte));
                else 
                    buf.append((char) ('a' + (halfbyte - 10)));
                halfbyte = data[i] & 0x0F;
            } while(two_halfs++ < 1);
        } 
        return buf.toString();
    } 

    public static String SHA1(String text) 
    throws NoSuchAlgorithmException, UnsupportedEncodingException  { 
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA-1"");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes(""iso-8859-1""), 0, text.length());
        sha1hash = md.digest();
        return convertToHex(sha1hash);
    } 
} ",4
10041314,0,"        md = MessageDigest.getInstance(""SHA-1"");
        byte[] sha1hash = new byte[40];
        md.update(text.getBytes(""iso-8859-1""), 0, text.length());
        sha1hash = md.digest();",4
10128606,0,"            byte [] trimbuf = new byte [nread];
            for (int i = 0; i < nread; i++)
                trimbuf[i] = inbuf[i];

            // encrypt the buffer using the cipher obtained previosly
            byte [] tmp = mEcipher.update (trimbuf);

            // I don't think this should happen, but just in case..
            if (tmp != null)
                fout.write (tmp);",-1
10207324,0,"    public void hash() throws NoSuchAlgorithmException, UnsupportedEncodingException{

        MessageDigest md = MessageDigest.getInstance(""SHA-256"");
        md.update(fixturesFeedURL.getBytes(""UTF-8""));
        byte[] digest = md.digest();
        strHash = new String(digest);
",4
10207487,0,"public void hash() throws NoSuchAlgorithmException, UnsupportedEncodingException{

    MessageDigest md = MessageDigest.getInstance(""SHA-256"");
    md.update(fixturesFeedURL.getBytes(""UTF-8""));
    byte[] digest = md.digest();
    strhash = new String(digest);
",4
10222196,12,"    public static PublicKey bytesToPubKey(byte[] bytes) throws InvalidKeySpecException, NoSuchAlgorithmException{
        return KeyFactory.getInstance(""RSA"").generatePublic(new X509EncodedKeySpec(bytes));
    }
    public static PrivateKey bytesToPrivKey(byte[] bytes) throws InvalidKeySpecException, NoSuchAlgorithmException{
        return KeyFactory.getInstance(""RSA"").generatePrivate(new PKCS8EncodedKeySpec(bytes));
    }
",3
10272410,1,"RSAPublicKeySpec spec = new RSAPublicKeySpec(n, e);
RSAPublicKey pub = (RSAPublicKey) factory.generatePublic(spec);
Cipher enc = Cipher.getInstance(""RSA"");
enc.init(Cipher.WRAP_MODE, pub);",3
10291282,0,"            rfile.seek(rfile.length()-32); // second to last block
            rfile.read(iv); // get iv
            byte[] lastBlockEnc = new byte[16]; 
                // last block
                // it's padded, so we'll decrypt it and 
                // save it for the beginning of our data
            rfile.read(lastBlockEnc);
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");",2
10291282,2,"            rfile.seek(rfile.length()-32);
            rfile.read(iv);
            byte[] lastBlockEnc = new byte[16];
            rfile.read(lastBlockEnc);
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");",2
10307724,1,"public class sample{
 public void foo(){
/*
* First, create (or ask some other component for) the adequate encryptor for   
* decrypting the values in our .properties file.   
*/  
StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();     
encryptor.setPassword(""jasypt""); // could be got from web, env variable...    
/*   
* Create our EncryptableProperties object and load it the usual way.   
*/  
Properties props = new EncryptableProperties(encryptor);  
props.load(new FileInputStream(""/path/to/my/configuration.properties""));

/*   
* To get a non-encrypted value, we just get it with getProperty...   
*/  
String datasourceUsername = props.getProperty(""datasource.username"");

/*   
* ...and to get an encrypted value, we do exactly the same. Decryption will   
* be transparently performed behind the scenes.   
*/ 
String datasourcePassword = props.getProperty(""datasource.password"");

 // From now on, datasourcePassword equals ""reports_passwd""...

}",2
10316509,0,"    public TrippleDes() throws Exception {
        myEncryptionKey = ""ThisIsSpartaThisIsSparta"";
        myEncryptionScheme = DESEDE_ENCRYPTION_SCHEME;
        arrayBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
        ks = new DESedeKeySpec(arrayBytes);
        skf = SecretKeyFactory.getInstance(myEncryptionScheme);
        cipher = Cipher.getInstance(myEncryptionScheme);
        key = skf.generateSecret(ks);
    }


    public String encrypt(String unencryptedString) {
        String encryptedString = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            byte[] encryptedText = cipher.doFinal(plainText);
            encryptedString = new String(Base64.encodeBase64(encryptedText));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return encryptedString;
    }

",2
10316509,0,"            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            byte[] encryptedText = cipher.doFinal(plainText);
            encryptedString = new String(Base64.encodeBase64(encryptedText));",2
10358882,0,"    public static String encrypt(String seed, String cleartext) throws NoSuchAlgorithmException, InvalidKeyException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] result = encrypt(rawKey, cleartext.getBytes());
        return bin2hex(result);
    }

    public static String decrypt(String seed, String encrypted) throws NoSuchAlgorithmException, InvalidKeyException, IllegalBlockSizeException, BadPaddingException, NoSuchPaddingException {
        final byte[] rawKey = getRawKey(seed.getBytes());
        final byte[] enc = toByte(encrypted);
        final byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }
",2
10360372,1,"            KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
            SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
            sr.setSeed(keyStart);
            kgen.init(128, sr); // 192 and 256 bits may not be available
            SecretKey skey = kgen.generateKey();
            byte[] key = skey.getEncoded();
",5
10537489,0,"private static KeyPair readKeyPair(File privateKey, String keyPassword) throws IOException {
    FileReader fileReader = new FileReader(privateKey);
    PEMReader r = new PEMReader(fileReader, new DefaultPasswordFinder(keyPassword.toCharArray()));
    try {
        return (KeyPair) r.readObject();
    } catch (IOException ex) {
        throw ex;
    } finally {
        r.close();
        fileReader.close();
    }",3
10537489,0,"private static Key readPublicKey(File privateKey, String keyPassword) throws IOException {
    FileReader fileReader = new FileReader(privateKey);
    PEMReader r = new PEMReader(fileReader, new DefaultPasswordFinder(keyPassword.toCharArray()));
    try {
        return (RSAPublicKey) r.readObject();
    } catch (IOException ex) {
        throw ex;
    } finally {
        r.close();
        fileReader.close();
    }",3
10709830,0,"        System.out.println("""");
        RSAPrivateKeySpec privSpec = new RSAPrivateKeySpec(modules, d);
        PrivateKey privKey = factory.generatePrivate(privSpec);
        cipher.init(Cipher.DECRYPT_MODE, privKey);",3
10725268,1,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
       return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
       return sslContext.getSocketFactory().createSocket();
    }

",1
10782267,3,"    CipherOutputStream cos = new CipherOutputStream(fos, cipher);
    // Write bytes
    int b;
    byte[] d = new byte[8];
    while((b = fis.read(d)) != -1) {
        cos.write(d, 0, b);
    }
    // Flush and close streams.
    cos.flush();
    cos.close();
    fis.close();",2
10782267,6,"    CipherInputStream cis = new CipherInputStream(fis, cipher);
    int b;
    byte[] d = new byte[8];
    while((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }
    fos.flush();
    fos.close();
    cis.close();",2
10782267,6,"    CipherInputStream cis = new CipherInputStream(fis, cipher);
    int b;
    byte[] d = new byte[8];
    while((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }
    fos.flush();
    fos.close();
    cis.close();",2
10803330,1,"    hash = messageDigest.digest(passwordString.getBytes(""UTF-8""));
    StringBuilder sb = new StringBuilder();
    for (byte b : hash) {
        sb.append(String.format(""%02x"", b));
    }",4
10843053,8,"            byte[] plaintext = new byte[plaintextLength];

            // Copy our actual data into the beginning of the array.  The
            // rest of the array is implicitly zero-filled, as desired.
            System.arraycopy(dataBytes, 0, plaintext, 0, dataBytes.length);

            SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), ""AES"");
            IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());

            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
            byte[] encrypted = cipher.doFinal(plaintext);

            return new sun.misc.BASE64Encoder().encode(encrypted);
",2
10843053,8,"            SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), ""AES"");
            IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());

            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
            byte[] encrypted = cipher.doFinal(plaintext);
",2
10843168,2,"        SecretKey aesKey = new SecretKeySpec(keyBytes, ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/NOPADDING"");
        cipher.init(Cipher.DECRYPT_MODE, aesKey, new IvParameterSpec(iv));

        byte[] result = cipher.doFinal(cipherBytes);",2
10949213,0,"        KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 2048, 160);
        SecretKeyFactory f = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        byte[] hash = f.generateSecret(spec).getEncoded();
",2
10958133,5,"KeyPair keyPair = kpg.genKeyPair();

byte[] pk = keyPair.getPublic().getEncoded();
X509EncodedKeySpec spec = new X509EncodedKeySpec(pk);
KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
PublicKey pubKey = keyFactory.generatePublic(spec);",4
10958133,5,"KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
PublicKey pubKey = keyFactory.generatePublic(spec);
Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
cipher.init(Cipher.ENCRYPT_MODE, pubKey);",23
11092289,1,"public class ValicertX509TrustManager implements X509TrustManager {

    X509TrustManager pkixTrustManager;

    ValicertX509TrustManager() throws Exception {

        String valicertFile = ""/certificates/ValicertRSAPublicRootCAv1.cer"";
        String commwebDRFile = ""/certificates/DR_10570.migs.mastercard.com.au.crt"";
        String commwebPRODFile = ""/certificates/PROD_10549.migs.mastercard.com.au.new.crt"";

        Certificate valicert = CertificateFactory.getInstance(""X509"").generateCertificate(this.getClass().getResourceAsStream(valicertFile));
        Certificate commwebDR = CertificateFactory.getInstance(""X509"").generateCertificate(this.getClass().getResourceAsStream(commwebDRFile));
        Certificate commwebPROD = CertificateFactory.getInstance(""X509"").generateCertificate(this.getClass().getResourceAsStream(commwebPRODFile));

        KeyStore keyStore = KeyStore.getInstance(""JKS"");
        keyStore.load(null, """".toCharArray());
        keyStore.setCertificateEntry(""valicert"", valicert);
        keyStore.setCertificateEntry(""commwebDR"", commwebDR);
        keyStore.setCertificateEntry(""commwebPROD"", commwebPROD);

        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(""PKIX"");
        trustManagerFactory.init(keyStore);

        TrustManager trustManagers[] = trustManagerFactory.getTrustManagers();

        for(TrustManager trustManager : trustManagers) {
            if(trustManager instanceof X509TrustManager) {
                pkixTrustManager = (X509TrustManager) trustManager;
                return;
            }
        }

        throw new Exception(""Couldn't initialize"");
    }

    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        pkixTrustManager.checkServerTrusted(chain, authType);
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        pkixTrustManager.checkServerTrusted(chain, authType);
    }

    public X509Certificate[] getAcceptedIssuers() {
        return pkixTrustManager.getAcceptedIssuers();
    }
}",1
11092289,1,"        keyStore.setCertificateEntry(""commwebPROD"", commwebPROD);

        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(""PKIX"");
        trustManagerFactory.init(keyStore);

        TrustManager trustManagers[] = trustManagerFactory.getTrustManagers();

        for(TrustManager trustManager : trustManagers) {
            if(trustManager instanceof X509TrustManager) {
                pkixTrustManager = (X509TrustManager) trustManager;
                return;
            }
        }

        throw new Exception(""Couldn't initialize"");",1
11092289,2,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    public boolean equals(Object obj) {
        return ((obj != null) && obj.getClass().equals(ValicertSSLProtocolSocketFactory.class));
    }

    public int hashCode() {
        return ValicertSSLProtocolSocketFactory.class.hashCode();
    }",1
11092289,3,"public class sample{
 public void foo(){
Protocol.registerProtocol(""vhttps"", new Protocol(""vhttps"", new ValicertSSLProtocolSocketFactory(), 443));
PostMethod postMethod = new PostMethod(url);
for (Map.Entry<String, String> entry : params.entrySet()) {
    postMethod.addParameter(entry.getKey(), StringUtils.Nz(entry.getValue()));
}

HttpClient client = new HttpClient();
int status = client.executeMethod(postMethod);
if (status == 200) {
    StringBuilder resultBuffer = new StringBuilder();
    resultBuffer.append(postMethod.getResponseBodyAsString());
    return new HttpResponse(resultBuffer.toString(), """");
} else {
    throw new IOException(""Invalid response code: "" + status);
}

}",1
11119059,1,"    private static boolean verify(byte[] data, byte[] signature, String publicKey) throws GeneralSecurityException{
        X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(Base64.decodeBase64(publicKey));
        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);
        Signature sig = Signature.getInstance(""SHA256withRSA"");
        sig.initVerify(pubKey);
        sig.update(data);
        return sig.verify(signature);
    }",34
11134538,0,"    MessageDigest md = MessageDigest.getInstance(""SHA-256"");
    md.update(password.getBytes());

    byte byteData[] = md.digest();

    //convert the byte to hex format method 1
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < byteData.length; i++) {
     sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));
    }

    System.out.println(""Hex format : "" + sb.toString());

    //convert the byte to hex format method 2
    StringBuffer hexString = new StringBuffer();
    for (int i=0;i<byteData.length;i++) {
        String hex=Integer.toHexString(0xff & byteData[i]);
        if(hex.length()==1) hexString.append('0');
        hexString.append(hex);
    }
    System.out.println(""Hex format : "" + hexString.toString());",4
11262616,0,"public class sample{
 public void foo(){
MessageDigest md   = MessageDigest.getInstance(""SHA-256""); //make sure it exists, there are other algorithms, but I prefer SHA for simple and relatively quick hashing
String strToEncode = ""Hello world"";
md.update(strToEncode.getBytes(""UTF-8"")); //I'd rather specify the encoding. It's platform dependent otherwise. 
byte[] digestBuff = md.digest();

}",4
11293498,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

",1
11306117,0,"    } catch (IOException e) {
        System.err
                .println(""An unknown error accoured while reading the PKCS#11 smartcard:"");
        e.printStackTrace();
        System.exit(-1);
    }

    String alias = """";
    try {
        alias = (String) ks.aliases().nextElement();
        privateKey = (PrivateKey) ks.getKey(alias, pkcs11PIN.toCharArray());
    } catch (NoSuchElementException e) {
        System.err
                .println(""An unknown error accoured while retrieving the private key:"");
        System.err
                .println(""The selected PKCS#12 file does not contain any private keys."");
        e.printStackTrace();
        System.exit(-1);
    } catch (NoSuchAlgorithmException e) {
        System.err
                .println(""An unknown error accoured while retrieving the private key:"");
        e.printStackTrace();
        System.exit(-1);
    } catch (UnrecoverableKeyException e) {
        System.err
                .println(""An unknown error accoured while retrieving the private key:"");
        e.printStackTrace();
        System.exit(-1);
    }
    certificateChain = ks.getCertificateChain(alias);",3
11306117,0,"    } catch (IOException e) {
        System.err
                .println(""An unknown error accoured while reading the PKCS#12 file:"");
        e.printStackTrace();
        System.exit(-1);
    }
    String alias = """";
    try {
        alias = (String) ks.aliases().nextElement();
        privateKey = (PrivateKey) ks.getKey(alias, pkcs12Password
                .toCharArray());
    } catch (NoSuchElementException e) {
        System.err
                .println(""An unknown error accoured while retrieving the private key:"");
        System.err
                .println(""The selected PKCS#12 file does not contain any private keys."");
        e.printStackTrace();
        System.exit(-1);
    } catch (NoSuchAlgorithmException e) {
        System.err
                .println(""An unknown error accoured while retrieving the private key:"");
        e.printStackTrace();
        System.exit(-1);
    } catch (UnrecoverableKeyException e) {
        System.err
                .println(""An unknown error accoured while retrieving the private key:"");
        e.printStackTrace();
        System.exit(-1);
    }
    certificateChain = ks.getCertificateChain(alias);",3
11340857,0,"public class sample{
 public void foo(){
Provider[] providers = Security.getProviders();
for (Provider provider : providers) {
    for (Object entry : provider.keySet()) {
        String name = String.valueOf(entry);
        if (name.startsWith(""Cipher"")) {
            Log.d(""Cipher"", ""Supports: "" + name.substring(7));
        }
    }
}

}",2
11392104,0,"    SecretKeyFactory factory = SecretKeyFactory
        .getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, 1024, 256);
    SecretKey tmp = factory.generateSecret(spec);
    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    AlgorithmParameters params = cipher.getParameters();
    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();",2
11392104,0,"    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    AlgorithmParameters params = cipher.getParameters();
    byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();",2
11528491,1,"Cipher contentCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
contentCipher.init(Cipher.ENCRYPT_MODE, contentEncryptionKey);
AlgorithmParameters params = contentCipher.getParameters();
byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();
",2
11539221,0,"            SecretKeySpec key = new SecretKeySpec((keyString).getBytes(""UTF-8""), ""HmacMD5"");
            Mac mac = Mac.getInstance(""HmacMD5"");
            mac.init(key);

            byte[] bytes = mac.doFinal(s.getBytes(""ASCII""));
",4
11541406,0,"    byte[] keyBytes = Base64.decodeBase64(keyString.getBytes(""utf-8""));
    X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    PublicKey key = keyFactory.generatePublic(spec);

    // decrypts the message",3
11621381,0,"    SecureRandom rnd = SecureRandom.getInstance(""SHA1PRNG"");
    final byte[] iv = new byte[c.getBlockSize()];
    rnd.nextBytes(iv);
    IvParameterSpec spec = new IvParameterSpec(iv);
    c.init(Cipher.ENCRYPT_MODE, key, spec);
",2
11627622,4,"public class sample{
static {
     //WORKAROUND. TO BE REMOVED.
     javax.net.ssl.HttpsURLConnection.setDefaultHostnameVerifier(
     new javax.net.ssl.HostnameVerifier(){
         public boolean verify(String hostname, javax.net.ssl.SSLSession sslSession) {
                if (hostname.equals(""mytargethostname"")) { //Change to actual value
                     return true;
                }
                return false;
         }
     });
}
",1
11670691,0,"    byte[] digest = md.digest();

    StringBuffer hexString = new StringBuffer();
    for (int i=0;i<digest.length;i++) {
        hexString.append(Integer.toHexString(0xFF & digest[i]));
    }
",4
11670691,0,"    byte[] digest = md.digest();

    StringBuffer hexString = new StringBuffer();
    for (int i=0;i<digest.length;i++) {
        hexString.append(Integer.toHexString(0xFF & digest[i]));
    }

    return  hexString.toString();",4
11708538,1,"            KeyGenerator keygen = KeyGenerator.getInstance(""AES"");
            keygen.init(128);  // To use 256 bit keys, you need the ""unlimited strength"" encryption policy files from Sun.
            byte[] key = keygen.generateKey().getEncoded();
            SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");

            // build the initialization vector (randomly).
            SecureRandom random = new SecureRandom();
            byte iv[] = new byte[16];//generate random 16 byte IV AES is always 16bytes
            random.nextBytes(iv);
            IvParameterSpec ivspec = new IvParameterSpec(iv);

            // initialize the cipher for encrypt mode
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivspec);
",2
11786924,1,"    public static byte[][] EVP_BytesToKey(int key_len, int iv_len, MessageDigest md,
            byte[] salt, byte[] data, int count) {
        byte[][] both = new byte[2][];
        byte[] key = new byte[key_len];
        int key_ix = 0;
        byte[] iv = new byte[iv_len];
        int iv_ix = 0;
        both[0] = key;
        both[1] = iv;
        byte[] md_buf = null;
        int nkey = key_len;
        int niv = iv_len;
        int i = 0;
        if (data == null) {
            return both;
        }
        int addmd = 0;
        for (;;) {
            md.reset();
            if (addmd++ > 0) {
                md.update(md_buf);
            }
            md.update(data);
            if (null != salt) {
                md.update(salt, 0, 8);
            }
            md_buf = md.digest();
            for (i = 1; i < count; i++) {
                md.reset();
                md.update(md_buf);
                md_buf = md.digest();
            }
            i = 0;
            if (nkey > 0) {
                for (;;) {
                    if (nkey == 0)
                        break;
                    if (i == md_buf.length)
                        break;
                    key[key_ix++] = md_buf[i];
                    nkey--;
                    i++;
                }
            }
            if (niv > 0 && i != md_buf.length) {
                for (;;) {
                    if (niv == 0)
                        break;
                    if (i == md_buf.length)
                        break;
                    iv[iv_ix++] = md_buf[i];
                    niv--;
                    i++;
                }
            }
            if (nkey == 0 && niv == 0) {
                break;
            }
        }
        for (i = 0; i < md_buf.length; i++) {
            md_buf[i] = 0;
        }
        return both;",4
11786924,1,"            SecretKeySpec key = new SecretKeySpec(keyAndIV[INDEX_KEY], ""AES"");
            IvParameterSpec iv = new IvParameterSpec(keyAndIV[INDEX_IV]);

            // --- initialize cipher instance and decrypt ---

            aesCBC.init(Cipher.DECRYPT_MODE, key, iv);
            byte[] decrypted = aesCBC.doFinal(encrypted);
",2
11804805,0,"public class sample{
public static String encode(String key, String data) throws Exception {
  Mac sha256_HMAC = Mac.getInstance(""HmacSHA256"");
  SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(""UTF-8""), ""HmacSHA256"");
  sha256_HMAC.init(secret_key);

  return Hex.encodeHexString(sha256_HMAC.doFinal(data.getBytes(""UTF-8"")));
}

public static void main(String [] args) throws Exception {
  System.out.println(encode(""key"", ""The quick brown fox jumps over the lazy dog""));
}
",4
11886011,1,"        SecureRandom random = new SecureRandom();
        byte[] salt = new byte[16];
        random.nextBytes(salt);

        // Create PBE parameter set
        PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, count);
        PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());",2
11943979,0,"        KeyStore keystore = KeyStore.getInstance(""PKCS12"");
        InputStream keystream = context.getResources().getAssets().open(""client.p12"");
        try {
            keystore.load(keystream, ""dysan100"".toCharArray());",1
11978976,0,"public class sample{
String sha1Hash( String toHash )
{
    String hash = null;
    try
    {
        MessageDigest digest = MessageDigest.getInstance( ""SHA-1"" );
        byte[] bytes = toHash.getBytes(""UTF-8"");
        digest.update(bytes, 0, bytes.length);
        bytes = digest.digest();

        // This is ~55x faster than looping and String.formating()
        hash = bytesToHex( bytes );
    }
    catch( NoSuchAlgorithmException e )
    {
        e.printStackTrace();
    }
    catch( UnsupportedEncodingException e )
    {
        e.printStackTrace();
    }
    return hash;
}

// http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
final protected static char[] hexArray = ""0123456789ABCDEF"".toCharArray();
public static String bytesToHex( byte[] bytes )
{
    char[] hexChars = new char[ bytes.length * 2 ];
    for( int j = 0; j < bytes.length; j++ )
    {
        int v = bytes[ j ] & 0xFF;
        hexChars[ j * 2 ] = hexArray[ v >>> 4 ];
        hexChars[ j * 2 + 1 ] = hexArray[ v & 0x0F ];
    }
    return new String( hexChars );
}
",4
12050822,0,"public static String hashMac(String text, String secretKey)
  throws SignatureException {

 try {
  Key sk = new SecretKeySpec(secretKey.getBytes(), HASH_ALGORITHM);
  Mac mac = Mac.getInstance(sk.getAlgorithm());
  mac.init(sk);
  final byte[] hmac = mac.doFinal(text.getBytes());
  return toHexString(hmac);
 } catch (NoSuchAlgorithmException e1) {
  // throw an exception or pick a different encryption method
  throw new SignatureException(
    ""error building signature, no such algorithm in device ""
      + HASH_ALGORITHM);
 } catch (InvalidKeyException e) {
  throw new SignatureException(
    ""error building signature, invalid key "" + HASH_ALGORITHM);
 }",4
12143167,2,"    byte[] b = ""test"".getBytes(""ASCII"");
    MessageDigest md = MessageDigest.getInstance(""SHA-256"");
    byte[] hashBytes = md.digest(b);
    StringBuffer hexString = new StringBuffer();",4
12143167,2,"    byte[] hashBytes = md.digest(b);
    StringBuffer hexString = new StringBuffer();
    for (int i = 0; i < hashBytes.length; i++) {
        hexString.append(Integer.toHexString(0xFF & hashBytes[i]));
    }",4
12212903,0,"    byte[] encrypted = cipher.doFinal(value);

    SecretKeySpec key2 = getSecretKeySpec(false);
    System.err.println(""encrypt():\t"" + key2.toString());
    cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");",2
12377301,0,"    private static PGPPrivateKey findSecretKey(
            PGPSecretKeyRingCollection pgpSec, long keyID, char[] pass)
            throws PGPException, NoSuchProviderException {
        PGPSecretKey pgpSecKey = pgpSec.getSecretKey(keyID);

        if (pgpSecKey == null) {
            return null;
        }

        return pgpSecKey.extractPrivateKey(pass, ""BC"");
    }

    /**
     * decrypt the passed in message stream
     * 
     * @param encrypted
     *            The message to be decrypted.
     * @param passPhrase
     *            Pass phrase (key)
     * 
     * @return Clear text as a byte array. I18N considerations are not handled
     *         by this routine
     * @exception IOException
     * @exception PGPException
     * @exception NoSuchProviderException
     */
    public static byte[] decrypt(byte[] encrypted, InputStream keyIn, char[] password)
            throws IOException, PGPException, NoSuchProviderException {
        InputStream in = new ByteArrayInputStream(encrypted);

        in = PGPUtil.getDecoderStream(in);

        PGPObjectFactory pgpF = new PGPObjectFactory(in);
        PGPEncryptedDataList enc = null;
        Object o = pgpF.nextObject();

        //
        // the first object might be a PGP marker packet.
        //
        if (o instanceof PGPEncryptedDataList) {
            enc = (PGPEncryptedDataList) o;
        } else {
            enc = (PGPEncryptedDataList) pgpF.nextObject();
        }



        //
        // find the secret key
        //
        Iterator it = enc.getEncryptedDataObjects();
        PGPPrivateKey sKey = null;
        PGPPublicKeyEncryptedData pbe = null;
        PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(
                PGPUtil.getDecoderStream(keyIn));

        while (sKey == null && it.hasNext()) {
            pbe = (PGPPublicKeyEncryptedData) it.next();

            sKey = findSecretKey(pgpSec, pbe.getKeyID(), password);
        }

        if (sKey == null) {
            throw new IllegalArgumentException(
                    ""secret key for message not found."");
        }

        InputStream clear = pbe.getDataStream(sKey, ""BC"");



        PGPObjectFactory pgpFact = new PGPObjectFactory(clear);

        PGPCompressedData cData = (PGPCompressedData) pgpFact.nextObject();

        pgpFact = new PGPObjectFactory(cData.getDataStream());

        PGPLiteralData ld = (PGPLiteralData) pgpFact.nextObject();

        InputStream unc = ld.getInputStream();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int ch;

        while ((ch = unc.read()) >= 0) {
            out.write(ch);

        }

        byte[] returnBytes = out.toByteArray();
        out.close();
        return returnBytes;
    }

    /**
     * Simple PGP encryptor between byte[].
     * 
     * @param clearData
     *            The test to be encrypted
     * @param passPhrase
     *            The pass phrase (key). This method assumes that the key is a
     *            simple pass phrase, and does not yet support RSA or more
     *            sophisiticated keying.
     * @param fileName
     *            File name. This is used in the Literal Data Packet (tag 11)
     *            which is really inly important if the data is to be related to
     *            a file to be recovered later. Because this routine does not
     *            know the source of the information, the caller can set
     *            something here for file name use that will be carried. If this
     *            routine is being used to encrypt SOAP MIME bodies, for
     *            example, use the file name from the MIME type, if applicable.
     *            Or anything else appropriate.
     * 
     * @param armor
     * 
     * @return encrypted data.
     * @exception IOException
     * @exception PGPException
     * @exception NoSuchProviderException
     */
    public static byte[] encrypt(byte[] clearData, PGPPublicKey encKey,
            String fileName,boolean withIntegrityCheck, boolean armor)
            throws IOException, PGPException, NoSuchProviderException {
        if (fileName == null) {
            fileName = PGPLiteralData.CONSOLE;
        }

        ByteArrayOutputStream encOut = new ByteArrayOutputStream();

        OutputStream out = encOut;
        if (armor) {
            out = new ArmoredOutputStream(out);
        }

        ByteArrayOutputStream bOut = new ByteArrayOutputStream();

        PGPCompressedDataGenerator comData = new PGPCompressedDataGenerator(
                PGPCompressedDataGenerator.ZIP);
        OutputStream cos = comData.open(bOut); // open it with the final
        // destination
        PGPLiteralDataGenerator lData = new PGPLiteralDataGenerator();

        // we want to generate compressed data. This might be a user option
        // later,
        // in which case we would pass in bOut.
        OutputStream pOut = lData.open(cos, // the compressed output stream
                PGPLiteralData.BINARY, fileName, // ""filename"" to store
                clearData.length, // length of clear data
                new Date() // current time
                );
        pOut.write(clearData);

        lData.close();
        comData.close();

        PGPEncryptedDataGenerator cPk = new PGPEncryptedDataGenerator(
                PGPEncryptedData.CAST5, withIntegrityCheck, new SecureRandom(),
                ""BC"");

        cPk.addMethod(encKey);

        byte[] bytes = bOut.toByteArray();

        OutputStream cOut = cPk.open(out, bytes.length);

        cOut.write(bytes); // obtain the actual bytes from the compressed stream

        cOut.close();

        out.close();

        return encOut.toByteArray();
    }

    private static PGPPublicKey readPublicKey(InputStream in)
            throws IOException, PGPException {
        in = PGPUtil.getDecoderStream(in);

        PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection(in);

        //
        // we just loop through the collection till we find a key suitable for
        // encryption, in the real
        // world you would probably want to be a bit smarter about this.
        //

        //
        // iterate through the key rings.
        //
        Iterator rIt = pgpPub.getKeyRings();

        while (rIt.hasNext()) {
            PGPPublicKeyRing kRing = (PGPPublicKeyRing) rIt.next();
            Iterator kIt = kRing.getPublicKeys();

            while (kIt.hasNext()) {
                PGPPublicKey k = (PGPPublicKey) kIt.next();

                if (k.isEncryptionKey()) {
                    return k;
                }
            }
        }

        throw new IllegalArgumentException(
                ""Can't find encryption key in key ring."");
    }

    public static byte[] getBytesFromFile(File file) throws IOException {
        InputStream is = new FileInputStream(file);

        // Get the size of the file
        long length = file.length();

        if (length > Integer.MAX_VALUE) {
            // File is too large
        }

        // Create the byte array to hold the data
        byte[] bytes = new byte[(int)length];

        // Read in the bytes
        int offset = 0;
        int numRead = 0;
        while (offset < bytes.length
               && (numRead=is.read(bytes, offset, bytes.length-offset)) >= 0) {
            offset += numRead;
        }

        // Ensure all the bytes have been read in
        if (offset < bytes.length) {
            throw new IOException(""Could not completely read file ""+file.getName());
        }

        // Close the input stream and return bytes
        is.close();
        return bytes;
    }
",43
12377301,0,"        Object o = pgpF.nextObject();

        //
        // the first object might be a PGP marker packet.
        //
        if (o instanceof PGPEncryptedDataList) {
            enc = (PGPEncryptedDataList) o;
        } else {
            enc = (PGPEncryptedDataList) pgpF.nextObject();
        }



        //
        // find the secret key
        //
        Iterator it = enc.getEncryptedDataObjects();
        PGPPrivateKey sKey = null;
        PGPPublicKeyEncryptedData pbe = null;
        PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(
                PGPUtil.getDecoderStream(keyIn));
",4
12377301,0,"        if (o instanceof PGPEncryptedDataList) {
            enc = (PGPEncryptedDataList) o;
        } else {
            enc = (PGPEncryptedDataList) pgpF.nextObject();
        }



        //
        // find the secret key
        //
        Iterator it = enc.getEncryptedDataObjects();
        PGPPrivateKey sKey = null;
        PGPPublicKeyEncryptedData pbe = null;",4
12377301,0,"        PGPObjectFactory pgpFact = new PGPObjectFactory(clear);

        PGPCompressedData cData = (PGPCompressedData) pgpFact.nextObject();

        pgpFact = new PGPObjectFactory(cData.getDataStream());

        PGPLiteralData ld = (PGPLiteralData) pgpFact.nextObject();

        InputStream unc = ld.getInputStream();

        ByteArrayOutputStream out = new ByteArrayOutputStream();
        int ch;

        while ((ch = unc.read()) >= 0) {
            out.write(ch);

        }

        byte[] returnBytes = out.toByteArray();
        out.close();",3
12377301,0,"    private static PGPPublicKey readPublicKey(InputStream in)
            throws IOException, PGPException {
        in = PGPUtil.getDecoderStream(in);

        PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection(in);

        //
        // we just loop through the collection till we find a key suitable for
        // encryption, in the real
        // world you would probably want to be a bit smarter about this.
        //

        //
        // iterate through the key rings.
        //
        Iterator rIt = pgpPub.getKeyRings();

        while (rIt.hasNext()) {
            PGPPublicKeyRing kRing = (PGPPublicKeyRing) rIt.next();
            Iterator kIt = kRing.getPublicKeys();

            while (kIt.hasNext()) {
                PGPPublicKey k = (PGPPublicKey) kIt.next();

                if (k.isEncryptionKey()) {
                    return k;
                }
            }
        }

        throw new IllegalArgumentException(
                ""Can't find encryption key in key ring."");
    }
",4
12377301,0,"        Iterator rIt = pgpPub.getKeyRings();

        while (rIt.hasNext()) {
            PGPPublicKeyRing kRing = (PGPPublicKeyRing) rIt.next();
            Iterator kIt = kRing.getPublicKeys();

            while (kIt.hasNext()) {
                PGPPublicKey k = (PGPPublicKey) kIt.next();

                if (k.isEncryptionKey()) {
                    return k;
                }
            }
        }

        throw new IllegalArgumentException(
                ""Can't find encryption key in key ring."");",4
12377301,0,"            Iterator kIt = kRing.getPublicKeys();

            while (kIt.hasNext()) {
                PGPPublicKey k = (PGPPublicKey) kIt.next();

                if (k.isEncryptionKey()) {
                    return k;
                }
            }",4
12382879,0,"    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.login);

        usernameEditText = (EditText) findViewById(R.id.login_username_editText);
        passwordEditText = (EditText) findViewById(R.id.login_password_editText);

        sendPostReqButton = (Button) findViewById(R.id.login_sendPostReq_button);
        sendPostReqButton.setOnClickListener(this);

        clearButton = (Button) findViewById(R.id.login_clear_button);
        clearButton.setOnClickListener(this);        
    }

    @Override
    public void onClick(View v) {

        if(v.getId() == R.id.login_clear_button){
            usernameEditText.setText("""");
            passwordEditText.setText("""");
            passwordEditText.setCursorVisible(false);
            passwordEditText.setFocusable(false);
            usernameEditText.setCursorVisible(true);
            passwordEditText.setFocusable(true);
        }else if(v.getId() == R.id.login_sendPostReq_button){
            String givenUsername = usernameEditText.getEditableText().toString();
            String givenPassword = passwordEditText.getEditableText().toString();

            System.out.println(""Given username :"" + givenUsername + "" Given password :"" + givenPassword);

            sendPostRequest(givenUsername, givenPassword);
        }   
    }

    private void sendPostRequest(String givenUsername, String givenPassword) {

        class SendPostReqAsyncTask extends AsyncTask<String, Void, String>{

            @Override
            protected String doInBackground(String... params) {

                String paramUsername = params[0];
                String paramPassword = params[1];

                System.out.println(""*** doInBackground ** paramUsername "" + paramUsername + "" paramPassword :"" + paramPassword);

                HttpClient httpClient = new DefaultHttpClient();

                // In a POST request, we don't pass the values in the URL.
                //Therefore we use only the web page URL as the parameter of the HttpPost argument
                HttpPost httpPost = new HttpPost(""http://www.nirmana.lk/hec/android/postLogin.php"");

                // Because we are not passing values over the URL, we should have a mechanism to pass the values that can be
                //uniquely separate by the other end.
                //To achieve that we use BasicNameValuePair             
                //Things we need to pass with the POST request
                BasicNameValuePair usernameBasicNameValuePair = new BasicNameValuePair(""paramUsername"", paramUsername);
                BasicNameValuePair passwordBasicNameValuePAir = new BasicNameValuePair(""paramPassword"", paramPassword);

                // We add the content that we want to pass with the POST request to as name-value pairs
                //Now we put those sending details to an ArrayList with type safe of NameValuePair
                List<NameValuePair> nameValuePairList = new ArrayList<NameValuePair>();
                nameValuePairList.add(usernameBasicNameValuePair);
                nameValuePairList.add(passwordBasicNameValuePAir);

                try {
                    // UrlEncodedFormEntity is an entity composed of a list of url-encoded pairs. 
                    //This is typically useful while sending an HTTP POST request. 
                    UrlEncodedFormEntity urlEncodedFormEntity = new UrlEncodedFormEntity(nameValuePairList);

                    // setEntity() hands the entity (here it is urlEncodedFormEntity) to the request.
                    httpPost.setEntity(urlEncodedFormEntity);

                    try {
                        // HttpResponse is an interface just like HttpPost.
                        //Therefore we can't initialize them
                        HttpResponse httpResponse = httpClient.execute(httpPost);

                        // According to the JAVA API, InputStream constructor do nothing. 
                        //So we can't initialize InputStream although it is not an interface
                        InputStream inputStream = httpResponse.getEntity().getContent();

                        InputStreamReader inputStreamReader = new InputStreamReader(inputStream);

                        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);

                        StringBuilder stringBuilder = new StringBuilder();

                        String bufferedStrChunk = null;

                        while((bufferedStrChunk = bufferedReader.readLine()) != null){
                            stringBuilder.append(bufferedStrChunk);
                        }

                        return stringBuilder.toString();

                    } catch (ClientProtocolException cpe) {
                        System.out.println(""First Exception caz of HttpResponese :"" + cpe);
                        cpe.printStackTrace();
                    } catch (IOException ioe) {
                        System.out.println(""Second Exception caz of HttpResponse :"" + ioe);
                        ioe.printStackTrace();
                    }

                } catch (UnsupportedEncodingException uee) {
                    System.out.println(""An Exception given because of UrlEncodedFormEntity argument :"" + uee);
                    uee.printStackTrace();
                }

                return null;
            }

            @Override
            protected void onPostExecute(String result) {
                super.onPostExecute(result);

                if(result.equals(""working"")){
                    Toast.makeText(getApplicationContext(), ""HTTP POST is working..."", Toast.LENGTH_LONG).show();
                }else{
                    Toast.makeText(getApplicationContext(), ""Invalid POST req..."", Toast.LENGTH_LONG).show();
                }
            }           
        }

        SendPostReqAsyncTask sendPostReqAsyncTask = new SendPostReqAsyncTask();
        sendPostReqAsyncTask.execute(givenUsername, givenPassword);     
    }",1
12383031,0,"public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.login);

    usernameEditText = (EditText) findViewById(R.id.login_username_editText);
    passwordEditText = (EditText) findViewById(R.id.login_password_editText);

    sendPostReqButton = (Button) findViewById(R.id.login_sendPostReq_button);
    sendPostReqButton.setOnClickListener(this);

    clearButton = (Button) findViewById(R.id.login_clear_button);
    clearButton.setOnClickListener(this);        
}

@Override
public void onClick(View v) {

    if(v.getId() == R.id.login_clear_button){
        usernameEditText.setText("""");
        passwordEditText.setText("""");
        passwordEditText.setCursorVisible(false);
        passwordEditText.setFocusable(false);
        usernameEditText.setCursorVisible(true);
        passwordEditText.setFocusable(true);
    }else if(v.getId() == R.id.login_sendPostReq_button){
        String givenUsername = usernameEditText.getEditableText().toString();
        String givenPassword = passwordEditText.getEditableText().toString();

        System.out.println(""Given username :"" + givenUsername + "" Given password :"" + givenPassword);

        sendPostRequest(givenUsername, givenPassword);
    }   
}

private void sendPostRequest(String givenUsername, String givenPassword) {

    class SendPostReqAsyncTask extends AsyncTask<String, Void, String>{

        @Override
        protected String doInBackground(String... params) {

            String paramUsername = params[0];
            String paramPassword = params[1];

            System.out.println(""*** doInBackground ** paramUsername "" + paramUsername + "" paramPassword :"" + paramPassword);

            HttpClient httpClient = new DefaultHttpClient();

            // In a POST request, we don't pass the values in the URL.
            //Therefore we use only the web page URL as the parameter of the HttpPost argument
            HttpPost httpPost = new HttpPost(""http://www.nirmana.lk/hec/android/postLogin.php"");

            // Because we are not passing values over the URL, we should have a mechanism to pass the values that can be
            //uniquely separate by the other end.
            //To achieve that we use BasicNameValuePair             
            //Things we need to pass with the POST request
            BasicNameValuePair usernameBasicNameValuePair = new BasicNameValuePair(""paramUsername"", paramUsername);
            BasicNameValuePair passwordBasicNameValuePAir = new BasicNameValuePair(""paramPassword"", paramPassword);

            // We add the content that we want to pass with the POST request to as name-value pairs
            //Now we put those sending details to an ArrayList with type safe of NameValuePair
            List<NameValuePair> nameValuePairList = new ArrayList<NameValuePair>();
            nameValuePairList.add(usernameBasicNameValuePair);
            nameValuePairList.add(passwordBasicNameValuePAir);

            try {
                // UrlEncodedFormEntity is an entity composed of a list of url-encoded pairs. 
                //This is typically useful while sending an HTTP POST request. 
                UrlEncodedFormEntity urlEncodedFormEntity = new UrlEncodedFormEntity(nameValuePairList);

                // setEntity() hands the entity (here it is urlEncodedFormEntity) to the request.
                httpPost.setEntity(urlEncodedFormEntity);

                try {
                    // HttpResponse is an interface just like HttpPost.
                    //Therefore we can't initialize them
                    HttpResponse httpResponse = httpClient.execute(httpPost);

                    // According to the JAVA API, InputStream constructor do nothing. 
                    //So we can't initialize InputStream although it is not an interface
                    InputStream inputStream = httpResponse.getEntity().getContent();

                    InputStreamReader inputStreamReader = new InputStreamReader(inputStream);

                    BufferedReader bufferedReader = new BufferedReader(inputStreamReader);

                    StringBuilder stringBuilder = new StringBuilder();

                    String bufferedStrChunk = null;

                    while((bufferedStrChunk = bufferedReader.readLine()) != null){
                        stringBuilder.append(bufferedStrChunk);
                    }

                    return stringBuilder.toString();

                } catch (ClientProtocolException cpe) {
                    System.out.println(""First Exception caz of HttpResponese :"" + cpe);
                    cpe.printStackTrace();
                } catch (IOException ioe) {
                    System.out.println(""Second Exception caz of HttpResponse :"" + ioe);
                    ioe.printStackTrace();
                }

            } catch (UnsupportedEncodingException uee) {
                System.out.println(""An Exception given because of UrlEncodedFormEntity argument :"" + uee);
                uee.printStackTrace();
            }

            return null;
        }

        @Override
        protected void onPostExecute(String result) {
            super.onPostExecute(result);

            if(result.equals(""working"")){
                Toast.makeText(getApplicationContext(), ""HTTP POST is working..."", Toast.LENGTH_LONG).show();
            }else{
                Toast.makeText(getApplicationContext(), ""Invalid POST req..."", Toast.LENGTH_LONG).show();
            }
        }           
    }

    SendPostReqAsyncTask sendPostReqAsyncTask = new SendPostReqAsyncTask();
    sendPostReqAsyncTask.execute(givenUsername, givenPassword);     
}",1
12383083,0,"public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.login);

    usernameEditText = (EditText) findViewById(R.id.login_username_editText);
    passwordEditText = (EditText) findViewById(R.id.login_password_editText);

    sendPostReqButton = (Button) findViewById(R.id.login_sendPostReq_button);
    sendPostReqButton.setOnClickListener(this);

    clearButton = (Button) findViewById(R.id.login_clear_button);
    clearButton.setOnClickListener(this);        
}

@Override
public void onClick(View v) {

    if(v.getId() == R.id.login_clear_button){
        usernameEditText.setText("""");
        passwordEditText.setText("""");
        passwordEditText.setCursorVisible(false);
        passwordEditText.setFocusable(false);
        usernameEditText.setCursorVisible(true);
        passwordEditText.setFocusable(true);
    }else if(v.getId() == R.id.login_sendPostReq_button){
        String givenUsername = usernameEditText.getEditableText().toString();
        String givenPassword = passwordEditText.getEditableText().toString();

        System.out.println(""Given username :"" + givenUsername + "" Given password :"" + givenPassword);

        sendPostRequest(givenUsername, givenPassword);
    }   
}

private void sendPostRequest(String givenUsername, String givenPassword) {

    class SendPostReqAsyncTask extends AsyncTask<String, Void, String>{

        @Override
        protected String doInBackground(String... params) {

            String paramUsername = params[0];
            String paramPassword = params[1];

            System.out.println(""*** doInBackground ** paramUsername "" + paramUsername + "" paramPassword :"" + paramPassword);

            HttpClient httpClient = new DefaultHttpClient();

            // In a POST request, we don't pass the values in the URL.
            //Therefore we use only the web page URL as the parameter of the HttpPost argument
            HttpPost httpPost = new HttpPost(""http://www.nirmana.lk/hec/android/postLogin.php"");

            // Because we are not passing values over the URL, we should have a mechanism to pass the values that can be
            //uniquely separate by the other end.
            //To achieve that we use BasicNameValuePair             
            //Things we need to pass with the POST request
            BasicNameValuePair usernameBasicNameValuePair = new BasicNameValuePair(""paramUsername"", paramUsername);
            BasicNameValuePair passwordBasicNameValuePAir = new BasicNameValuePair(""paramPassword"", paramPassword);

            // We add the content that we want to pass with the POST request to as name-value pairs
            //Now we put those sending details to an ArrayList with type safe of NameValuePair
            List<NameValuePair> nameValuePairList = new ArrayList<NameValuePair>();
            nameValuePairList.add(usernameBasicNameValuePair);
            nameValuePairList.add(passwordBasicNameValuePAir);

            try {
                // UrlEncodedFormEntity is an entity composed of a list of url-encoded pairs. 
                //This is typically useful while sending an HTTP POST request. 
                UrlEncodedFormEntity urlEncodedFormEntity = new UrlEncodedFormEntity(nameValuePairList);

                // setEntity() hands the entity (here it is urlEncodedFormEntity) to the request.
                httpPost.setEntity(urlEncodedFormEntity);

                try {
                    // HttpResponse is an interface just like HttpPost.
                    //Therefore we can't initialize them
                    HttpResponse httpResponse = httpClient.execute(httpPost);

                    // According to the JAVA API, InputStream constructor do nothing. 
                    //So we can't initialize InputStream although it is not an interface
                    InputStream inputStream = httpResponse.getEntity().getContent();

                    InputStreamReader inputStreamReader = new InputStreamReader(inputStream);

                    BufferedReader bufferedReader = new BufferedReader(inputStreamReader);

                    StringBuilder stringBuilder = new StringBuilder();

                    String bufferedStrChunk = null;

                    while((bufferedStrChunk = bufferedReader.readLine()) != null){
                        stringBuilder.append(bufferedStrChunk);
                    }

                    return stringBuilder.toString();

                } catch (ClientProtocolException cpe) {
                    System.out.println(""First Exception caz of HttpResponese :"" + cpe);
                    cpe.printStackTrace();
                } catch (IOException ioe) {
                    System.out.println(""Second Exception caz of HttpResponse :"" + ioe);
                    ioe.printStackTrace();
                }

            } catch (UnsupportedEncodingException uee) {
                System.out.println(""An Exception given because of UrlEncodedFormEntity argument :"" + uee);
                uee.printStackTrace();
            }

            return null;
        }

        @Override
        protected void onPostExecute(String result) {
            super.onPostExecute(result);

            if(result.equals(""working"")){
                Toast.makeText(getApplicationContext(), ""HTTP POST is working..."", Toast.LENGTH_LONG).show();
            }else{
                Toast.makeText(getApplicationContext(), ""Invalid POST req..."", Toast.LENGTH_LONG).show();
            }
        }           
    }

    SendPostReqAsyncTask sendPostReqAsyncTask = new SendPostReqAsyncTask();
    sendPostReqAsyncTask.execute(givenUsername, givenPassword);     
}",1
12457452,0,"        byte messageDigest[] = algorithm.digest();

        StringBuffer hexString = new StringBuffer();
        for (int i=0;i<messageDigest.length;i++) {
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
        }",4
12514888,0,"    KeyStore keystore = KeyStore.getInstance(""JKS"");
    keystore.load(null);
    keystore.setCertificateEntry(""cert-alias"", cert);
    keystore.setKeyEntry(""key-alias"", key, ""changeit"".toCharArray(), new Certificate[] {cert});

    KeyManagerFactory kmf = KeyManagerFactory.getInstance(""SunX509"");
    kmf.init(keystore, ""changeit"".toCharArray());

    KeyManager[] km = kmf.getKeyManagers(); 

    context.init(km, null, null);

    return context.getSocketFactory();",1
12514888,2,"protected static byte[] parseDERFromPEM(byte[] pem, String beginDelimiter, String endDelimiter) {
    String data = new String(pem);
    String[] tokens = data.split(beginDelimiter);
    tokens = tokens[1].split(endDelimiter);
    return DatatypeConverter.parseBase64Binary(tokens[0]);        
}
",1
12571068,2,"    public static byte[][] EVP_BytesToKey(int key_len, int iv_len, MessageDigest md,
            byte[] salt, byte[] data, int count) {
        byte[][] both = new byte[2][];
        byte[] key = new byte[key_len];
        int key_ix = 0;
        byte[] iv = new byte[iv_len];
        int iv_ix = 0;
        both[0] = key;
        both[1] = iv;
        byte[] md_buf = null;
        int nkey = key_len;
        int niv = iv_len;
        int i = 0;
        if (data == null) {
            return both;
        }
        int addmd = 0;
        for (;;) {
            md.reset();
            if (addmd++ > 0) {
                md.update(md_buf);
            }
            md.update(data);
            if (null != salt) {
                md.update(salt, 0, 8);
            }
            md_buf = md.digest();
            for (i = 1; i < count; i++) {
                md.reset();
                md.update(md_buf);
                md_buf = md.digest();
            }
            i = 0;
            if (nkey > 0) {
                for (;;) {
                    if (nkey == 0)
                        break;
                    if (i == md_buf.length)
                        break;
                    key[key_ix++] = md_buf[i];
                    nkey--;
                    i++;
                }
            }
            if (niv > 0 && i != md_buf.length) {
                for (;;) {
                    if (niv == 0)
                        break;
                    if (i == md_buf.length)
                        break;
                    iv[iv_ix++] = md_buf[i];
                    niv--;
                    i++;
                }
            }
            if (nkey == 0 && niv == 0) {
                break;
            }
        }
        for (i = 0; i < md_buf.length; i++) {
            md_buf[i] = 0;
        }
        return both;",4
12673787,0,"        mCipher.init(Cipher.DECRYPT_MODE, mSecretKeySpec, mIvParameterSpec);
        byte[] decrypted = new byte[mCipher.getOutputSize(input.length)];
        int dec_len = mCipher.update(input, 0, input.length, decrypted, 0);
        dec_len += mCipher.doFinal(decrypted, dec_len);
        return ARRAY.copyOf(decrypted, dec_len);
    } catch (ShortBufferException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    }
    return null;",2
12673787,0,"        byte[] decrypted = new byte[mCipher.getOutputSize(input.length)];
        int dec_len = mCipher.update(input, 0, input.length, decrypted, 0);
        dec_len += mCipher.doFinal(decrypted, dec_len);",2
12673787,0,"        mCipher.init(Cipher.ENCRYPT_MODE, mSecretKeySpec, mIvParameterSpec);
        byte[] encrypted = new byte[mCipher.getOutputSize(data.length)];
        int enc_len = mCipher.update(data, 0, data.length, encrypted, 0);
        enc_len += mCipher.doFinal(encrypted, enc_len);
        return ARRAY.copyOf(encrypted, enc_len);
    } catch (ShortBufferException e) {
        e.printStackTrace();
    } catch (IllegalBlockSizeException e) {
        e.printStackTrace();
    } catch (BadPaddingException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (InvalidAlgorithmParameterException e) {
        e.printStackTrace();
    }
    return null;",2
12673787,0,"        byte[] encrypted = new byte[mCipher.getOutputSize(data.length)];
        int enc_len = mCipher.update(data, 0, data.length, encrypted, 0);
        enc_len += mCipher.doFinal(encrypted, enc_len);",2
12690835,1,"    Cipher cipher = Cipher.getInstance(cipherAlgo);
    IvParameterSpec ivSpec = new IvParameterSpec(iv);
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

    // decrypt
    byte[] decBytes = cipher.doFinal(encryptedData);
",2
12729052,0,"        byte[] cert = signatures[0].toByteArray();
        InputStream input = new ByteArrayInputStream(cert);
        CertificateFactory cf = CertificateFactory.getInstance(""X509"");
        X509Certificate cf509 = (X509Certificate) cf.generateCertificate(input);",3
12742591,0,"        public Socket createSocket(Socket socket, String host, int port,
                boolean autoClose) throws IOException
        {
            return Cur_SSL_Context.getSocketFactory().createSocket(socket, host, port, autoClose);
        }

        @Override
        public Socket createSocket() throws IOException
        {
            return Cur_SSL_Context.getSocketFactory().createSocket();
        }",1
12806835,0,"    public byte[] Encrypt(byte[] data)
    {
        IBlockCipher theCipher = null;
        theCipher = new RijndaelEngine(_keyBitSize);
        cipher = new PaddedBufferedBlockCipher(new CbcBlockCipher(theCipher));
        IVkey = new ParametersWithIV(key, _iv);
        cipher.Init(true, IVkey);

        int size = cipher.GetOutputSize(data.Length);
        byte[] result = new byte[size];
        int olen = cipher.ProcessBytes(data, 0, data.Length, result, 0);
        olen += cipher.DoFinal(result, olen);

        if (olen < size)
        {
            byte[] tmp = new byte[olen];
            Array.Copy(result, 0, tmp, 0, olen);
            result = tmp;
        }

        return result;
    }
",2
12806835,0,"    public byte[] Decrypt(byte[] data)
    {
        IBlockCipher theCipher = null;
        theCipher = new RijndaelEngine(_keyBitSize);
        cipher = new PaddedBufferedBlockCipher(new CbcBlockCipher(theCipher));
        IVkey = new ParametersWithIV(key, _iv);
        cipher.Init(false, IVkey);

        int size = cipher.GetOutputSize(data.Length);
        byte[] result = new byte[size];
        int olen = cipher.ProcessBytes(data, 0, data.Length, result, 0);
        olen += cipher.DoFinal(result, olen);

        if (olen < size)
        {
            byte[] tmp = new byte[olen];
            Array.Copy(result, 0, tmp, 0, olen);
            result = tmp;
        }

        return result;
    }",2
12837136,0,"SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""AES"");
SecretKey key = keyFactory.generateSecret(spec);

// use a cipher to decrypt the eid
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.DECRYPT_MODE, key);",2
12889528,0,"public class sample{
private void getHashKey()
{
        PackageInfo info;
        try {
        info = getPackageManager().getPackageInfo(""your app package name"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
                   MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
                   //String something = new String(Base64.encode(md.digest(), 0));
                     String something = new String(Base64.encode(md.digest(),0));
                   Log.e(""**** Hash Key"", something);
        } 
        }
        catch (NameNotFoundException e1) {
        Log.e(""name not found"", e1.toString());
        }

        catch (NoSuchAlgorithmException e) {
        Log.e(""no such an algorithm"", e.toString());
        }
        catch (Exception e){
        Log.e(""exception"", e.toString());
        }

}
",4
12889528,0,"        for (Signature signature : info.signatures) {
                   MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
                   //String something = new String(Base64.encode(md.digest(), 0));
                     String something = new String(Base64.encode(md.digest(),0));
                   Log.e(""**** Hash Key"", something);
        } ",4
12889528,0,"        for (Signature signature : info.signatures) {
                   MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
                   //String something = new String(Base64.encode(md.digest(), 0));
                     String something = new String(Base64.encode(md.digest(),0));
                   Log.e(""**** Hash Key"", something);
        } 
        }
        catch (NameNotFoundException e1) {
        Log.e(""name not found"", e1.toString());
        }

        catch (NoSuchAlgorithmException e) {
        Log.e(""no such an algorithm"", e.toString());
        }
        catch (Exception e){
        Log.e(""exception"", e.toString());
        }
",4
12914329,1,"String principal = ""CN=company1, OU=company1, O=company1, C=GB"";
AsymmetricKeyParameter privateKey = PrivateKeyFactory.createKey(pair.getPrivate().getEncoded());
AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder()
        .find(""SHA1WITHRSA"");
AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(""SHA-1"");
ContentSigner signer = new BcRSAContentSignerBuilder(signatureAlgorithm, digestAlgorithm).build(privateKey);

PKCS10CertificationRequestBuilder csrBuilder = new JcaPKCS10CertificationRequestBuilder(new X500Name(
        principal), pair.getPublic());
ExtensionsGenerator extensionsGenerator = new ExtensionsGenerator();
extensionsGenerator.addExtension(X509Extension.basicConstraints, true, new BasicConstraints(true));
extensionsGenerator.addExtension(X509Extension.keyUsage, true, new KeyUsage(KeyUsage.keyCertSign
        | KeyUsage.cRLSign));
csrBuilder.addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensionsGenerator.generate());",3
12984227,3,"String hash;
try {
    hash = new BASE64Encoder().encode(MessageDigest.getInstance(""SHA-1"").digest((keys.get(""Sec-WebSocket-Key"") + ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"").getBytes()));
} catch (NoSuchAlgorithmException ex) {
    ex.printStackTrace();
    return false;
}
",4
12984227,10,"    String hash;
    try {
        hash = new BASE64Encoder().encode(MessageDigest.getInstance(""SHA-1"").digest((keys.get(""Sec-WebSocket-Key"") + ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"").getBytes()));
    } catch (NoSuchAlgorithmException ex) {
        ex.printStackTrace();
        return false;
    }

    //Write handshake response",4
13028611,0,"public class sample{
public static byte[] signer(byte[] data, PrivateKey key) throws Exception {
    Signature signer = Signature.getInstance(""SHA1withRSA/ISO9796-2"", ""BC"");
    signer.initSign(key);
    signer.update(data);
    return signer.sign();
}
",4
13086234,0,"public class sample{
 public void foo(){
    X509EncodedKeySpec x509ks = new X509EncodedKeySpec(
            publicKey.getEncoded());
    FileOutputStream fos = new FileOutputStream(strPathFilePubKey);
    fos.write(x509ks.getEncoded());

}",3
13086234,1,"public class sample{
 public void foo(){
    byte[] encodedKey = IOUtils.toByteArray(new FileInputStream(strPathFilePubKey));
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"", p);
    X509EncodedKeySpec pkSpec = new X509EncodedKeySpec(
            encodedKey);
    PublicKey publicKey = keyFactory.generatePublic(pkSpec);

}",3
13086234,2,"public class sample{
 public void foo(){
    PKCS8EncodedKeySpec pkcsKeySpec = new PKCS8EncodedKeySpec(
            privateKey.getEncoded());
    FileOutputStream fos = new FileOutputStream(strPathFilePrivbKey);
    fos.write(pkcsKeySpec.getEncoded());

}",3
13086234,3,"public class sample{
 public void foo(){
    byte[] encodedKey = IOUtils.toByteArray(new FileInputStream(strPathFilePrivKey));
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"", p);
    PKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(
            encodedKey);
    PrivateKey privateKey = keyFactory.generatePrivate(privKeySpec);

}",3
13118911,3,"public class sample{
 public void foo(){
KeyStore ts = KeyStore.getInstance(""BKS"");
InputStream in = getResources().openRawResource(R.raw.mytruststore);
ts.load(in, TRUSTSTORE_PASSWORD.toCharArray());

SchemeRegistry schemeRegistry = new SchemeRegistry();
schemeRegistry.register(new Scheme(""http"", PlainSocketFactory
                .getSocketFactory(), 80));
SSLSocketFactory sslSocketFactory = new SSLSocketFactory(ts);
schemeRegistry.register(new Scheme(""https"", sslSocketFactory, 443));
HttpParams params = new BasicHttpParams();
ClientConnectionManager cm = 
    new ThreadSafeClientConnManager(params, schemeRegistry);

HttpClient client = new DefaultHttpClient(cm, params);

}",1
13209169,2,"Cipher eCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

// filled with 00h characters first, use Cipher instance so you can switch algorithms
byte[] realIV = new byte[eCipher.getBlockSize()];

// actually fill with random
random.nextBytes(realIV);

// MISSING: create IvParameterSpec
IvParameterSpec ivSpec = new IvParameterSpec(realIV);

// create the cipher using the IV
eCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec);

// NOTE: you should really not encrypt passwords for verification",2
13237486,4,"        String data = ""my data"";
        byte[] secretKey = secretAccessKey.getBytes();
        SecretKeySpec signingKey = new SecretKeySpec(secretKey, ""HmacSHA256"");
        Mac mac = Mac.getInstance(""HmacSHA256"");
        mac.init(signingKey);",4
13343716,0,"            byte[] buffer = new byte[8192];
            int noBytes = 0;
            byte[] cipherBlock = new byte[encryptcipher
                    .getOutputSize(buffer.length)];

            int cipherBytes;
            long startTime = System.currentTimeMillis();",-1
13343716,0,"            cipherBytes = encryptcipher.doFinal(cipherBlock, 0);
            fos.write(cipherBlock, 0, cipherBytes);
            System.out
                    .println(""encryption ""
                            + "" took ""
                            + ((System.currentTimeMillis() - startTime) / 1000.0)
                            + ""s"");
            // close the files
            fos.close();
            fis.close();
            Log.i(""encrypt"", ""done"");",2
13343716,0,"            byte[] buffer = new byte[8192];
            int noBytes = 0;
            byte[] cipherBlock = new byte[decryptCipher
                    .getOutputSize(buffer.length)];
            int cipherBytes;
            long startTime = System.currentTimeMillis();",-1
13343716,0,"            cipherBytes = decryptCipher.doFinal(cipherBlock, 0);
            fos.write(cipherBlock, 0, cipherBytes);
            System.out
                    .println(""decryption ""
                            + "" took ""
                            + ((System.currentTimeMillis() - startTime) / 1000.0)
                            + ""s"");
            // close the files
            fos.close();
            fis.close();
            Log.i(""decrypt"", ""done"");",2
13362024,0,"public static void main(String args[]) throws Exception {

Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());

new GoogleTest().sendSSLMessage(sendTo, emailSubjectTxt,
emailMsgTxt, emailFromAddress);
System.out.println(""Sucessfully mail to All Users"");",1
13409628,3,"public static String encrypt(String seed, String cleartext) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext.getBytes());
    String fromHex = toHex(result);
    String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));
    return base64;
}


public static String decrypt(String seed, String encrypted) throws Exception {
    byte[] seedByte = seed.getBytes();
    System.arraycopy(seedByte, 0, key, 0, ((seedByte.length < 16) ? seedByte.length : 16));
    String base64 = new String(Base64.decode(encrypted, 0));
    byte[] rawKey = getRawKey(seedByte);
    byte[] enc = toByte(base64);
    byte[] result = decrypt(rawKey, enc);
    return new String(result);
}


public static byte[] encryptBytes(String seed, byte[] cleartext) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext);
    return result;
}


public static byte[] decryptBytes(String seed, byte[] encrypted) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = decrypt(rawKey, encrypted);
    return result;
}


private static byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES""); // , ""SC"");
    SecureRandom sr = null;
    if (android.os.Build.VERSION.SDK_INT >= JELLY_BEAN_4_2) {
        sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
    } else {
        sr = SecureRandom.getInstance(""SHA1PRNG"");
    }
    sr.setSeed(seed);
    try {
        kgen.init(256, sr);
        // kgen.init(128, sr);
    } catch (Exception e) {
        // Log.w(LOG, ""This device doesn't suppor 256bits, trying 192bits."");
        try {
            kgen.init(192, sr);
        } catch (Exception e1) {
            // Log.w(LOG, ""This device doesn't suppor 192bits, trying 128bits."");
            kgen.init(128, sr);
        }
    }
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}


private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES""); // /ECB/PKCS7Padding"", ""SC"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}


private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES""); // /ECB/PKCS7Padding"", ""SC"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
    return decrypted;
}


public static String toHex(String txt) {
    return toHex(txt.getBytes());
}


public static String fromHex(String hex) {
    return new String(toByte(hex));
}


public static byte[] toByte(String hexString) {
    int len = hexString.length() / 2;
    byte[] result = new byte[len];
    for (int i = 0; i < len; i++)
        result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();
    return result;
}


public static String toHex(byte[] buf) {
    if (buf == null) return """";
    StringBuffer result = new StringBuffer(2 * buf.length);
    for (int i = 0; i < buf.length; i++) {
        appendHex(result, buf[i]);
    }
    return result.toString();
}


private static void appendHex(StringBuffer sb, byte b) {
    sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));
}
",5
13438590,1,"    SecureRandom random = new SecureRandom();
    byte[] salt = new byte[saltLength];
    random.nextBytes(salt);

    /* Use this to derive the key from the password: */
    KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,
                iterationCount, keyLength);
    SecretKeyFactory keyFactory = SecretKeyFactory
                .getInstance(""PBKDF2WithHmacSHA1"");
    byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();",2
13438590,1,"    KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt,
                iterationCount, keyLength);
    SecretKeyFactory keyFactory = SecretKeyFactory
                .getInstance(""PBKDF2WithHmacSHA1"");
    byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();",2
13471160,0,"            SecretKeySpec key = new SecretKeySpec((secret).getBytes(""UTF-8""), ""HmacMD5"");
            Mac mac = Mac.getInstance(""HmacMD5"");
            mac.init(key);

            byte[] bytes = mac.doFinal(payload.getBytes(""UTF-8""));
",4
13511671,0,"        this.mac.Reset();
        this.mac.BlockUpdate(message, 0, message.Length);
        byte[] digest = new byte[this.mac.GetUnderlyingDigest().GetDigestSize()];
        this.mac.DoFinal(digest, 0);
",4
13511671,0,"        this.mac.Reset();
        this.mac.BlockUpdate(message, 0, message.Length);
        byte[] computed = new byte[this.mac.GetUnderlyingDigest().GetDigestSize()];
        this.mac.DoFinal(computed, 0);
",4
13523341,1,"    _data = _data.replace(',', '\n');
    CertificateFactory cf = CertificateFactory.getInstance(""X509"", ""BC"");

    // Read the Private Key
    KeyStore ks = KeyStore.getInstance(""PKCS12"", ""BC"");
    ks.load(new FileInputStream(_privateKeyPath), _keyPass.toCharArray());

    String keyAlias = null;
    Enumeration<String> aliases = ks.aliases();",3
13525299,0,"public class Encryption {

    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }


    private static byte[] getRawKey(byte[] seed) throws Exception {
        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }


    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }
    public static String fromHex(String hex) {
        return new String(toByte(hex));
    }

    public static byte[] toByte(String hexString) {
        int len = hexString.length()/2;
        byte[] result = new byte[len];
        for (int i = 0; i < len; i++)
            result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
        return result;
    }

    public static String toHex(byte[] buf) {
        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2*buf.length);
        for (int i = 0; i < buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }
    private final static String HEX = ""0123456789ABCDEF"";
    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));
    }


}",5
13525299,0,"    public static String encrypt(String seed, String cleartext) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        return toHex(result);
    }

    public static String decrypt(String seed, String encrypted) throws Exception {
        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] enc = toByte(encrypted);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

",2
13525299,0,"        KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        sr.setSeed(seed);
        kgen.init(128, sr); // 192 and 256 bits may not be available
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();",5
13526035,0,"            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < messageDigest.length; i++) {
                String h = Integer.toHexString(0xFF & messageDigest[i]);
                while (h.length() < 2)
                    h = ""0"" + h;
                hexString.append(h);
            }",4
13577933,1,"public class sample{
public String doLogin() throws ServletException, IOException {

    FacesContext context = FacesContext.getCurrentInstance();

        String springCheckUrl = this.buildSpringSecurityCheckUrl();

        HttpServletRequest request = (HttpServletRequest) context
                .getExternalContext().getRequest();

        RequestDispatcher dispatcher = request
                .getRequestDispatcher(springCheckUrl);

        dispatcher.forward((ServletRequest) request,
                (ServletResponse) context.getExternalContext.getResponse());

        context.responseComplete();

        return null;
    }

    private String buildSpringSecurityCheckUrl() {
        StringBuilder springCheckUrl = new StringBuilder(
                ""/j_spring_security_check"").append(""?"").append(""j_username"")
                .append(""="").append(this.userName.trim()).append(""&"")
                .append(""j_password"").append(""="")
                .append(this.userPassword.trim());
        return springCheckUrl.toString();
    }
}
",1
13612902,0,"    public TrippleDes() throws Exception {
        myEncryptionKey = ""ThisIsSpartaThisIsSparta"";
        myEncryptionScheme = DESEDE_ENCRYPTION_SCHEME;
        arrayBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
        ks = new DESedeKeySpec(arrayBytes);
        skf = SecretKeyFactory.getInstance(myEncryptionScheme);
        cipher = Cipher.getInstance(myEncryptionScheme);
        key = skf.generateSecret(ks);
    }


    public String encrypt(String unencryptedString) {
        String encryptedString = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            byte[] encryptedText = cipher.doFinal(plainText);
            encryptedString = new String(Base64.encodeBase64(encryptedText));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return encryptedString;
    }

",2
13612902,0,"            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            byte[] encryptedText = cipher.doFinal(plainText);
            encryptedString = new String(Base64.encodeBase64(encryptedText));",2
13688414,0,"    private byte[] generateSalt(int size) {
        byte[] salt = new byte[size];
        rand.nextBytes(salt);

        return salt;
    }

    private SecretKey generateKey(String algorithm, int keySize, byte[] salt)
            throws NoSuchProviderException, NoSuchAlgorithmException,
            InvalidKeySpecException {
        SecretKeyFactory factory = SecretKeyFactory.getInstance(KEY_ALGORITHM);
        PBEKeySpec pbeKeySpec = new PBEKeySpec(passwd.toCharArray(), salt,
                100000);
        SecretKey tmpKey = factory.generateSecret(pbeKeySpec);
        byte[] keyBytes = new byte[keySize / 8];
        System.arraycopy(tmpKey.getEncoded(), 0, keyBytes, 0, keyBytes.length);

        return new SecretKeySpec(keyBytes, algorithm);
    }

    private byte[] generateIV(Cipher cipher) {
        byte[] iv = new byte[cipher.getBlockSize()];
        rand.nextBytes(iv);

        return iv;
    }

    private byte[] appendArrays(byte[] firstArray, byte[] secondArray) {
        final byte[] result = new byte[firstArray.length + secondArray.length];

        System.arraycopy(firstArray, 0, result, 0, firstArray.length);
        System.arraycopy(secondArray, 0, result, firstArray.length,
                secondArray.length);

        return result;
    }

    public byte[] encrypt(String algorithm, int keySize, final byte[] message)
            throws Exception {
        Cipher cipher = Cipher.getInstance(algorithm + MODE_PADDING);

        // The salt size for the chosen algorithm is set to be equal
        // to the algorithm's block size (if it is a block algorithm).
        int saltSizeBytes = DEFAULT_SALT_SIZE_BYTES;
        int algorithmBlockSize = cipher.getBlockSize();
        if (algorithmBlockSize > 0) {
            saltSizeBytes = algorithmBlockSize;
        }

        // Create salt
        final byte[] salt = generateSalt(saltSizeBytes);

        SecretKey key = generateKey(algorithm, keySize, salt);

        // create a new IV for each encryption
        final IvParameterSpec ivParamSpec = new IvParameterSpec(
                generateIV(cipher));

        // Perform encryption using the Cipher
        cipher.init(Cipher.ENCRYPT_MODE, key, ivParamSpec);
        byte[] encryptedMessage = cipher.doFinal(message);

        // append the IV and salt
        encryptedMessage = appendArrays(ivParamSpec.getIV(), encryptedMessage);
        encryptedMessage = appendArrays(salt, encryptedMessage);

        return encryptedMessage;
    }
",2
13724091,0,"public static byte[] encrypt(byte[] ivBytes, byte[] keyBytes, byte[] mes) 
        throws NoSuchAlgorithmException,
        NoSuchPaddingException,
        InvalidKeyException,
        InvalidAlgorithmParameterException,
        IllegalBlockSizeException,
        BadPaddingException, IOException {

    AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
    SecretKeySpec newKey = new SecretKeySpec(keyBytes, ""AES"");
    Cipher cipher = null;
    cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
    return  cipher.doFinal(mes);
",2
13724091,0,"public static byte[] decrypt(byte[] ivBytes, byte[] keyBytes, byte[] bytes) 
        throws NoSuchAlgorithmException,
        NoSuchPaddingException,
        InvalidKeyException,
        InvalidAlgorithmParameterException,
        IllegalBlockSizeException,
        BadPaddingException, IOException, ClassNotFoundException {

    AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
    SecretKeySpec newKey = new SecretKeySpec(keyBytes, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
    return  cipher.doFinal(bytes);

}",2
13770749,1,"byte[] key = (Password+Username).getBytes(""UTF-8""); // depends on your implementation
MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
key = sha.digest(key);
key = Arrays.copyOf(key, 16); // AES uses 16 byte of key as a parameter (?)
",4
13779488,0,"public class sample{
protected org.apache.http.conn.ssl.SSLSocketFactory createAdditionalCertsSSLSocketFactory() {
try {
    final KeyStore ks = KeyStore.getInstance(""BKS"");

    // the bks file we generated above
    final InputStream in = context.getResources().openRawResource( R.raw.mystore);  
    try {
        // don't forget to put the password used above in strings.xml/mystore_password
        ks.load(in, context.getString( R.string.mystore_password ).toCharArray());
    } finally {
        in.close();
    }

    return new AdditionalKeyStoresSSLSocketFactory(ks);

} catch( Exception e ) {
    throw new RuntimeException(e);
}
}
",1
13812958,1,"public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
    return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
}

@Override
public Socket createSocket() throws IOException {
    return sslContext.getSocketFactory().createSocket();
}


",1
13925381,0,"public class sample{
public String doLogin() throws ServletException, IOException {

    FacesContext context = FacesContext.getCurrentInstance();

        String springCheckUrl = this.buildSpringSecurityCheckUrl();

        HttpServletRequest request = (HttpServletRequest) context
                .getExternalContext().getRequest();

        RequestDispatcher dispatcher = request
                .getRequestDispatcher(springCheckUrl);

        dispatcher.forward((ServletRequest) request,
                (ServletResponse) context.getExternalContext.getResponse());

        context.responseComplete();

        return null;
    }

    private String buildSpringSecurityCheckUrl() {
        StringBuilder springCheckUrl = new StringBuilder(
                ""/j_spring_security_check"").append(""?"").append(""j_username"")
                .append(""="").append(this.userName.trim()).append(""&"")
                .append(""j_password"").append(""="")
                .append(this.userPassword.trim());
        return springCheckUrl.toString();
    }
}
",1
13925635,4,"public class sample{
 public void foo(){
KeyStore localTrustStore = KeyStore.getInstance(""BKS"");
InputStream in = getResources().openRawResource(R.raw.mytruststore);
localTrustStore.load(in, TRUSTSTORE_PASSWORD.toCharArray());

SchemeRegistry schemeRegistry = new SchemeRegistry();
schemeRegistry.register(new Scheme(""http"", PlainSocketFactory
                .getSocketFactory(), 80));
SSLSocketFactory sslSocketFactory = new SSLSocketFactory(localTrustStore);
schemeRegistry.register(new Scheme(""https"", sslSocketFactory, 443));
HttpParams params = new BasicHttpParams();
ClientConnectionManager cm = 
    new ThreadSafeClientConnManager(params, schemeRegistry);

HttpClient client = new DefaultHttpClient(cm, params); 

}",1
13991540,2,"    while ((s = br.readLine()) != null) {
        sb.append(s);
    }
    br.close();
    reader.close();
    PublicKey publicKey = KeyFactory.getInstance(""RSA"").generatePublic(new X509EncodedKeySpec(new BASE64Decoder().decodeBuffer(sb.toString())));",3
13991540,2,"    while ((s = br.readLine()) != null) {
        sb.append(s);
    }
    br.close();
    reader.close();
    PrivateKey privateKey =  KeyFactory.getInstance(""RSA"").generatePrivate(new PKCS8EncodedKeySpec(new BASE64Decoder().decodeBuffer(sb.toString())));",3
14023167,1,"        byte[] iv = generateIv(cipher.getBlockSize());
        IvParameterSpec ivParams = new IvParameterSpec(iv);

        cipher.init(Cipher.ENCRYPT_MODE, key, ivParams);
        byte[] cipherText = cipher.doFinal(plaintext.getBytes(""UTF-8""));
",2
14042125,0,"public String encode(String password, String saltKey)
        throws NoSuchAlgorithmException, IOException {

    String encodedPassword = null;
    byte[] salt = base64ToByte(saltKey);

    MessageDigest digest = MessageDigest.getInstance(""SHA-512"");
    digest.reset();
    digest.update(salt);

    byte[] btPass = digest.digest(password.getBytes(""UTF-8""));
    for (int i = 0; i < ITERATION_COUNT; i++) {
        digest.reset();
        btPass = digest.digest(btPass);
    }

    encodedPassword = byteToBase64(btPass);
    return encodedPassword;
}
",4
14098236,0,"    byte[] dataBytes = new byte[1024];

    int nread = 0;
    while ((nread = fis.read(dataBytes)) != -1) {
        md.update(dataBytes, 0, nread);
    };
    byte[] mdbytes = md.digest();
    StringBuffer sb = new StringBuffer();",4
14098236,0,"    byte[] dataBytes = new byte[1024];

    int nread = 0;
    while ((nread = fis.read(dataBytes)) != -1) {
        md.update(dataBytes, 0, nread);
    };
    byte[] mdbytes = md.digest();
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < mdbytes.length; i++) {
        sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
    }
    System.out.println(""Digest(in hex format):: "" + sb.toString());",4
14113692,1,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""My Keyhash"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
14167313,0,"        System.out.println(""Loading RSA keys"");

        FileInputStream in = new FileInputStream(keyFile);
        DataInputStream dat = new DataInputStream(in);

        int len = dat.readInt();
        byte[] enc = new byte[len];
        dat.readFully(enc);",3
14167313,0,"        Cipher rsa = Cipher.getInstance(""RSA/ECB/OAEPWithSHA1AndMGF1Padding"");

        FileInputStream in = new FileInputStream(inFile);
        DataInputStream dat = new DataInputStream(in);

        // read RSA encrypted AES key
        int len = dat.readInt();
        byte[] buf = new byte[len];
        dat.readFully(buf);",3
14201817,0,"        byte[] digested = md.digest(passBytes);
        StringBuffer sb = new StringBuffer();
        for(int i=0;i<digested.length;i++){
            sb.append(Integer.toHexString(0xff & digested[i]));
        }",4
14201925,0,"        byte[] digested = md.digest(passBytes);
        StringBuffer sb = new StringBuffer();
        for(int i=0;i<digested.length;i++){
            sb.append(Integer.toHexString(0xff & digested[i]));
        }",4
14314783,0,"        AsymmetricBlockCipher eng = new RSAEngine();
        eng = new PKCS1Encoding(eng);
        RSAKeyParameters publicKey = new RSAKeyParameters(true, rsaPriv.getModulus(), rsaPriv.getPublicExponent());
        eng.init(true, publicKey);
",3
14314783,0,"        AsymmetricBlockCipher eng = new RSAEngine();
        eng = new PKCS1Encoding(eng);
        RSAKeyParameters privateKey = new RSAKeyParameters(true, rsaPriv.getModulus(), rsaPriv.getPrivateExponent());
        eng.init(false, privateKey);
",3
14355543,5,"            final byte[] keyBytes = HMAC_SHA1_KEY.getBytes();
            final SecretKeySpec signingKey = new SecretKeySpec(keyBytes,
                    ""HmacSHA1"");

            // Get an hmac_sha1 Mac instance and initialize with the signing key
            final Mac mac = Mac.getInstance(""HmacSHA1"");
            mac.init(signingKey);

            // Compute the hmac on input data bytes
            final byte[] rawHmac = mac.doFinal(dataToEncrypt.getBytes());
",4
14382231,1,"    PrivateKey privateKey = keyPairGenerator.genKeyPair().getPrivate();

    StringWriter writer = new StringWriter();

    try (PEMWriter pemWriter = new PEMWriter(writer)) {
      pemWriter.writeObject(privateKey);
    }

    String privateKeyStr = writer.toString();
    System.out.println(privateKeyStr);",3
14403580,0,"public class sample{
 public void foo(){
SSLSocket sslSocket = (SSLSocket) ((SSLSocketFactory) SSLSocketFactory.getDefault()).createSocket(
                       socket, 
                       socket.getInetAddress().getHostAddress(), 
                       socket.getPort(), 
                       true);
InputStream inputStream = sslSocket.getInputStream();
OutputStream outputStream = sslSocket.getOutputStream();
// reads from the socket
Scanner scanner = new Scanner(inputStream);
// writes to the socket
OutputStream outputStream = new BufferedOutputStream(outputStream);

}",1
14403842,1,"public class sample{
 public void foo(){
SSLSocket sslSocket = (SSLSocket) ((SSLSocketFactory) SSLSocketFactory.getDefault()).createSocket(
                       socket, 
                       socket.getInetAddress().getHostAddress(), 
                       socket.getPort(), 
                       true);
InputStream inputStream = sslSocket.getInputStream();
OutputStream outputStream = sslSocket.getOutputStream();
// reads from the socket
Scanner scanner = new Scanner(inputStream);
// writes to the socket
OutputStream outputStream = new BufferedOutputStream(outputStream);

}",1
14416324,1,"public class MyKeyManager extends X509ExtendedKeyManager {

KeyStore keystore = null;
String password = null;
public MyKeyManager(KeyStore keystore, String password) {
        this.keystore = keystore;
        this.password = password;
}

@Override
public String chooseClientAlias(String[] arg0, Principal[] arg1, Socket arg2) {
    return """";//can't be null
}

@Override
public String chooseServerAlias(String arg0, Principal[] arg1, Socket arg2) {
    return null;
}

@Override
public X509Certificate[] getCertificateChain(String arg0) {
    try {
        X509Certificate[] result = new X509Certificate[keystore.getCertificateChain(keystore.aliases().nextElement()).length];
        for (int i=0; i < result.length; i++){
            result[i] = (X509Certificate) keystore.getCertificateChain(keystore.aliases().nextElement())[i];
        }
        return result ;
    } catch (Exception e) {
    }
    return null;
}

@Override
public String[] getClientAliases(String arg0, Principal[] arg1) {
    try {
        return new String[] { keystore.aliases().nextElement() };
    } catch (Exception e) {
        return null;
    }
}

@Override
public PrivateKey getPrivateKey(String arg0) {
    try {
        return ((KeyStore.PrivateKeyEntry) keystore.getEntry(keystore.aliases().nextElement(),
                new KeyStore.PasswordProtection(password.toCharArray()))).getPrivateKey();
    } catch (Exception e) {
    }
    return null;
}

@Override
public String[] getServerAliases(String arg0, Principal[] arg1) {
    return null;
}

}",1
14427017,0,"        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
        byte[] encryptedText = cipher.doFinal(plainText);
        encryptedString = new String(Base64.encodeBase64(encryptedText));
",2
14545326,0,"public class sample{
 public void foo(){
    BASE64Encoder encoder = new BASE64Encoder();
    out.println(X509Factory.BEGIN_CERT);
    encoder.encodeBuffer(cert.getEncoded(), out);
    out.println(X509Factory.END_CERT);

}",-1
14582408,2,"public class sample{
    /**
     * Encode PublicKey (DSA or RSA encoded) to authorized_keys like string
     *
     * @param publicKey DSA or RSA encoded
     * @param user username for output authorized_keys like string
     * @return authorized_keys like string
     * @throws IOException
     */
    public static String encodePublicKey(PublicKey publicKey, String user)
            throws IOException {
        String publicKeyEncoded;
        if(publicKey.getAlgorithm().equals(""RSA"")){
            RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
            ByteArrayOutputStream byteOs = new ByteArrayOutputStream();
            DataOutputStream dos = new DataOutputStream(byteOs);
            dos.writeInt(""ssh-rsa"".getBytes().length);
            dos.write(""ssh-rsa"".getBytes());
            dos.writeInt(rsaPublicKey.getPublicExponent().toByteArray().length);
            dos.write(rsaPublicKey.getPublicExponent().toByteArray());
            dos.writeInt(rsaPublicKey.getModulus().toByteArray().length);
            dos.write(rsaPublicKey.getModulus().toByteArray());
            publicKeyEncoded = new String(
                    Base64.encodeBase64(byteOs.toByteArray()));
            return ""ssh-rsa "" + publicKeyEncoded + "" "" + user;
        }
        else if(publicKey.getAlgorithm().equals(""DSA"")){
            DSAPublicKey dsaPublicKey = (DSAPublicKey) publicKey;
            DSAParams dsaParams = dsaPublicKey.getParams();

            ByteArrayOutputStream byteOs = new ByteArrayOutputStream();
            DataOutputStream dos = new DataOutputStream(byteOs);
            dos.writeInt(""ssh-dss"".getBytes().length);
            dos.write(""ssh-dss"".getBytes());
            dos.writeInt(dsaParams.getP().toByteArray().length);
            dos.write(dsaParams.getP().toByteArray());
            dos.writeInt(dsaParams.getQ().toByteArray().length);
            dos.write(dsaParams.getQ().toByteArray());
            dos.writeInt(dsaParams.getG().toByteArray().length);
            dos.write(dsaParams.getG().toByteArray());
            dos.writeInt(dsaPublicKey.getY().toByteArray().length);
            dos.write(dsaPublicKey.getY().toByteArray());
            publicKeyEncoded = new String(
                    Base64.encodeBase64(byteOs.toByteArray()));
            return ""ssh-dss "" + publicKeyEncoded + "" "" + user;
        }
        else{
            throw new IllegalArgumentException(
                    ""Unknown public key encoding: "" + publicKey.getAlgorithm());
        }
    }
",3
14582408,2,"            dos.writeInt(rsaPublicKey.getModulus().toByteArray().length);
            dos.write(rsaPublicKey.getModulus().toByteArray());
            publicKeyEncoded = new String(
                    Base64.encodeBase64(byteOs.toByteArray()));
            return ""ssh-rsa "" + publicKeyEncoded + "" "" + user;",3
14582408,2,"            dos.writeInt(dsaPublicKey.getY().toByteArray().length);
            dos.write(dsaPublicKey.getY().toByteArray());
            publicKeyEncoded = new String(
                    Base64.encodeBase64(byteOs.toByteArray()));
            return ""ssh-dss "" + publicKeyEncoded + "" "" + user;",3
14845785,2,"Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
int blockSize = cipher.getBlockSize();

byte[] inputBytes = data.getBytes();
int byteLength = inputBytes.length;
if (byteLength % blockSize != 0) {
    byteLength = byteLength + (blockSize - (byteLength % blockSize));
}

byte[] paddedBytes = new byte[byteLength];

System.arraycopy(inputBytes, 0, paddedBytes, 0, inputBytes.length);
",2
14845785,2,"byte[] paddedBytes = new byte[byteLength];

System.arraycopy(inputBytes, 0, paddedBytes, 0, inputBytes.length);

cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
byte[] results = cipher.doFinal(paddedBytes);
",2
14922107,0,"Key key = new SecretKeySpec(keyByte, ""AES"");
IvParameterSpec iv = new IvParameterSpec(ivByte);
Cipher c = Cipher.getInstance(""AES/CBC/NoPadding"");
c.init(Cipher.DECRYPT_MODE, key, iv);",2
14957365,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""Your Tag"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
14979026,0,"try 
        {
            KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
            if (ks != null) 
            {
                ks.load(null, null);
                Enumeration aliases = ks.aliases();
                while (aliases.hasMoreElements()) 
                {
                    String alias = (String) aliases.nextElement();
                    java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);

                    if (cert.getIssuerDN().getName().contains(""MyCert"")) 
                    {
                        isCertExist = true;
                        break;
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (KeyStoreException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (java.security.cert.CertificateException e) {
            e.printStackTrace();
        }
",1
15050475,0,"    public EncryptDecrypt() throws Exception {
        myEncryptionKey = ""ThisIsSpartaThisIsSparta"";
        myEncryptionScheme = DESEDE_ENCRYPTION_SCHEME;
        arrayBytes = myEncryptionKey.getBytes(UNICODE_FORMAT);
        ks = new DESedeKeySpec(arrayBytes);
        skf = SecretKeyFactory.getInstance(myEncryptionScheme);
        cipher = Cipher.getInstance(myEncryptionScheme);
        key = skf.generateSecret(ks);
    }


    public String encrypt(String unencryptedString) {
        String encryptedString = null;
        try {
            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            byte[] encryptedText = cipher.doFinal(plainText);
            encryptedString = new String(Base64.encodeBase64(encryptedText));
        } catch (Exception e) {
            e.printStackTrace();
        }
        return encryptedString;
    }

",2
15050475,0,"            cipher.init(Cipher.ENCRYPT_MODE, key);
            byte[] plainText = unencryptedString.getBytes(UNICODE_FORMAT);
            byte[] encryptedText = cipher.doFinal(plainText);
            encryptedString = new String(Base64.encodeBase64(encryptedText));",2
15157327,1,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
15254815,4,"byte [] buffer = new byte[1024];
int count = 0;

while ( (count = fin.read(buffer)) != -1 ) {
    baos.write(buffer, 0, count);
}

byte [] fileContent = baos.toByteArray();

//all chars in encoded are guaranteed to be 7-bit ASCII",4
15279642,0,"        {
            ivspec = new IvParameterSpec(iv.getBytes());

            keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

            try {
                cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
            } catch (NoSuchAlgorithmException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (NoSuchPaddingException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }

        public byte[] encrypt(String text) throws Exception
        {
            if(text == null || text.length() == 0)
                throw new Exception(""Empty string"");

            byte[] encrypted = null;

            try {
                cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

                encrypted = cipher.doFinal(padString(text).getBytes());
            } catch (Exception e)
            {           
                throw new Exception(""[encrypt] "" + e.getMessage());
            }

            return encrypted;
        }
",2
15279642,0,"            keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

            try {
                cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
            } catch (NoSuchAlgorithmException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            } catch (NoSuchPaddingException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }",2
15279642,0,"            if(text == null || text.length() == 0)
                throw new Exception(""Empty string"");

            byte[] encrypted = null;

            try {
                cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

                encrypted = cipher.doFinal(padString(text).getBytes());
            } catch (Exception e)",2
15279642,0,"            byte[] encrypted = null;

            try {
                cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

                encrypted = cipher.doFinal(padString(text).getBytes());
            } catch (Exception e)
            {           
                throw new Exception(""[encrypt] "" + e.getMessage());
            }

            return encrypted;",2
15303291,0,"public class sample{
 public void foo(){
PKCS5S2ParametersGenerator generator = new PKCS5S2ParametersGenerator(new SHA256Digest());
generator.init(PBEParametersGenerator.PKCS5PasswordToUTF8Bytes(password), salt, iterations);
KeyParameter key = (KeyParameter)generator.generateDerivedMacParameters(keySizeInBits);

}",2
15339499,1,"public class MyKeyManager extends X509ExtendedKeyManager {

    KeyStore keystore = null;
    String password = null;
    public MyKeyManager(KeyStore keystore, String password) {
        this.keystore = keystore;
        this.password = password;
    }

    @Override
    public String chooseClientAlias(String[] arg0, Principal[] arg1, Socket arg2) {
        return """"; // can't be null
    }

    @Override
    public String chooseServerAlias(String arg0, Principal[] arg1, Socket arg2) {
        return null;
    }

    @Override
    public X509Certificate[] getCertificateChain(String arg0) {
        try {
            X509Certificate[] result = new X509Certificate[keystore.getCertificateChain(keystore.aliases().nextElement()).length];
            for (int i = 0; i < result.length; i++){
                result[i] = (X509Certificate) keystore.getCertificateChain(keystore.aliases().nextElement())[i];
            }
            return result;
        } catch (Exception e) {
        }
        return null;
    }

    @Override
    public String[] getClientAliases(String arg0, Principal[] arg1) {
        try {
            return new String[] { keystore.aliases().nextElement() };
        } catch (Exception e) {
            return null;
        }
    }

    @Override
    public PrivateKey getPrivateKey(String arg0) {
        try {
            return ((KeyStore.PrivateKeyEntry) keystore.getEntry(keystore.aliases().nextElement(),
                new KeyStore.PasswordProtection(password.toCharArray()))).getPrivateKey();
        } catch (Exception e) {
        }
        return null;
    }

    @Override
    public String[] getServerAliases(String arg0, Principal[] arg1) {
        return null;
    }
}",1
15357387,2,"        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        }",2
15373186,0,"    X509Certificate[] chain = tm.chain;
    if (chain == null) {
        System.out.println(""Could not obtain server certificate chain"");
        return;
    }

    BufferedReader reader =
            new BufferedReader(new InputStreamReader(System.in));

    System.out.println();
    System.out.println(""Server sent "" + chain.length + "" certificate(s):"");
    System.out.println();
    MessageDigest sha1 = MessageDigest.getInstance(""SHA1"");
    MessageDigest md5 = MessageDigest.getInstance(""MD5"");
    for (int i = 0; i < chain.length; i++) {
        X509Certificate cert = chain[i];
        System.out.println
                ("" "" + (i + 1) + "" Subject "" + cert.getSubjectDN());
        System.out.println(""   Issuer  "" + cert.getIssuerDN());
        sha1.update(cert.getEncoded());
        System.out.println(""   sha1    "" + toHexString(sha1.digest()));
        md5.update(cert.getEncoded());
        System.out.println(""   md5     "" + toHexString(md5.digest()));
        System.out.println();
    }

    System.out.println(""Enter certificate to add to trusted keystore or 'q' to quit: [1]"");
    String line = reader.readLine().trim();
    int k;
    try {
        k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;
    } catch (NumberFormatException e) {
        System.out.println(""KeyStore not changed"");
        return;
    }

    X509Certificate cert = chain[k];
    String alias = host + ""-"" + (k + 1);
    ks.setCertificateEntry(alias, cert);
",4
15373186,0,"    private static String toHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 3);
        for (int b : bytes) {
            b &= 0xff;
            sb.append(HEXDIGITS[b >> 4]);
            sb.append(HEXDIGITS[b & 15]);
            sb.append(' ');
        }
        return sb.toString();
    }

private static class SavingTrustManager implements X509TrustManager {

        private final X509TrustManager tm;
        private X509Certificate[] chain;

        SavingTrustManager(X509TrustManager tm) {
            this.tm = tm;
        }

        public X509Certificate[] getAcceptedIssuers() {
            throw new UnsupportedOperationException();
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }
    }",1
15373186,0,"        public void checkClientTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }",1
15391490,0,"public static PublicKey bigIntegerToPublicKey(BigInteger e, BigInteger m)  {
    RSAPublicKeySpec keySpec = new RSAPublicKeySpec(m, e);
    KeyFactory fact = KeyFactory.getInstance(""RSA"");
    PublicKey pubKey = fact.generatePublic(keySpec);
    return pubKey;
}
",3
15391490,0,"public static PrivateKey bigIntegerToPrivateKey(BigInteger e, BigInteger m) {
    RSAPrivateKeySpec keySpec = new RSAPrivateKeySpec(m, e);
    KeyFactory fact = KeyFactory.getInstance(""RSA"");
    PrivateKey privKey = fact.generatePrivate(keySpec);
    return privKey;
}
",3
15427868,0,"    KeyFactory kf = KeyFactory.getInstance(""RSA"");
    PublicKey pkPublic = kf.generatePublic(publicKeySpec);

    Cipher pkCipher = Cipher.getInstance(""RSA/ECB/PKCS1PADDING"");
    pkCipher.init(Cipher.DECRYPT_MODE, pkPublic);
",3
15427868,0,"    Cipher pkCipher = Cipher.getInstance(""RSA/ECB/PKCS1PADDING"");
    pkCipher.init(Cipher.DECRYPT_MODE, pkPublic);

    byte[] decoded = Base64Coder.decode(encrypted);
    byte[] decryptedInByte = pkCipher.doFinal(decoded);",3
15497236,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""YOURHASH KEY:"",
                    Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
15497320,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""YOURHASH KEY:"",
                    Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
15659842,0,"            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null) {
                for (TrustManager tm : tms) {
                    if (tm instanceof X509TrustManager) {
                        localTrustManager = (X509TrustManager)tm;
                        break;
                    }
                }
            }",1
15659842,0,"            tmf.init(keyStore);
            TrustManager[] tms = tmf.getTrustManagers();
            if (tms != null) {
                for (TrustManager tm : tms) {
                    if (tm instanceof X509TrustManager) {
                        localTrustManager = (X509TrustManager) tm;
                        break;
                    }
                }
            }",1
15660170,0,"            Cipher cipher               = Cipher.getInstance(""RSA/None/OAEPWithSHA1AndMGF1Padding"", ""BC"");
            cipher.init(Cipher.DECRYPT_MODE, privateKey);


            byte[] plainText            = cipher.doFinal(decodedStr);

            System.out.println(""         Message: "" + new String(plainText));",3
15669908,0,"        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        md.update(password.getBytes());
        byte[] byteData = md.digest();
        // byte[] byteData = md.digest(password.getBytes());    // both updates and completes the hash computation

        // Method 1 of converting bytes to hex format
        StringBuffer sb = new StringBuffer();",4
15755512,4,"    public static KeyStore getKeyStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {
        URL keyStoreUrl = CxfClientSslTest.class.getResource(""/certs/client.jks"");
        File keystoreFile = new File(keyStoreUrl.getPath());
        if (!keystoreFile.exists()) {
            throw new RuntimeException(""keystore doesn't exists: "" + keystoreFile.getAbsolutePath());
        }

        KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
        InputStream keystoreInput = new FileInputStream(keystoreFile.getAbsolutePath());
        keystore.load(keystoreInput, ""changeit"".toCharArray());
        keystoreInput.close();
        return keystore;
    }
",1
15755512,4,"    public static KeyStore getTrustStore() throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {
        URL trustStoreUrl = CxfClientSslTest.class.getResource(""/certs/client-trust.jks"");
        File trustStoreFile = new File(trustStoreUrl.getPath());
        if (!trustStoreFile.exists()) {
            throw new RuntimeException(""truststore doesn't exists: "" + trustStoreFile.getAbsolutePath());
        }

        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        InputStream trustStoreInput = new FileInputStream(trustStoreFile.getAbsolutePath());
        trustStore.load(trustStoreInput, ""changeit"".toCharArray());
        trustStoreInput.close();
        return trustStore;
    }",1
15843381,2,"public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
    return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
}

@Override
public Socket createSocket() throws IOException {
    return sslContext.getSocketFactory().createSocket();
}
",1
15878972,1,"public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
    return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
}

@Override
public Socket createSocket() throws IOException {
    return sslContext.getSocketFactory().createSocket();
}
",1
15954508,0,"public static byte[] encryptMsg(String message, SecretKey secret) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException {
/* Encrypt the message. */
    Cipher cipher = null;
    cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    byte[] cipherText = cipher.doFinal(message.getBytes(""UTF-8""));
    return cipherText;
}

public static String decryptMsg(byte[] cipherText, SecretKey secret) throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidParameterSpecException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException {

    /* Decrypt the message, given derived encContentValues and initialization vector. */
    Cipher cipher = null;
    cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
   cipher.init(Cipher.DECRYPT_MODE, secret);
    String decryptString = new String(cipher.doFinal(cipherText), ""UTF-8"");
    return decryptString;
}
",2
16032897,3,"    byte messageDigest[] = digest.digest();

    // Create Hex String
    StringBuffer hexString = new StringBuffer();
    for (int i = 0; i < messageDigest.length; i++) {
        String h = Integer.toHexString(0xFF & messageDigest[i]);
        while (h.length() < 2)
            h = ""0"" + h;
        hexString.append(h);
    }",4
16099061,1,"public class sample{
 public void foo(){
File pubKeyFile = new File(""keys/serverPublicKey.der"");
byte[] buffer = new byte[(int) pubKeyFile.length()];

DataInputStream in = new DataInputStream(new FileInputStream(pubKeyFile));
in.readFully(buffer);
in.close();

KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
RSAPublicKey publicKey = (RSAPublicKey) keyFactory.generatePublic(new X509EncodedKeySpec(buffer));

}",3
16099061,4,"public class sample{
 public void foo(){
File privKeyFile = new File(""keys/clientPrivateKey.der"");
byte[] buffer = new byte[(int) privKeyFile.length()];

DataInputStream in = new DataInputStream(new FileInputStream(privKeyFile));
in.readFully(buffer);
in.close();

KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
RSAPrivateKey privateKey = (RSAPrivateKey) keyFactory.generatePrivate(new PKCS8EncodedKeySpec(buffer));

}",3
16125545,1,"protected static String convertToPem(X509Certificate cert) throws CertificateEncodingException {
 Base64 encoder = new Base64(64);
 String cert_begin = ""-----BEGIN CERTIFICATE-----\n"";
 String end_cert = ""-----END CERTIFICATE-----"";

 byte[] derCert = x509cert.getEncoded();
 String pemCertPre = new String(encoder.encode(derCert));
 String pemCert = cert_begin + pemCertPre + end_cert;
 return pemCert;",3
16229909,0,"  public @Nullable String[] getClientAliases(String keyType, Principal[] issuers) {
    ImmutableList.Builder aliases = ImmutableList.builder();
    for (X509KeyManager keyManager : keyManagers) {
      aliases.add(keyManager.getClientAliases(keyType, issuers));
    }
    return emptyToNull(Iterables.toArray(aliases.build(), String.class));
  }

  /**
   * Get all matching aliases for authenticating the server side of a
   * secure socket, or {@code null} if there are no matches.
   */
  @Override",1
16229909,0,"  public @Nullable String[] getServerAliases(String keyType, Principal[] issuers) {
    ImmutableList.Builder aliases = ImmutableList.builder();
    for (X509KeyManager keyManager : keyManagers) {
      aliases.add(keyManager.getServerAliases(keyType, issuers));
    }
    return emptyToNull(Iterables.toArray(aliases.build(), String.class));
  }

  @Nullable",1
16229909,1,"  public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
    for (X509TrustManager trustManager : trustManagers) {
      try {
        trustManager.checkClientTrusted(chain, authType);
        return; // someone trusts them. success!
      } catch (CertificateException e) {
        // maybe someone else will trust them
      }
    }
    throw new CertificateException(""None of the TrustManagers trust this certificate chain"");
  }

  @Override",1
16229909,1,"  public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
    for (X509TrustManager trustManager : trustManagers) {
      try {
        trustManager.checkServerTrusted(chain, authType);
        return; // someone trusts them. success!
      } catch (CertificateException e) {
        // maybe someone else will trust them
      }
    }
    throw new CertificateException(""None of the TrustManagers trust this certificate chain"");
  }

  @Override",1
16231742,0,"Key key = new SecretKeySpec(secret.getBytes(), ALGORITHM);

// Encrypt
Cipher cipher = Cipher.getInstance(ALGORITHM);
cipher.init(Cipher.ENCRYPT_MODE, key);
byte[] encryptedData = cipher.doFinal(plainText);

// Decrypt",2
16237370,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
16269621,7,"KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, IT, KEY_LENGTH);
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();",2
16298636,0,"KeyGenerator kg = KeyGenerator.getInstance(""AES"");
c.init(Cipher.ENCRYPT_MODE, kg.generateKey());
System.out.println(c.update(new byte[1]).length);  // output: 1
System.out.println(c.update(new byte[20]).length); // output: 20
",2
16308314,1,"KeyGenerator kg = KeyGenerator.getInstance(""AES"");
c.init(Cipher.ENCRYPT_MODE, kg.generateKey());
System.out.println(c.update(new byte[1]).length);  // output: 1
System.out.println(c.update(new byte[20]).length); // output: 20
",2
16308314,2,"KeyGenerator kg = KeyGenerator.getInstance(""AES"");
c.init(Cipher.ENCRYPT_MODE, kg.generateKey());
System.out.println(c.update(new byte[20]).length); // output: 16
System.out.println(c.update(new byte[1]).length);  // null pointer exception
",2
16323820,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();",4
16323820,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < mdbytes.length; i++) {
          sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
        }

        System.out.println(""Hex format : "" + sb.toString());

       //convert the byte to hex format method 2",4
16323820,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < mdbytes.length; i++) {
          sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
        }

        System.out.println(""Hex format : "" + sb.toString());

       //convert the byte to hex format method 2
        StringBuffer hexString = new StringBuffer();",4
16357822,0,"public class ExportPrivateKey {
    private File keystoreFile;
    private String keyStoreType;
    private char[] password;
    private String alias;
    private File exportedFile;

    public static KeyPair getPrivateKey(KeyStore keystore, String alias, char[] password) {
        try {
            Key key=keystore.getKey(alias,password);
            if(key instanceof PrivateKey) {
                Certificate cert=keystore.getCertificate(alias);
                PublicKey publicKey=cert.getPublicKey();
                return new KeyPair(publicKey,(PrivateKey)key);
            }
        } catch (UnrecoverableKeyException e) {
        } catch (NoSuchAlgorithmException e) {
        } catch (KeyStoreException e) { }
        return null;
    }

    public void export() throws Exception{
        KeyStore keystore=KeyStore.getInstance(keyStoreType);
        BASE64Encoder encoder=new BASE64Encoder();
        keystore.load(new FileInputStream(keystoreFile),password);
        KeyPair keyPair=getPrivateKey(keystore,alias,password);
        PrivateKey privateKey=keyPair.getPrivate();
        String encoded=encoder.encode(privateKey.getEncoded());
        FileWriter fw=new FileWriter(exportedFile);
        fw.write(“—–BEGIN PRIVATE KEY—–\n“);
        fw.write(encoded);
        fw.write(“\n“);
        fw.write(“—–END PRIVATE KEY—–”);
        fw.close();
    }

    public static void main(String args[]) throws Exception{
        ExportPrivateKey export=new ExportPrivateKey();
        export.keystoreFile=new File(args[0]);
        export.keyStoreType=args[1];
        export.password=args[2].toCharArray();
        export.alias=args[3];
        export.exportedFile=new File(args[4]);
        export.export();
    }
}",3
16508187,0,"    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

    if ((localAddress != null) || (localPort > 0)) {
        // we need to bind explicitly
        if (localPort < 0) {
            localPort = 0; // indicates ""any""
        }
        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);
        sslsock.bind(isa);
    }
",1
16508187,0,"public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException,
        UnknownHostException {
    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
}

// -------------------------------------------------------------------
// javadoc in org.apache.http.conn.scheme.SocketFactory says :
// Both Object.equals() and Object.hashCode() must be overridden
// for the correct operation of some connection managers
// -------------------------------------------------------------------

public boolean equals(Object obj) {
    return ((obj != null) && obj.getClass().equals(EasySSLSocketFactory.class));
}

public int hashCode() {
    return EasySSLSocketFactory.class.hashCode();
}",1
16508187,1,"public class EasyX509TrustManager implements X509TrustManager {

private X509TrustManager standardTrustManager = null;

/**
 * Constructor for EasyX509TrustManager.
 */
public EasyX509TrustManager(KeyStore keystore) throws NoSuchAlgorithmException, KeyStoreException {
    super();
    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keystore);
    TrustManager[] trustmanagers = factory.getTrustManagers();
    if (trustmanagers.length == 0) {
        throw new NoSuchAlgorithmException(""no trust manager found"");
    }
    this.standardTrustManager = (X509TrustManager) trustmanagers[0];
}

/**
 * @see javax.net.ssl.X509TrustManager#checkClientTrusted(X509Certificate[],String authType)
 */
public void checkClientTrusted(X509Certificate[] certificates, String authType) throws CertificateException {
    standardTrustManager.checkClientTrusted(certificates, authType);
}

/**
 * @see javax.net.ssl.X509TrustManager#checkServerTrusted(X509Certificate[],String authType)
 */
public void checkServerTrusted(X509Certificate[] certificates, String authType) throws CertificateException {
    if ((certificates != null) && (certificates.length == 1)) {
        certificates[0].checkValidity();
    } else {
        standardTrustManager.checkServerTrusted(certificates, authType);
    }
}

/**
 * @see javax.net.ssl.X509TrustManager#getAcceptedIssuers()
 */
public X509Certificate[] getAcceptedIssuers() {
    return this.standardTrustManager.getAcceptedIssuers();
}
}",1
16508187,1,"    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keystore);
    TrustManager[] trustmanagers = factory.getTrustManagers();
    if (trustmanagers.length == 0) {
        throw new NoSuchAlgorithmException(""no trust manager found"");
    }
    this.standardTrustManager = (X509TrustManager) trustmanagers[0];",1
16519302,0,"SecretKeySpec keySpec = new SecretKeySpec(""secretkey"".getBytes(), ""HmacMD5"");
Mac mac = Mac.getInstance(""HmacMD5"");
mac.init(keySpec);
byte[] hashBytes = mac.doFinal(""text2crypt"".getBytes());",4
16522149,0,"public class sample{
 public void foo(){
String keyStorePath = ""absolute path to your JKS keystore file"";
String keyStorePass = ""keystore password"";

System.setProperty(""javax.net.ssl.keyStore"", keyStorePath);
System.setProperty(""javax.net.ssl.keyStorePassword"", keyStorePass);

SSLServerSocketFactory sslserversocketfactory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
SSLServerSocket serverSocket = (SSLServerSocket) sslserversocketfactory.createServerSocket(port_number);

while (true) {
    new ClientThread((SSLSocket) serverSocket.accept()).start();
}

}",-1
16548981,8,"final CipherOutputStream output = new CipherOutputStream(fos, cipher);

int bytesRead = 0;
final byte[] plainText = new byte[4096];
while ((bytesRead = fis.read(plainText)) >= 0) {
    output.write(plainText, 0, bytesRead);
}
output.flush();
output.close();
fos.close();
fis.close();
final byte[] iv = cipher.getIV();

// decrypt the file
cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));",2
16566482,0,"    commandData = commandData.replace(',', '\n');
    CertificateFactory cf = CertificateFactory.getInstance(""X509"", ""BC"");

    // Read the Private Key
    KeyStore ks = KeyStore.getInstance(""PKCS12"", ""BC"");
    ks.load(new FileInputStream(keystorePath), keystorePassword.toCharArray());

    String keyAlias = null;
    Enumeration<String> aliases = ks.aliases();",3
16575101,0,"        sGen.init(PGPSignature.BINARY_DOCUMENT, pgpPrivKey);
        Iterator it = pgpSec.getPublicKey().getUserIDs();
        if (it.hasNext()) {
            PGPSignatureSubpacketGenerator spGen = new PGPSignatureSubpacketGenerator();
            spGen.setSignerUserID(false, (String) it.next());
            sGen.setHashedSubpackets(spGen.generate());
        }
        //BCPGOutputStream bOut = new BCPGOutputStream(compressedData);",4
16575101,1,"    in = PGPUtil.getDecoderStream(in);

    PGPObjectFactory pgpF = new PGPObjectFactory(in);
    PGPEncryptedDataList enc;

    Object o = pgpF.nextObject();
    //
    // the first object might be a PGP marker packet.
    //
    if (o instanceof PGPEncryptedDataList) {
        enc = (PGPEncryptedDataList) o;
    } else {
        enc = (PGPEncryptedDataList) pgpF.nextObject();
    }

    //
    // find the secret key
    //",4
16575101,1,"    in = PGPUtil.getDecoderStream(in);

    PGPObjectFactory pgpF = new PGPObjectFactory(in);
    PGPEncryptedDataList enc;

    Object o = pgpF.nextObject();
    //
    // the first object might be a PGP marker packet.
    //
    if (o instanceof PGPEncryptedDataList) {
        enc = (PGPEncryptedDataList) o;
    } else {
        enc = (PGPEncryptedDataList) pgpF.nextObject();
    }

    //
    // find the secret key
    //
    Iterator<?> it = enc.getEncryptedDataObjects();
    PGPPrivateKey sKey = null;
    PGPPublicKeyEncryptedData pbe = null;",4
16575101,1,"    Object o = pgpF.nextObject();
    //
    // the first object might be a PGP marker packet.
    //
    if (o instanceof PGPEncryptedDataList) {
        enc = (PGPEncryptedDataList) o;
    } else {
        enc = (PGPEncryptedDataList) pgpF.nextObject();
    }

    //
    // find the secret key
    //
    Iterator<?> it = enc.getEncryptedDataObjects();
    PGPPrivateKey sKey = null;
    PGPPublicKeyEncryptedData pbe = null;
    PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(PGPUtil.getDecoderStream(keyIn));
",4
16575101,1,"    if (o instanceof PGPEncryptedDataList) {
        enc = (PGPEncryptedDataList) o;
    } else {
        enc = (PGPEncryptedDataList) pgpF.nextObject();
    }

    //
    // find the secret key
    //
    Iterator<?> it = enc.getEncryptedDataObjects();
    PGPPrivateKey sKey = null;
    PGPPublicKeyEncryptedData pbe = null;",4
16575101,1,"    message = plainFact.nextObject();
    ByteArrayOutputStream actualOutput = new ByteArrayOutputStream();

    while (message != null) {
        log.trace(message.toString());
        if (message instanceof PGPCompressedData) {
            compressedData = (PGPCompressedData) message;
            plainFact = new PGPObjectFactory(compressedData.getDataStream());
            message = plainFact.nextObject();
        }

        if (message instanceof PGPLiteralData) {
            // have to read it and keep it somewhere.
            Streams.pipeAll(((PGPLiteralData) message).getInputStream(), actualOutput);
        } else if (message instanceof PGPOnePassSignatureList) {
            onePassSignatureList = (PGPOnePassSignatureList) message;
        } else if (message instanceof PGPSignatureList) {
            signatureList = (PGPSignatureList) message;
        } else {
            throw new PGPException(""message unknown message type."");
        }
        message = plainFact.nextObject();
    }
    actualOutput.close();
    PGPPublicKey publicKey = null;
    byte[] output = actualOutput.toByteArray();
    if (onePassSignatureList == null || signatureList == null) {
        throw new PGPException(""Poor PGP. Signatures not found."");
    } else {

        for (int i = 0; i < onePassSignatureList.size(); i++) {
            PGPOnePassSignature ops = onePassSignatureList.get(0);
            log.trace(""verifier : "" + ops.getKeyID());
            PGPPublicKeyRingCollection pgpRing = new PGPPublicKeyRingCollection(
                    PGPUtil.getDecoderStream(publicKeyIn));
            publicKey = pgpRing.getPublicKey(ops.getKeyID());
            if (publicKey != null) {
                ops.init(new JcaPGPContentVerifierBuilderProvider().setProvider(""BC""), publicKey);
                ops.update(output);
                PGPSignature signature = signatureList.get(i);",4
16575101,1,"    if (pbe.isIntegrityProtected() && !pbe.verify()) {
        throw new PGPException(""Data is integrity protected but integrity is lost."");
    } else if (publicKey == null) {
        throw new SignatureException(""Signature not found"");
    } else {
        fOut.write(output);
        fOut.flush();
        fOut.close();
    }",4
16596992,1,"public class sample{
 public void foo(){
Cipher c = Cipher.getInstance(""AESWrap"", ""SunJCE"");
c.init(Cipher.WRAP_MODE, secretKey);
byte[] result = c.wrap(someKey);

}",2
16714084,0,"private static String[] setupPreferredDefaultCipherSuites(SSLSocketFactory sslSocketFactory) {

    String[] defaultCipherSuites = sslSocketFactory.getDefaultCipherSuites();

    ArrayList<String> suitesList = new ArrayList<String>(Arrays.asList(defaultCipherSuites));
    suitesList.remove(PREFERRED_CIPHER_SUITE);
    suitesList.add(0, PREFERRED_CIPHER_SUITE);

    return suitesList.toArray(new String[suitesList.size()]);
}
",1
16714084,0,"private static String[] setupPreferredSupportedCipherSuites(SSLSocketFactory sslSocketFactory) {

    String[] supportedCipherSuites = sslSocketFactory.getSupportedCipherSuites();

    ArrayList<String> suitesList = new ArrayList<String>(Arrays.asList(supportedCipherSuites));
    suitesList.remove(PREFERRED_CIPHER_SUITE);
    suitesList.add(0, PREFERRED_CIPHER_SUITE);

    return suitesList.toArray(new String[suitesList.size()]);
}",1
16734015,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
16759793,0,"    public Socket createSocket(Socket socket, String host, int port,
            boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port,
                autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
16854800,0,"  public AESCrypt(String password) throws Exception
  {
    // hash password with SHA-256 and crop the output to 128-bit for key
    MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
    digest.update(password.getBytes(""UTF-8""));
    byte[] keyBytes = new byte[32];
    System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);

    cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    key = new SecretKeySpec(keyBytes, ""AES"");
    spec = getIV();
  }       

  public AlgorithmParameterSpec getIV()
  {
    byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
    IvParameterSpec ivParameterSpec;
    ivParameterSpec = new IvParameterSpec(iv);

    return ivParameterSpec;
  }

  public String encrypt(String plainText) throws Exception
  {
    cipher.init(Cipher.ENCRYPT_MODE, key, spec);
    byte[] encrypted = cipher.doFinal(plainText.getBytes(""UTF-8""));
    String encryptedText = new String(Base64.encode(encrypted, Base64.DEFAULT), ""UTF-8"");

    return encryptedText;
  }

  public String decrypt(String cryptedText) throws Exception
  {
    cipher.init(Cipher.DECRYPT_MODE, key, spec);
    byte[] bytes = Base64.decode(cryptedText, Base64.DEFAULT);
    byte[] decrypted = cipher.doFinal(bytes);
    String decryptedText = new String(decrypted, ""UTF-8"");

    return decryptedText;
  }",24
16854800,0,"    digest.update(password.getBytes(""UTF-8""));
    byte[] keyBytes = new byte[32];
    System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);

    cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    key = new SecretKeySpec(keyBytes, ""AES"");
    spec = getIV();",2
16854857,0,"public AESCrypt(String password) throws Exception
{
    // hash password with SHA-256 and crop the output to 128-bit for key
    MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
    digest.update(password.getBytes(""UTF-8""));
    byte[] keyBytes = new byte[32];
    System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);

    cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    key = new SecretKeySpec(keyBytes, ""AES"");
    spec = getIV();
}       

public AlgorithmParameterSpec getIV()
{
    byte[] iv = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
    IvParameterSpec ivParameterSpec;
    ivParameterSpec = new IvParameterSpec(iv);

    return ivParameterSpec;
}

public String encrypt(String plainText) throws Exception
{
    cipher.init(Cipher.ENCRYPT_MODE, key, spec);
    byte[] encrypted = cipher.doFinal(plainText.getBytes(""UTF-8""));
    String encryptedText = new String(Base64.encode(encrypted, Base64.DEFAULT), ""UTF-8"");

    return encryptedText;
}

public String decrypt(String cryptedText) throws Exception
{
    cipher.init(Cipher.DECRYPT_MODE, key, spec);
    byte[] bytes = Base64.decode(cryptedText, Base64.DEFAULT);
    byte[] decrypted = cipher.doFinal(bytes);
    String decryptedText = new String(decrypted, ""UTF-8"");

    return decryptedText;
}",24
16854857,0,"    digest.update(password.getBytes(""UTF-8""));
    byte[] keyBytes = new byte[32];
    System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);

    cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    key = new SecretKeySpec(keyBytes, ""AES"");
    spec = getIV();",2
17080884,1,"            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);

            //Factoria para crear la SecretKey, debemos indicar el Algoritmo
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);

            SecretKey tmp = factory.generateSecret(pbeKeySpec);

            //Creamos una llave;
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

            //Obtenemos la llave, solo informativo
            byte[] key = secret.getEncoded();

            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave simétrica",2
17080884,1,"            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);

            //Factoria para crear la SecretKey, debemos indicar el Algoritmo
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);

            SecretKey tmp = factory.generateSecret(pbeKeySpec);

            //Creamos una llave;
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

            //Obtenemos la llave, solo informativo
            byte[] key = secret.getEncoded();

            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave simétrica
            Cipher encryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);   

            //byte[] iv = generateIv();

            IvParameterSpec ivspec = new IvParameterSpec(iv);

            //Accion, SecretKey, parameter specification for an initialization vector
            encryptionCipher.init(Cipher.ENCRYPT_MODE, secret, ivspec);

            //Realizamos el cifrado",2
17080884,1,"            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);

            //Factoria para crear la SecretKey, debemos indicar el Algoritmo
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);

            SecretKey tmp = factory.generateSecret(pbeKeySpec);

            //Creamos una llave;
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

            //Obtenemos la llave, solo informativo
            byte[] key = secret.getEncoded();

            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave simétrica",2
17080884,1,"            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, PBE_ITERATION_COUNT, 256);

            //Factoria para crear la SecretKey, debemos indicar el Algoritmo
            SecretKeyFactory factory = SecretKeyFactory.getInstance(PBE_ALGORITHM);

            SecretKey tmp = factory.generateSecret(pbeKeySpec);

            //Creamos una llave;
            SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

            //Obtenemos la llave, solo informativo
            byte[] key = secret.getEncoded();

            //La clase Cipher, se usa para cifrar mediante algoritmos de  clave simétrica
            Cipher decryptionCipher = Cipher.getInstance(CIPHER_ALGORITHM);

            //byte[] iv = generateIv();

            IvParameterSpec ivspec = new IvParameterSpec(iv);

            //Accion, SecretKey, parameter specification for an initialization vector
            decryptionCipher.init(Cipher.DECRYPT_MODE, secret, ivspec);

            //Realizamos el descifrado",2
17323025,3,"    byte[] raw = key.getBytes(Charset.forName(""UTF-8""));
    if (raw.length != 16) {
      throw new IllegalArgumentException(""Invalid key size."");
    }

    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");",2
17323025,3,"    byte[] raw = key.getBytes(Charset.forName(""UTF-8""));
    if (raw.length != 16) {
      throw new IllegalArgumentException(""Invalid key size."");
    }
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");",2
17323025,3,"    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec,
        new IvParameterSpec(new byte[16]));
    byte[] original = cipher.doFinal(encrypted);
",2
17323051,0,"        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec,iv);
        byte[] encrypted = cipher.doFinal(value.getBytes());
        System.out.println(""encrypted string:"" + Base64.encodeBase64String(encrypted));
        return Base64.encodeBase64String(encrypted);",2
17323051,0,"        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec,iv);
        byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));

        return new String(original);",2
17418477,0,"        byte[] digest = md.digest();

        BigInteger bigInt = new BigInteger(1, digest);
        String output = bigInt.toString(16);
        while (output.length() < 32) {
            output = ""0"" + output;
        }
",4
17490344,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i < messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
        return hexString.toString();
",4
17490344,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i < messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
        return hexString.toString();
",4
17490344,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i < messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));",4
17490344,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i < messageDigest.length; i++)
            hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
        return hexString.toString();
",4
17515382,8,"public static PublicKey bytesToPubKey(byte[] bytes) throws InvalidKeySpecException, NoSuchAlgorithmException{
    return KeyFactory.getInstance(""RSA"").generatePublic(new X509EncodedKeySpec(bytes));
}
public static PrivateKey bytesToPrivKey(byte[] bytes) throws InvalidKeySpecException, NoSuchAlgorithmException{
    return KeyFactory.getInstance(""RSA"").generatePrivate(new PKCS8EncodedKeySpec(bytes));
}
",3
17586111,0,"public class sample{
 public void foo(){
PackageInfo info;
try {
    info = getPackageManager().getPackageInfo(""com.you.name"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }
} catch (NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}

}",4
17586111,0,"    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }",4
17586111,0,"    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }
} catch (NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}
",4
17725333,0,"    byte[] iv = new byte[16];
    rnd.nextBytes(iv);
    IvParameterSpec ivSpec = new IvParameterSpec(iv);

    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, ""AES""), ivSpec);",5
17736146,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }",4
17770788,0,"    for (Signature signature: info.signatures)  {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.e(""FACEBOOK APP SIGNATURE"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }",4
17854946,0,"public MCrypt(String SecretKey) {
    ivspec = new IvParameterSpec(iv.getBytes());
    keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");
    try {
        cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    }
}

public byte[] encrypt(String text) throws Exception {
    if (text == null || text.length() == 0)
        throw new Exception(""Empty string"");
    byte[] encrypted = null;
    try {
        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
        encrypted = cipher.doFinal(padString(text).getBytes());
    } catch (Exception e) {
        throw new Exception(""[encrypt] "" + e.getMessage());
    }
    return encrypted;
}
",2
17854946,0,"public MCrypt(String SecretKey) {
    ivspec = new IvParameterSpec(iv.getBytes());
    keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");
    try {
        cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    }
}

public byte[] encrypt(String text) throws Exception {
    if (text == null || text.length() == 0)
        throw new Exception(""Empty string"");
    byte[] encrypted = null;
    try {
        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
        encrypted = cipher.doFinal(padString(text).getBytes());
    } catch (Exception e) {
        throw new Exception(""[encrypt] "" + e.getMessage());
    }
    return encrypted;
}

private byte[] decrypt(String code) throws Exception {
    if (code == null || code.length() == 0)
        throw new Exception(""Empty string"");
    byte[] decrypted = null;
    try {
        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
        decrypted = cipher.doFinal(hexToBytes(code));
    } catch (Exception e) {
        throw new Exception(""[decrypt] "" + e.getMessage());
    }
    return decrypted;
}

public static String bytesToHex(byte[] data) {
    if (data == null) {
        return null;
    }

    int len = data.length;
    String str = """";
    for (int i = 0; i < len; i++) {
        if ((data[i] & 0xFF) < 16)
            str = str + ""0"" + java.lang.Integer.toHexString(data[i] & 0xFF);
        else
            str = str + java.lang.Integer.toHexString(data[i] & 0xFF);
    }
    return str;
}

private static byte[] hexToBytes(String str) {
    if (str == null) {
        return null;
    } else if (str.length() < 2) {
        return null;
    } else {
        int len = str.length() / 2;
        byte[] buffer = new byte[len];
        for (int i = 0; i < len; i++) {
            buffer[i] = (byte) Integer.parseInt(
                    str.substring(i * 2, i * 2 + 2), 16);
        }
        return buffer;
    }
}

private String padString(String source) {

    char paddingChar = ' ';
    int size = 16;
    int x = source.length() % size;
    int padLength = size - x;

    for (int i = 0; i < padLength; i++) {
        source += paddingChar;
    }
    return source;
}
",2
17854946,0,"    keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");
    try {
        cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    }",2
17854946,0,"    if (text == null || text.length() == 0)
        throw new Exception(""Empty string"");
    byte[] encrypted = null;
    try {
        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
        encrypted = cipher.doFinal(padString(text).getBytes());",2
17854946,0,"    byte[] encrypted = null;
    try {
        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
        encrypted = cipher.doFinal(padString(text).getBytes());
    } catch (Exception e) {
        throw new Exception(""[encrypt] "" + e.getMessage());
    }
    return encrypted;",2
17854946,0,"private byte[] decrypt(String code) throws Exception {
    if (code == null || code.length() == 0)
        throw new Exception(""Empty string"");
    byte[] decrypted = null;
    try {
        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
        decrypted = cipher.doFinal(hexToBytes(code));
    } catch (Exception e) {
        throw new Exception(""[decrypt] "" + e.getMessage());
    }
    return decrypted;
}

public static String bytesToHex(byte[] data) {
    if (data == null) {
        return null;
    }

    int len = data.length;
    String str = """";
    for (int i = 0; i < len; i++) {
        if ((data[i] & 0xFF) < 16)
            str = str + ""0"" + java.lang.Integer.toHexString(data[i] & 0xFF);
        else
            str = str + java.lang.Integer.toHexString(data[i] & 0xFF);
    }
    return str;
}

private static byte[] hexToBytes(String str) {
    if (str == null) {
        return null;
    } else if (str.length() < 2) {
        return null;
    } else {
        int len = str.length() / 2;
        byte[] buffer = new byte[len];
        for (int i = 0; i < len; i++) {
            buffer[i] = (byte) Integer.parseInt(
                    str.substring(i * 2, i * 2 + 2), 16);
        }
        return buffer;
    }
}
",2
17854946,0,"    if (code == null || code.length() == 0)
        throw new Exception(""Empty string"");
    byte[] decrypted = null;
    try {
        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
        decrypted = cipher.doFinal(hexToBytes(code));",2
17854946,0,"    try {
        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);
        decrypted = cipher.doFinal(hexToBytes(code));
    } catch (Exception e) {
        throw new Exception(""[decrypt] "" + e.getMessage());
    }
    return decrypted;
}

public static String bytesToHex(byte[] data) {
    if (data == null) {
        return null;
    }

    int len = data.length;
    String str = """";
    for (int i = 0; i < len; i++) {
        if ((data[i] & 0xFF) < 16)
            str = str + ""0"" + java.lang.Integer.toHexString(data[i] & 0xFF);
        else
            str = str + java.lang.Integer.toHexString(data[i] & 0xFF);
    }
    return str;
}

private static byte[] hexToBytes(String str) {
    if (str == null) {
        return null;
    } else if (str.length() < 2) {
        return null;
    } else {
        int len = str.length() / 2;
        byte[] buffer = new byte[len];
        for (int i = 0; i < len; i++) {
            buffer[i] = (byte) Integer.parseInt(
                    str.substring(i * 2, i * 2 + 2), 16);
        }
        return buffer;
    }
}

private String padString(String source) {

    char paddingChar = ' ';
    int size = 16;
    int x = source.length() % size;
    int padLength = size - x;

    for (int i = 0; i < padLength; i++) {
        source += paddingChar;
    }
    return source;
}
",2
17860052,0,"    byte[] decoded = Base64.decode(privKeyPEM, Base64.DEFAULT);
    PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(decoded);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");
    PrivateKey privKey = kf.generatePrivate(spec);

    Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, privKey);

    encrypted = cipher.doFinal(plaintext.getBytes());
    encoded = Base64.encodeToString(encrypted, Base64.DEFAULT);",3
17873905,0,"        public String decrypt(String encryptedString) {
            String decryptedText=null;
            try {
                cipher.init(Cipher.DECRYPT_MODE, key);
                BASE64Decoder base64decoder = new BASE64Decoder();
                byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);
                byte[] plainText = cipher.doFinal(encryptedText);
                decryptedText= bytes2String(plainText);
            } catch (Exception e) {
                e.printStackTrace();
            }
            return decryptedText;
        }
        /**
         * Returns String From An Array Of Bytes
         */",2
17925969,2,"    byte[] b = key.getBytes(""UTF-8"");
    int len = b.length;
    if (len > keyBytes.length)
        len = keyBytes.length;
    System.arraycopy(b, 0, keyBytes, 0, len);
    SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
",2
17925969,2,"    IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

    byte[] results = cipher.doFinal(text.getBytes(""UTF-8""));
    BASE64Decoder encoder = new BASE64Decoder();
    return encoder.encodeBytes(results);",6
17971012,0,"    String text = ""This is some test text."";

    byte[] encrypted = encrypt(key, text.getBytes());
    byte[] decrypted = decrypt(key, encrypted);

    System.out.println(""Text: "" + text);
    System.out.println(""Encrypted: "" + Hex.encodeHexString(encrypted));
    System.out.println(""Decrypted: "" + new String(decrypted));",2
17971012,0,"    byte[] iv = new byte[16];
    rnd.nextBytes(iv);
    IvParameterSpec ivSpec = new IvParameterSpec(iv);

    //Set up the cipher and encrypt
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, ""AES""), ivSpec);",5
17971012,0,"    IvParameterSpec ivSpec = new IvParameterSpec(iv);

    //Set up the cipher and encrypt
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, ""AES""), ivSpec);
    byte[] encrypted = cipher.doFinal(unencrypted);

    //Append the encrypted text to the IV",2
17971012,0,"    IvParameterSpec ivSpec = new IvParameterSpec(iv);
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, ""AES""), ivSpec);
    byte[] decrypted = cipher.doFinal(encryptedText);
",2
17975379,5,"        Cipher cipher = Cipher.getInstance(CIPHER_ALGO, bc);

        byte[] keyBytes = Hex.decodeHex(keytext.toCharArray());
        SecretKeySpec key = new SecretKeySpec(keyBytes, KEY_ALGO);
        cipher.init(Cipher.ENCRYPT_MODE, key);
",2
17975379,5,"        Cipher cipher = Cipher.getInstance(CIPHER_ALGO, bc);

        byte[] keyBytes = Hex.decodeHex(keytext.toCharArray());
        SecretKeySpec key = new SecretKeySpec(keyBytes, KEY_ALGO);
        cipher.init(Cipher.DECRYPT_MODE, key);
",2
17998351,0,"        for (Signature signature: info.signatures)
        {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""YOUR HASH KEY:"",
                Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
18016739,0,"private byte[] encrypt(String key, String plainText) throws GeneralSecurityException {

    SecretKey secret_key = new SecretKeySpec(key.getBytes(), ALGORITM);

    Cipher cipher = Cipher.getInstance(ALGORITM);
    cipher.init(Cipher.ENCRYPT_MODE, secret_key);

    return cipher.doFinal(plainText.getBytes());
}
",2
18017695,0,"private byte[] encrypt(String key, String plainText) throws GeneralSecurityException {

    SecretKey secret_key = new SecretKeySpec(key.getBytes(), ALGORITM);

    Cipher cipher = Cipher.getInstance(ALGORITM);
    cipher.init(Cipher.ENCRYPT_MODE, secret_key);

    return cipher.doFinal(plainText.getBytes());
}
",2
18017911,0,"private byte[] encrypt(String key, String plainText) throws GeneralSecurityException {

    SecretKey secret_key = new SecretKeySpec(key.getBytes(), ALGORITM);

    Cipher cipher = Cipher.getInstance(ALGORITM);
    cipher.init(Cipher.ENCRYPT_MODE, secret_key);

    return cipher.doFinal(plainText.getBytes());
}
",2
18031179,0,"        byte[] b= KEY.getBytes(""UTF-8"");
        int len= b.length;
        if (len > keyBytes.length) len = keyBytes.length;
        System.arraycopy(b, 0, keyBytes, 0, len);
        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, ""AES"");
        IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);
        cipher.init(Cipher.DECRYPT_MODE,keySpec,ivSpec);",2
18043320,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""YOURHASH KEY:"",
                        Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
18081254,5,"    String text = ""Password12345678"";

    byte[] encrypted = encrypt(key, text.getBytes());
    byte[] decrypted = decrypt(key, encrypted);

    System.out.println(""Text: "" + text);
    System.out.println(""Encrypted: "" + Hex.encodeHexString(encrypted));
    System.out.println(""Decrypted: "" + new String(decrypted));",2
18114634,1,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i < messageDigest.length; i++) {
            String h = Integer.toHexString(0xFF & messageDigest[i]);
            while (h.length() < 2)
                h = ""0"" + h;
            hexString.append(h);
        }",4
18114859,3,"    byte[] keyData = new byte[keysize / Byte.SIZE];
    System.arraycopy(givenKey, 0, keyData, 0, Math.min(givenKey.length, keyData.length));
    KeyParameter key = new KeyParameter(keyData);

    // create a Rijndael cipher with 256 bit block size, this is not AES
    BlockCipher rijndael = new RijndaelEngine(256);

    // use a padding method that only works on data that cannot end with zero valued bytes
    ZeroBytePadding c = new ZeroBytePadding();

    // use ECB mode encryption, which should never be used
    PaddedBufferedBlockCipher pbbc = new PaddedBufferedBlockCipher(rijndael, c);

    // initialize the cipher using the key (no need for an IV, this is ECB)",2
18114859,3,"    byte[] plaintext = args[1].getBytes(Charset.forName(""UTF8""));

    // create a buffer for the ciphertext
    byte[] ciphertext = new byte[pbbc.getOutputSize(plaintext.length)];

    int offset = 0;
    offset += pbbc.processBytes(plaintext, 0, plaintext.length, ciphertext, offset);
    offset += pbbc.doFinal(ciphertext, offset);

    // show the ciphertext",2
18115456,0,"            KeyPairGenerator generator;
            generator = KeyPairGenerator.getInstance(""RSA"", ""BC"");
            generator.initialize(256, new SecureRandom());
            KeyPair pair = generator.generateKeyPair();
            pubKey = pair.getPublic();
            privKey = pair.getPrivate();            
            byte[] publicKeyBytes = pubKey.getEncoded();
            String pubKeyStr = new String(Base64.encode(publicKeyBytes));
            byte[] privKeyBytes = privKey.getEncoded();
            String privKeyStr = new String(Base64.encode(privKeyBytes));            
            SPE = SP.edit();
            SPE.putString(""PublicKey"", pubKeyStr);
            SPE.putString(""PrivateKey"", privKeyStr);           
            SPE.commit();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }           
    }
    public PublicKey getPublicKey(){
        String pubKeyStr = SP.getString(""PublicKey"", """");       
        byte[] sigBytes = Base64.decode(pubKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePublic(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPublicKeyAsString(){
        return SP.getString(""PublicKey"", """");       
    }
    public PrivateKey getPrivateKey(){
        String privKeyStr = SP.getString(""PrivateKey"", """");
        byte[] sigBytes = Base64.decode(privKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePrivate(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPrivateKeyAsString(){
        return SP.getString(""PrivateKey"", """");      
    }",3
18115456,0,"    public PublicKey getPublicKey(){
        String pubKeyStr = SP.getString(""PublicKey"", """");       
        byte[] sigBytes = Base64.decode(pubKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePublic(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPublicKeyAsString(){
        return SP.getString(""PublicKey"", """");       
    }",3
18115456,0,"    public PrivateKey getPrivateKey(){
        String privKeyStr = SP.getString(""PrivateKey"", """");
        byte[] sigBytes = Base64.decode(privKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePrivate(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPrivateKeyAsString(){
        return SP.getString(""PrivateKey"", """");      
    }",3
18146713,0,"byte[] modulusBytes = Base64.decodeBase64(modulusString);
byte[] exponentBytes = Base64.decodeBase64(publicExponentString);
BigInteger modulus = new BigInteger(1, modulusBytes);
BigInteger publicExponent = new BigInteger(1, exponentBytes);

RSAPublicKeySpec rsaPubKey = new RSAPublicKeySpec(modulus, publicExponent);
KeyFactory fact = KeyFactory.getInstance(""RSA"");",3
18146713,0,"BigInteger modulus = new BigInteger(1, modulusBytes);
BigInteger publicExponent = new BigInteger(1, exponentBytes);

RSAPublicKeySpec rsaPubKey = new RSAPublicKeySpec(modulus, publicExponent);
KeyFactory fact = KeyFactory.getInstance(""RSA"");
PublicKey pubKey = fact.generatePublic(rsaPubKey);
Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1PADDING"");
cipher.init(Cipher.ENCRYPT_MODE, pubKey);
",3
18146713,0,"KeyFactory fact = KeyFactory.getInstance(""RSA"");
PublicKey pubKey = fact.generatePublic(rsaPubKey);
Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1PADDING"");
cipher.init(Cipher.ENCRYPT_MODE, pubKey);
",3
18223152,0,"            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            Document doc = db.parse(new InputSource(url.openStream()));
            doc.getDocumentElement().normalize();

            NodeList nodeList = doc.getElementsByTagName(""item"");
            for (int i = 0; i < nodeList.getLength(); i++) {

                Node node = nodeList.item(i);       

                Element fstElmnt = (Element) node;
                NodeList nameList = fstElmnt.getElementsByTagName(""title"");
                Element nameElement = (Element) nameList.item(0);
                nameList = nameElement.getChildNodes();         ",-1
18241416,0,"    Mac mac = Mac.getInstance(""HmacSHA256"");
    SecretKeySpec secret = new SecretKeySpec(PRIVATE_KEY.getBytes(), ""HmacSHA256"");
    mac.init(secret);
    byte[] digest = mac.doFinal(str.getBytes());",4
18263263,0,"Signature ecdsaSign = Signature.getInstance(""SHA256withECDSA"", ""BC"");
ecdsaSign.initSign(pair.getPrivate());
ecdsaSign.update(plaintext.getBytes(""UTF-8""));
byte[] signature = ecdsaSign.sign();
",4
18346374,0,"  private SSLSocketFactory newSslSocketFactory() {
      try {

          // Get an instance of the Bouncy Castle KeyStore format
            KeyStore trusted = KeyStore.getInstance(""BKS"");//put BKS literal  
            // Get the raw resource, which contains the keystore with
            // your trusted certificates (root and any intermediate certs)
            InputStream in =context.getResources().openRawResource(R.raw.keystore);
            try {
                // Initialize the keystore with the provided trusted certificates
                // Also provide the password of the keystore
                trusted.load(in, ""mysecret"".toCharArray());
            } finally {
                in.close();
            }
          // Pass the keystore to the SSLSocketFactory. The factory is responsible
          // for the verification of the server certificate.
          SSLSocketFactory sf = new SSLSocketFactory(trusted);
          // Hostname verification from certificate

           sf.setHostnameVerifier(SSLSocketFactory.STRICT_HOSTNAME_VERIFIER);
          return sf;
      } catch (Exception e) {
          throw new AssertionError(e);
      }
  }
",1
18346374,0,"            KeyStore trusted = KeyStore.getInstance(""BKS"");//put BKS literal  
            // Get the raw resource, which contains the keystore with
            // your trusted certificates (root and any intermediate certs)
            InputStream in =context.getResources().openRawResource(R.raw.keystore);
            try {
                // Initialize the keystore with the provided trusted certificates
                // Also provide the password of the keystore
                trusted.load(in, ""mysecret"".toCharArray());
            } finally {
                in.close();
            }
          // Pass the keystore to the SSLSocketFactory. The factory is responsible
          // for the verification of the server certificate.",1
18358247,0,"        if (text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());",2
18358247,0,"        if (code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));",2
18371429,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
18414863,0,"        Signature[] signatures = packageInfo.signatures;

        byte[] cert = signatures[0].toByteArray();

        InputStream input = new ByteArrayInputStream(cert);

        CertificateFactory cf = null;
        try {
                cf = CertificateFactory.getInstance(""X509"");

",3
18427371,0,"                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
                DocumentBuilder db = dbf.newDocumentBuilder();
                Document doc = db.parse(new InputSource(url.openStream()));

                doc.getDocumentElement().normalize();

                NodeList nodeList = doc.getElementsByTagName(""item"");

                for (int i = 0; i < nodeList.getLength(); i++) {

                    Node node = nodeList.item(i);       

                    Element fstElmnt = (Element) node;
                    NodeList nameList = fstElmnt.getElementsByTagName(""name"");
                    Element nameElement = (Element) nameList.item(0);
                    nameList = nameElement.getChildNodes();",-1
18573851,0,"public class AesFileIo {
//    private static final String AES_ALGORITHM = ""AES/CTR/NoPadding"";
    private static final String AES_ALGORITHM = ""AES/CBC/PKCS5Padding"";
    private SecretKeySpec secretKeySpec;
    private IvParameterSpec ivSpec;

    public AesFileIo(byte[] aesKey, byte[] iv) {
        ivSpec = new IvParameterSpec(iv);
        secretKeySpec = new SecretKeySpec(aesKey, ""AES"");
    }

    public String decrypt(String text) {

        StringBuilder stringBuilder = new StringBuilder(); 
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);
            byte[] decordedValue =  Base64.decode(text,Base64.DEFAULT);
            String decryptedValue = new String(cipher.doFinal(decordedValue),""UTF-8"");
            Log.e(""decrypted Value :"",decryptedValue);
            return decryptedValue; 
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
        return stringBuilder.toString();
    }

    public String encrypt(String text) {
        String encryptedValue=null;
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM); 
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);
            byte[] encValue = cipher.doFinal(text.getBytes());
            encryptedValue = Base64.encodeToString(encValue,Base64.DEFAULT);
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
        return encryptedValue;
    }
}",2
18630832,0,"DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();
Document doc = db.parse(new InputSource(url.openStream()));

doc.getDocumentElement().normalize();

NodeList nodeList = doc.getElementsByTagName(""item"");

for (int i = 0; i < nodeList.getLength(); i++) {

Node node = nodeList.item(i);

Element fstElmnt = (Element) node;
NodeList nameList = fstElmnt.getElementsByTagName(""name"");
Element nameElement = (Element) nameList.item(0);
nameList = nameElement.getChildNodes();",-1
18657143,0,"public class sample{
 public void foo(){
PackageInfo info;
try {

    info = getPackageManager().getPackageInfo( ""com.you.name"",PackageManager.GET_SIGNATURES);

    for (Signature signature : info.signatures)
    {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""Hash key"", something);
    }

} catch (NameNotFoundException e1) {
Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
Log.e(""exception"", e.toString());
}

}",4
18657143,0,"    for (Signature signature : info.signatures)
    {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""Hash key"", something);
    }
",4
18657143,0,"    for (Signature signature : info.signatures)
    {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""Hash key"", something);
    }

} catch (NameNotFoundException e1) {
Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
Log.e(""exception"", e.toString());
}
",4
18685470,0,"                DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
                DocumentBuilder db = dbf.newDocumentBuilder();
                Document doc = db.parse(new InputSource(url.openStream()));

                doc.getDocumentElement().normalize();

                NodeList nodeList = doc.getElementsByTagName(""item"");

                for (int i = 0; i < nodeList.getLength(); i++) {

                    Node node = nodeList.item(i);       

                    Element fstElmnt = (Element) node;
                    NodeList nameList = fstElmnt.getElementsByTagName(""channel"");
                    Element nameElement = (Element) nameList.item(0);
                    nameList = nameElement.getChildNodes();",-1
18733422,0,"    md = MessageDigest.getInstance(""SHA-256"");
    byte[] md5 = new byte[64];
    md.update(text.getBytes(""iso-8859-1""), 0, text.length());
    md5 = md.digest();",4
18740367,0,"            MessageDigest digest = java.security.MessageDigest.getInstance(""SHA-1"");
            digest.update(s.getBytes(""UTF-8""));
            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < messageDigest.length; i++)",4
18740367,0,"            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < messageDigest.length; i++)
                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
            return hexString.toString();
",4
18740367,0,"            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < messageDigest.length; i++)
                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
            return hexString.toString();
",4
18740367,0,"            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < messageDigest.length; i++)
                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));",4
18740367,0,"            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < messageDigest.length; i++)
                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
            return hexString.toString();
",4
18754772,1,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
18842591,0,"private X509Certificate getCertFromFile(String path) throws Exception {
    AssetManager assetManager = MyActivity.this.getResources().getAssets();
    InputStream inputStream = null;
    try {
        inputStream = assetManager.open(path);
    } catch (IOException e) {
        e.printStackTrace();
    }
    InputStream caInput = new BufferedInputStream(inputStream);
    X509Certificate cert = null;
    CertificateFactory cf = CertificateFactory.getInstance(""X509"");
    cert = (X509Certificate) cf.generateCertificate(caInput);
    cert.getSerialNumber();
    return cert;
}
",1
18848428,0,"public class AesFileIo {
//    private static final String AES_ALGORITHM = ""AES/CTR/NoPadding"";
    private static final String AES_ALGORITHM = ""AES/CBC/PKCS5Padding"";
    private SecretKeySpec secretKeySpec;
    private IvParameterSpec ivSpec;

    public AesFileIo(byte[] aesKey, byte[] iv) {
        ivSpec = new IvParameterSpec(iv);
        secretKeySpec = new SecretKeySpec(aesKey, ""AES"");
    }

    public String decrypt(String text) {

        StringBuilder stringBuilder = new StringBuilder(); 
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec);
            byte[] decordedValue =  Base64.decode(text,Base64.DEFAULT);
            String decryptedValue = new String(cipher.doFinal(decordedValue),""UTF-8"");
            Log.e(""decrypted Value :"",decryptedValue);
            return decryptedValue; 
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
        return stringBuilder.toString();
    }

    public String encrypt(String text) {
        String encryptedValue=null;
        try {
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM); 
            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivSpec);
            byte[] encValue = cipher.doFinal(text.getBytes());
            encryptedValue = Base64.encodeToString(encValue,Base64.DEFAULT);
        } catch (Exception e) {
            Log.e(this.getClass().toString(), e.getMessage(), e);
        }
        return encryptedValue;
    }
}",2
18882130,1,"    {
        var pubRings =
            new PgpPublicKeyRingBundle(PgpUtilities.GetDecoderStream(publicIn)).GetKeyRings().OfType<PgpPublicKeyRing>();
        var pubKeys = pubRings.SelectMany(x => x.GetPublicKeys().OfType<PgpPublicKey>());
        var pubKey = pubKeys.FirstOrDefault();
        return pubKey;",3
18882130,1,"    {
        var secRings =
            new PgpSecretKeyRingBundle(PgpUtilities.GetDecoderStream(secretIn)).GetKeyRings().OfType<PgpSecretKeyRing>();
        var secKeys = secRings.SelectMany(x => x.GetSecretKeys().OfType<PgpSecretKey>());
        var secKey = secKeys.FirstOrDefault();
        return secKey;",3
18892960,2,"            InvalidAlgorithmParameterException, IOException {
        try {
            // byte[] iv = new byte[] { (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,
            // 0x07, 0x72, 0x6F, 0x5A, (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,
            // 0x07, 0x72, 0x6F, 0x5A };
            //generate new AlgorithmParameterSpec 
            // AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);
            Cipher c = Cipher.getInstance(ALGO_VIDEO_ENCRYPTOR);
            c.init(Cipher.ENCRYPT_MODE, key, paramSpec);
            out = new CipherOutputStream(out, c);
            int count = 0;
            byte[] buffer = new byte[DEFAULT_READ_WRITE_BLOCK_BUFFER_SIZE];
            while ((count = in.read(buffer)) >= 0) {
                out.write(buffer, 0, count);
            }
        } finally {
            out.close();
        }",2
18892960,2,"            InvalidAlgorithmParameterException, IOException {
        try {
            // byte[] iv = new byte[] { (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,
            // 0x07, 0x72, 0x6F, 0x5A, (byte) 0x8E, 0x12, 0x39, (byte) 0x9C,
            // 0x07, 0x72, 0x6F, 0x5A };
            // read from input stream AlgorithmParameterSpec 
            // AlgorithmParameterSpec paramSpec = new IvParameterSpec(iv);
            Cipher c = Cipher.getInstance(ALGO_VIDEO_ENCRYPTOR);
            c.init(Cipher.DECRYPT_MODE, key, paramSpec);
            out = new CipherOutputStream(out, c);
            int count = 0;
            byte[] buffer = new byte[DEFAULT_READ_WRITE_BLOCK_BUFFER_SIZE];
            while ((count = in.read(buffer)) >= 0) {
                out.write(buffer, 0, count);
            }
        } finally {
            out.close();
        }",2
19219685,0,"public SecretKeySpec getKey(String password)
        throws UnsupportedEncodingException {


    int keyLength = 128;
    byte[] keyBytes = new byte[keyLength / 8];
    // explicitly fill with zeros
    Arrays.fill(keyBytes, (byte) 0x0);

    // if password is shorter then key length, it will be zero-padded
    // to key length
    byte[] passwordBytes = password.getBytes(""UTF-8"");
    int length = passwordBytes.length < keyBytes.length ? passwordBytes.length
            : keyBytes.length;
    System.arraycopy(passwordBytes, 0, keyBytes, 0, length);
    SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");
    return key;
}
",2
19219718,0,"public SecretKeySpec getKey(String password)
        throws UnsupportedEncodingException {


    int keyLength = 128;
    byte[] keyBytes = new byte[keyLength / 8];
    // explicitly fill with zeros
    Arrays.fill(keyBytes, (byte) 0x0);

    // if password is shorter then key length, it will be zero-padded
    // to key length
    byte[] passwordBytes = password.getBytes(""UTF-8"");
    int length = passwordBytes.length < keyBytes.length ? passwordBytes.length
            : keyBytes.length;
    System.arraycopy(passwordBytes, 0, keyBytes, 0, length);
    SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");
    return key;
}
",2
19250174,0,"        IvParameterSpec ivspec = new IvParameterSpec(iv);

        // initialize the cipher for encrypt mode
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivspec);

        // encrypt the message
        byte[] encrypted = cipher.doFinal(message.getBytes());",2
19349955,0,"        for (Signature signature : info.signatures) {
            MessageDigest md;

            md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String something = new String(Base64.encode(md.digest(), 0));
            Log.d(""Hash key"", something);
        } ",4
19361378,0,"    public class MySSLSocketFactory extends SSLSocketFactory {
        SSLContext sslContext = SSLContext.getInstance(getString(R.string.tls));

        public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {
            super(truststore);

            TrustManager tm = new X509TrustManager() {
                public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
                }

                public X509Certificate[] getAcceptedIssuers() {
                    return null;
                }
            };

            sslContext.init(null, new TrustManager[] { tm }, null);
        }

        public MySSLSocketFactory(SSLContext context) throws KeyManagementException, NoSuchAlgorithmException, KeyStoreException, UnrecoverableKeyException {
            super(null);
            sslContext = context;
        }

        @Override
        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
            return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
        }

        @Override
        public Socket createSocket() throws IOException {
            return sslContext.getSocketFactory().createSocket();
        }
    }
    /**********************************end********************************************/",1
19361378,0,"        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
            return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
        }

        @Override
        public Socket createSocket() throws IOException {
            return sslContext.getSocketFactory().createSocket();
        }",1
19387517,3,"public class PrivateKeyReader {

  public static PrivateKey get(String filename)
  throws Exception {

    byte[] keyBytes = Files.readAllBytes(Paths.get(filename));

    PKCS8EncodedKeySpec spec =
      new PKCS8EncodedKeySpec(keyBytes);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");
    return kf.generatePrivate(spec);
  }
}",3
19387517,4,"public class PublicKeyReader {

  public static PublicKey get(String filename)
    throws Exception {

    byte[] keyBytes = Files.readAllBytes(Paths.get(filename));

    X509EncodedKeySpec spec =
      new X509EncodedKeySpec(keyBytes);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");
    return kf.generatePublic(spec);
  }
}",3
19410828,0,"public class sample{
 public void foo(){
SchemeRegistry schReg = new SchemeRegistry();
schReg.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
schReg.register(new Scheme(""https"",SSLSocketFactory.getSocketFactory(), 443));
SingleClientConnManager conMgr = new SingleClientConnManager(params,post.getParams());

}",1
19681949,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }",4
19681966,0,"    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }",4
19682000,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }",4
19725202,0,"        gcmEngine.init(true, parameters);

        byte[] encMsg = new byte[gcmEngine.getOutputSize(inMsg.length)];
        int encLen = gcmEngine.processBytes(inMsg, 0, inMsg.length, encMsg,
                0);
        encLen += gcmEngine.doFinal(encMsg, encLen);

        System.out.println(""encLen==="" + encLen);

        // decrypt",2
19725202,0,"        byte[] encMsg = new byte[gcmEngine.getOutputSize(inMsg.length)];
        int encLen = gcmEngine.processBytes(inMsg, 0, inMsg.length, encMsg,
                0);
        encLen += gcmEngine.doFinal(encMsg, encLen);
",2
19725202,0,"        gcmEngine.init(false, parameters);

        byte[] decMsg = new byte[gcmEngine.getOutputSize(encMsg.length)];
        int decLen = gcmEngine.processBytes(encMsg, 0, encMsg.length,
                decMsg, 0);
        decLen += gcmEngine.doFinal(decMsg, decLen);

        System.out.println(""decLen==="" + decLen);
",2
19725202,0,"        byte[] decMsg = new byte[gcmEngine.getOutputSize(encMsg.length)];
        int decLen = gcmEngine.processBytes(encMsg, 0, encMsg.length,
                decMsg, 0);
        decLen += gcmEngine.doFinal(decMsg, decLen);
",2
19738072,0,"MessageDigest md = MessageDigest.getInstance(""SHA-1"");
byte[] sha1hash = new byte[40];
md.update(text.getBytes(""UTF-8""), 0, text.length()); // TODO verify the lengths are the same
sha1hash = md.digest();
",4
19750393,1,"    in = PGPUtil.getDecoderStream(in);

    PGPObjectFactory pgpF = new PGPObjectFactory(in);
    PGPEncryptedDataList enc;

    Object o = pgpF.nextObject();
    //
    // the first object might be a PGP marker packet.
    //
    if (o instanceof PGPEncryptedDataList) {
        enc = (PGPEncryptedDataList) o;
    } else {
        enc = (PGPEncryptedDataList) pgpF.nextObject();
    }

    //
    // find the secret key
    //",4
19750393,1,"    in = PGPUtil.getDecoderStream(in);

    PGPObjectFactory pgpF = new PGPObjectFactory(in);
    PGPEncryptedDataList enc;

    Object o = pgpF.nextObject();
    //
    // the first object might be a PGP marker packet.
    //
    if (o instanceof PGPEncryptedDataList) {
        enc = (PGPEncryptedDataList) o;
    } else {
        enc = (PGPEncryptedDataList) pgpF.nextObject();
    }

    //
    // find the secret key
    //
    Iterator<PGPPublicKeyEncryptedData> it = enc.getEncryptedDataObjects();
    PGPPrivateKey sKey = null;
    PGPPublicKeyEncryptedData pbe = null;",4
19750393,1,"    PGPEncryptedDataList enc;

    Object o = pgpF.nextObject();
    //
    // the first object might be a PGP marker packet.
    //
    if (o instanceof PGPEncryptedDataList) {
        enc = (PGPEncryptedDataList) o;
    } else {
        enc = (PGPEncryptedDataList) pgpF.nextObject();
    }

    //
    // find the secret key
    //
    Iterator<PGPPublicKeyEncryptedData> it = enc.getEncryptedDataObjects();
    PGPPrivateKey sKey = null;
    PGPPublicKeyEncryptedData pbe = null;",4
19750393,1,"    if (o instanceof PGPEncryptedDataList) {
        enc = (PGPEncryptedDataList) o;
    } else {
        enc = (PGPEncryptedDataList) pgpF.nextObject();
    }

    //
    // find the secret key
    //
    Iterator<PGPPublicKeyEncryptedData> it = enc.getEncryptedDataObjects();
    PGPPrivateKey sKey = null;
    PGPPublicKeyEncryptedData pbe = null;",4
19750393,1,"    message = plainFact.nextObject();
    ByteArrayOutputStream actualOutput = new ByteArrayOutputStream();

    while (message != null) {
        __l.trace(message.toString());
        if (message instanceof PGPCompressedData) {
            compressedData = (PGPCompressedData) message;
            plainFact = new PGPObjectFactory(compressedData.getDataStream());
            message = plainFact.nextObject();
        }

        if (message instanceof PGPLiteralData) {
            // have to read it and keep it somewhere.
            Streams.pipeAll(((PGPLiteralData) message).getInputStream(), actualOutput);
        } else if (message instanceof PGPOnePassSignatureList) {
            onePassSignatureList = (PGPOnePassSignatureList) message;
        } else if (message instanceof PGPSignatureList) {
            signatureList = (PGPSignatureList) message;
        } else {
            throw new PGPException(""message unknown message type."");
        }
        message = plainFact.nextObject();
    }
    actualOutput.close();
    PGPPublicKey publicKey = null;
    byte[] output = actualOutput.toByteArray();
    if (onePassSignatureList == null || signatureList == null) {
        throw new PGPException(""Poor PGP. Signatures not found."");
    } else {

        for (int i = 0; i < onePassSignatureList.size(); i++) {
            PGPOnePassSignature ops = onePassSignatureList.get(0);
            __l.trace(""verifier : "" + ops.getKeyID());
            PGPPublicKeyRingCollection pgpRing = new PGPPublicKeyRingCollection(
                    PGPUtil.getDecoderStream(publicKeyIn));
            publicKey = pgpRing.getPublicKey(ops.getKeyID());
            if (publicKey != null) {
                ops.init(new JcaPGPContentVerifierBuilderProvider().setProvider(""BC""), publicKey);
                ops.update(output);
                PGPSignature signature = signatureList.get(i);",4
19750393,1,"    if (pbe.isIntegrityProtected() && !pbe.verify()) {
        throw new PGPException(""Data is integrity protected but integrity is lost."");
    } else if (publicKey == null) {
        throw new SignatureException(""Signature not found"");
    } else {
        fOut.write(output);
        fOut.flush();
        fOut.close();
    }",4
19821504,0," FileInputStream instream = new FileInputStream(new File(""miller.keystore""));
 try {
     trustStore.load(instream, ""pw"".toCharArray());
 } finally {
     instream.close();
 }

 SSLContext sslcontext = SSLContexts.custom()",1
19875505,0,"            IvParameterSpec ivSpec = new IvParameterSpec(iv);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec,ivSpec);
            byte[] results = cipher.doFinal(text.getBytes(""UTF-8""));
            Encoded = Base64.encodeToString(results,Base64.URL_SAFE);
",2
19886537,2,"KeyPairGenerator kpg = KeyPairGenerator.getInstance(""RSA"");
kpg.initialize(2048);
KeyPair keyPair = kpg.generateKeyPair();
PublicKey pub = keyPair.getPublic();
PrivateKey prv = keyPair.getPrivate();

byte[] pubBytes = pub.getEncoded();
byte[] prvBytes = prv.getEncoded();

// now save pubBytes or prvBytes

// to recover the key",3
20066617,0,"IvParameterSpec ivs=new IvParameterSpec(iv);
Cipher cps=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cps.init(Cipher.ENCRYPT_MODE,spec,ivs);
byte[] iv2=cps.doFinal(s.getBytes());",2
20097247,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.v(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }",4
20179803,9,"        public class Crypto {

           private static final String engine = ""AES"";
           private static final String crypto = ""AES/CBC/PKCS5Padding"";
           private static Context ctx;
           public Crypto(Context cntx) {
             ctx = cntx;
           }

           public byte[] cipher(byte[] data, int mode) throws NoSuchAlgorithmException,NoSuchPaddingException,InvalidKeyException,IllegalBlockSizeException,BadPaddingException,InvalidAlgorithmParameterException {
             KeyManager km = new KeyManager(ctx);
             SecretKeySpec sks = new SecretKeySpec(km.getId(), engine);
             IvParameterSpec iv = new IvParameterSpec(km.getIv());
             Cipher c = Cipher.getInstance(crypto);
             c.init(mode, sks, iv);
             return c.doFinal(data);
           }

           public byte[] encrypt(byte[] data) throws InvalidKeyException,
        NoSuchAlgorithmException, NoSuchPaddingException,
        IllegalBlockSizeException, BadPaddingException,
        InvalidAlgorithmParameterException {
             return cipher(data, Cipher.ENCRYPT_MODE);
           }

           public byte[] decrypt(byte[] data) throws InvalidKeyException,
        NoSuchAlgorithmException, NoSuchPaddingException,
        IllegalBlockSizeException, BadPaddingException,
        InvalidAlgorithmParameterException {
             return cipher(data, Cipher.DECRYPT_MODE);
           }

        public String armorEncrypt(byte[] data) throws InvalidKeyException,NoSuchAlgorithmException,
    NoSuchPaddingException,IllegalBlockSizeException,
    BadPaddingException,InvalidAlgorithmParameterException {
                 return Base64.encodeToString(encrypt(data), Base64.DEFAULT);
               }

         public String armorDecrypt(String data) throws InvalidKeyException,NoSuchAlgorithmException,
    NoSuchPaddingException,IllegalBlockSizeException,
    BadPaddingException,InvalidAlgorithmParameterException {
                 return new String(decrypt(Base64.decode(data, Base64.DEFAULT)));
               }
}",2
20188768,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"",
                    Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
20192606,0,"ContentSigner getCertSigner(PrivateKey issuerKey) {
  AsymmetricKeyParameter akp = PrivateKeyFactory.createKey(issuerKey.getEncoded());
  AlgorithmIdentifier sigAlgId = new DefaultSignatureAlgorithmIdentifierFinder().find(""SHA1withRSA"");
  AlgorithmIdentifier digAlgId = new DefaultDigestAlgorithmIdentifierFinder().find(sigAlgId);
  return new BcRSAContentSignerBuilder(sigAlgId, digAlgId).build(akp);
}
",3
20212056,0,"IvParameterSpec ivSpec = new IvParameterSpec(iv);   

// encrypt
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);
byte[] ciphertext = cipher.doFinal(plaintext);

// copy to result",2
20262338,0,"                DocumentBuilderFactory dbf = DocumentBuilderFactory
                        .newInstance();
                DocumentBuilder db = dbf.newDocumentBuilder();
                Document doc = db.parse(new InputSource(url.openStream()));

                doc.getDocumentElement().normalize();

                NodeList nodeList = doc.getElementsByTagName(""GoldQuotes"");

                for (int i = 0; i < nodeList.getLength(); i++) {

                    Node node = nodeList.item(i);

                    Element fstElmnt = (Element) node;
                    NodeList nameList = fstElmnt.getElementsByTagName(""Price"");
                    Element nameElement = (Element) nameList.item(0);
                    nameList = nameElement.getChildNodes();",-1
20269941,2,"        public Builder setCharsetName(String charsetName) {
            mCharsetName = charsetName;
            return this;
        }

        /**
         * @return the algorithm
         */
        private String getAlgorithm() {
            return mAlgorithm;
        }

        /**
         * @param algorithm the algorithm to be used
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setAlgorithm(String algorithm) {
            mAlgorithm = algorithm;
            return this;
        }

        /**
         * @return the key algorithm
         */
        private String getKeyAlgorithm() {
            return mKeyAlgorithm;
        }

        /**
         * @param keyAlgorithm the keyAlgorithm to be used in keys
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setKeyAlgorithm(String keyAlgorithm) {
            mKeyAlgorithm = keyAlgorithm;
            return this;
        }

        /**
         * @return the Base 64 mode
         */
        private int getBase64Mode() {
            return mBase64Mode;
        }

        /**
         * @param base64Mode set the base 64 mode
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setBase64Mode(int base64Mode) {
            mBase64Mode = base64Mode;
            return this;
        }

        /**
         * @return the type of aes key that will be created, on KITKAT+ the API has changed, if you
         * are getting problems please @see <a href=""http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html"">http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html</a>
         */
        private String getSecretKeyType() {
            return mSecretKeyType;
        }

        /**
         * @param secretKeyType the type of AES key that will be created, on KITKAT+ the API has
         *                      changed, if you are getting problems please @see <a href=""http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html"">http://android-developers.blogspot.com.br/2013/12/changes-to-secretkeyfactory-api-in.html</a>
         *
         * @return this instance to follow the Builder patter
         */",2
20269941,2,"        public Builder setSecretKeyType(String secretKeyType) {
            mSecretKeyType = secretKeyType;
            return this;
        }

        /**
         * @return the value used for salting
         */
        private String getSalt() {
            return mSalt;
        }

        /**
         * @param salt the value used for salting
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setSalt(String salt) {
            mSalt = salt;
            return this;
        }

        /**
         * @return the key
         */
        private String getKey() {
            return mKey;
        }

        /**
         * @param key the key.
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setKey(String key) {
            mKey = key;
            return this;
        }

        /**
         * @return the length of key
         */
        private int getKeyLength() {
            return mKeyLength;
        }

        /**
         * @param keyLength the length of key
         *
         * @return this instance to follow the Builder patter
         */
        public Builder setKeyLength(int keyLength) {
            mKeyLength = keyLength;
            return this;
        }

        /**
         * @return the number of times the password is hashed
         */
        private int getIterationCount() {
            return mIterationCount;
        }

        /**
         * @param iterationCount the number of times the password is hashed
         *
         * @return this instance to follow the Builder patter
         */",2
20322250,2,"public final class PubKeyManager implements X509TrustManager
{
  private static String PUB_KEY = ""30820122300d06092a864886f70d0101"" +
    ""0105000382010f003082010a0282010100b35ea8adaf4cb6db86068a836f3c85"" +
    ""5a545b1f0cc8afb19e38213bac4d55c3f2f19df6dee82ead67f70a990131b6bc"" +
    ""ac1a9116acc883862f00593199df19ce027c8eaaae8e3121f7f329219464e657"" +
    ""2cbf66e8e229eac2992dd795c4f23df0fe72b6ceef457eba0b9029619e0395b8"" +
    ""609851849dd6214589a2ceba4f7a7dcceb7ab2a6b60c27c69317bd7ab2135f50"" +
    ""c6317e5dbfb9d1e55936e4109b7b911450c746fe0d5d07165b6b23ada7700b00"" +
    ""33238c858ad179a82459c4718019c111b4ef7be53e5972e06ca68a112406da38"" +
    ""cf60d2f4fda4d1cd52f1da9fd6104d91a34455cd7b328b02525320a35253147b"" +
    ""e0b7a5bc860966dc84f10d723ce7eed5430203010001"";

  public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException
  {
    if (chain == null) {
      throw new IllegalArgumentException(""checkServerTrusted: X509Certificate array is null"");
    }

    if (!(chain.length > 0)) {
      throw new IllegalArgumentException(""checkServerTrusted: X509Certificate is empty"");
    }

    if (!(null != authType && authType.equalsIgnoreCase(""RSA""))) {
      throw new CertificateException(""checkServerTrusted: AuthType is not RSA"");
    }

    // Perform customary SSL/TLS checks
    try {
      TrustManagerFactory tmf = TrustManagerFactory.getInstance(""X509"");
      tmf.init((KeyStore) null);

      for (TrustManager trustManager : tmf.getTrustManagers()) {
        ((X509TrustManager) trustManager).checkServerTrusted(chain, authType);
      }
    } catch (Exception e) {
      throw new CertificateException(e);
    }

    // Hack ahead: BigInteger and toString(). We know a DER encoded Public Key begins
    // with 0x30 (ASN.1 SEQUENCE and CONSTRUCTED), so there is no leading 0x00 to drop.
    RSAPublicKey pubkey = (RSAPublicKey) chain[0].getPublicKey();
    String encoded = new BigInteger(1 /* positive */, pubkey.getEncoded()).toString(16);

    // Pin it!
    final boolean expected = PUB_KEY.equalsIgnoreCase(encoded);
    if (!expected) {
      throw new CertificateException(""checkServerTrusted: Expected public key: ""
                + PUB_KEY + "", got public key:"" + encoded);
      }
    }
  }",1
20325704,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }",4
20416502,0,"        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
            return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
        }

        @Override
        public Socket createSocket() throws IOException {
            return sslContext.getSocketFactory().createSocket();
        }",1
20416561,0,"        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
            return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
        }

        @Override
        public Socket createSocket() throws IOException {
            return sslContext.getSocketFactory().createSocket();
        }",1
20457991,0,"        cipher.init(true, new KeyParameter(key));
        byte[] rv = new byte[cipher.getOutputSize(ptBytes.length)];
        int tam = cipher.processBytes(ptBytes, 0, ptBytes.length, rv, 0);",2
20457991,0,"        cipher.init(false, new KeyParameter(key));
        byte[] rv = new byte[cipher.getOutputSize(cipherText.length)];
        int tam = cipher.processBytes(cipherText, 0, cipherText.length, rv, 0);",2
20509628,0,"        Cipher cipher=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] keyBytes=md.digest((KeyPart1+KeyPart2).getBytes());
        keyBytes = Arrays.copyOf(keyBytes, 16);
        SecretKey key= new SecretKeySpec(keyBytes,""AES"");
        IvParameterSpec ivSpec = new IvParameterSpec(new byte[] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0});
        cipher.init(Cipher.ENCRYPT_MODE,key,ivSpec);
        byte[] outBytes = new byte[cipher.getOutputSize(inBytes.length)];
        //cipher.update(encrypted, 0, encrypted.length, decrypted, 0);
        outBytes=cipher.doFinal(inBytes);",24
20509628,0,"        Cipher cipher=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        MessageDigest md = MessageDigest.getInstance(""SHA-1"");
        byte[] keyBytes=md.digest((KeyPart1+KeyPart2).getBytes());
        keyBytes = Arrays.copyOf(keyBytes, 16);
        SecretKey key= new SecretKeySpec(keyBytes,""AES"");
        IvParameterSpec ivSpec = new IvParameterSpec(new byte[] {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0});
        cipher.init(Cipher.DECRYPT_MODE,key,ivSpec);
        byte[] decrypted = new byte[cipher.getOutputSize(encrypted.length)];
        //cipher.update(encrypted, 0, encrypted.length, decrypted, 0);
        decrypted=cipher.doFinal(encrypted);",24
20513679,0,"        X509Certificate[] chain = tm.chain;
        if (chain == null) {
            System.out.println(""Could not obtain server certificate chain"");
            return;
        }

        BufferedReader reader =
                new BufferedReader(new InputStreamReader(System.in));

        System.out.println();
        System.out.println(""Server sent "" + chain.length + "" certificate(s):"");
        System.out.println();
        MessageDigest sha1 = MessageDigest.getInstance(""SHA1"");
        MessageDigest md5 = MessageDigest.getInstance(""MD5"");
        for (int i = 0; i < chain.length; i++) {
            X509Certificate cert = chain[i];
            System.out.println
                ("" "" + (i + 1) + "" Subject "" + cert.getSubjectDN());
            System.out.println(""   Issuer  "" + cert.getIssuerDN());
            sha1.update(cert.getEncoded());
            System.out.println(""   sha1    "" + toHexString(sha1.digest()));
            md5.update(cert.getEncoded());
            System.out.println(""   md5     "" + toHexString(md5.digest()));
            System.out.println();
        }

        System.out.println(""Enter certificate to add to trusted keystore or 'q' to quit: [1]"");
        String line = reader.readLine().trim();
        int k;
        try {
            k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;
        } catch (NumberFormatException e) {
            System.out.println(""KeyStore not changed"");
            return;
        }

        X509Certificate cert = chain[k];
        String alias = host + ""-"" + (k + 1);
        ks.setCertificateEntry(alias, cert);
",4
20513679,0,"    private static String toHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 3);
        for (int b : bytes) {
            b &= 0xff;
            sb.append(HEXDIGITS[b >> 4]);
            sb.append(HEXDIGITS[b & 15]);
            sb.append(' ');
        }
        return sb.toString();
    }

    private static class SavingTrustManager implements X509TrustManager {

        private final X509TrustManager tm;
        private X509Certificate[] chain;

        SavingTrustManager(X509TrustManager tm) {
            this.tm = tm;
        }

        public X509Certificate[] getAcceptedIssuers() {
            throw new UnsupportedOperationException();
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }
    }
",1
20513679,0,"        public void checkClientTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }",1
20535447,0,"          CipherOutputStream cos = new CipherOutputStream(fos, cipher);
          // Write bytes
          int b;
          byte[] d = new byte[8];
          while ((b = fis.read(d)) != -1) {
                 cos.write(d, 0, b);
          }
          // Flush and close streams.
          cos.flush();
          cos.close();
          fis.close();",2
20535447,0,"          CipherInputStream cis = new CipherInputStream(fis, cipher);
          int b;
          byte[] d = new byte[8];
          while ((b = cis.read(d)) != -1) {
                 fos.write(d, 0, b);
          }
          fos.flush();
          fos.close();
          cis.close();",2
20535447,0,"          CipherInputStream cis = new CipherInputStream(fis, cipher);
          int b;
          byte[] d = new byte[8];
          while ((b = cis.read(d)) != -1) {
                 fos.write(d, 0, b);
          }
          fos.flush();
          fos.close();
          cis.close();",2
20578096,0,"kp = mcElieceKeyPairGenerator.generateKeyPair();

final byte[] publicKeyData = kp.getPublic().getEncoded(); 
X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(publicKeyData);
KeyFactory mcElieceKeyFactory = KeyFactory.getInstance(""McEliece"");
PublicKey regeneratedPublicKey = mcElieceKeyFactory.generatePublic(publicKeySpec);
",4
20609314,0,"String hash;
try {
    hash = new BASE64Encoder().encode(MessageDigest.getInstance(""SHA-1"").digest((keys.get(""Sec-WebSocket-Key"") + ""258EAFA5-E914-47DA-95CA-C5AB0DC85B11"").getBytes()));
} catch (NoSuchAlgorithmException ex) {
    ex.printStackTrace();
    return false;
}

//Write handshake response",4
20613068,2,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
20655345,0,"                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    Log.i(""PXR"", com.domain.Base64.encodeBytes(md.digest()));
                }",4
20661442,0,"        X509Certificate[] chain = tm.chain;
        if (chain == null) {
            System.out.println(""Could not obtain server certificate chain"");
            return;
        }

        BufferedReader reader =
                new BufferedReader(new InputStreamReader(System.in));

        System.out.println();
        System.out.println(""Server sent "" + chain.length + "" certificate(s):"");
        System.out.println();
        MessageDigest sha1 = MessageDigest.getInstance(""SHA1"");
        MessageDigest md5 = MessageDigest.getInstance(""MD5"");
        for (int i = 0; i < chain.length; i++) {
            X509Certificate cert = chain[i];
            System.out.println
                    ("" "" + (i + 1) + "" Subject "" + cert.getSubjectDN());
            System.out.println(""   Issuer  "" + cert.getIssuerDN());
            sha1.update(cert.getEncoded());
            System.out.println(""   sha1    "" + toHexString(sha1.digest()));
            md5.update(cert.getEncoded());
            System.out.println(""   md5     "" + toHexString(md5.digest()));
            System.out.println();
        }

        System.out.println(""Enter certificate to add to trusted keystore or 'q' to quit: [1]"");
        String line = reader.readLine().trim();
        int k;
        try {
            k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;
        } catch (NumberFormatException e) {
            System.out.println(""KeyStore not changed"");
            return;
        }

        X509Certificate cert = chain[k];
        String alias = host + ""-"" + (k + 1);
        ks.setCertificateEntry(alias, cert);
",4
20661442,0,"    private static String toHexString(byte[] bytes) {
        StringBuilder sb = new StringBuilder(bytes.length * 3);
        for (int b : bytes) {
            b &= 0xff;
            sb.append(HEXDIGITS[b >> 4]);
            sb.append(HEXDIGITS[b & 15]);
            sb.append(' ');
        }
        return sb.toString();
    }

    private static class SavingTrustManager implements X509TrustManager {

        private final X509TrustManager tm;
        private X509Certificate[] chain;

        SavingTrustManager(X509TrustManager tm) {
            this.tm = tm;
        }

        public X509Certificate[] getAcceptedIssuers() {
            throw new UnsupportedOperationException();
        }

        public void checkClientTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }
    }
",1
20661442,0,"        public void checkClientTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }",1
20667350,0,"            OutputStreamWriter osw;

            if (encryptionIsOn) {
                Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
                SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, ""AES"");
                IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);
                cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);

                FileOutputStream fos = new FileOutputStream(file);
                CipherOutputStream cos = new CipherOutputStream(fos, cipher);
                osw = new OutputStreamWriter(cos, ""UTF-8"");
            }
            else    // not encryptionIsOn
                osw = new FileWriter(file);

            BufferedWriter out = new BufferedWriter(osw);",2
20667350,0,"            InputStreamReader isr;

            if (encryptionIsOn) {
                Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
                SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, ""AES"");
                IvParameterSpec ivParameterSpec = new IvParameterSpec(keyBytes);
                cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivParameterSpec);

                FileInputStream fis = new FileInputStream(file);
                CipherInputStream cis = new CipherInputStream(fis, cipher);
                isr = new InputStreamReader(cis, ""UTF-8"");
            }
            else
                isr = new FileReader(file);

            BufferedReader in = new BufferedReader(isr);",2
20708800,3,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
                    throws IOException {
        SSLSocket s = (SSLSocket)mSSLContext.getSocketFactory().createSocket(socket, host, port, autoClose);
        s.setEnabledProtocols(new String[] {""TLSv1.2""} );
        return s;
    }
",1
20744367,0,"        if (secretKey == null || secretKey.length() != 8)
            throw new Exception(""Invalid key length - 8 bytes key needed!"");

        SecretKey key = new SecretKeySpec(secretKey.getBytes(), ALGORITHM);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, key);
",2
20744367,0,"        if (secretKey == null || secretKey.length() != 8)
            throw new Exception(""Invalid key length - 8 bytes key needed!"");

        SecretKey key = new SecretKeySpec(secretKey.getBytes(), ALGORITHM);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, key);
",2
20759426,0,"            Key key = generateKey();
            Cipher chiper = Cipher.getInstance(algorithm);
            chiper.init(Cipher.ENCRYPT_MODE, key);
            byte[] encVal = chiper.doFinal(plainText.getBytes());",2
20759426,0,"    public static String decrypt(String encryptedText) throws Exception 
    {
            // generate key 
            Key key = generateKey();
            Cipher chiper = Cipher.getInstance(algorithm);
            chiper.init(Cipher.DECRYPT_MODE, key);
            byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedText);
            byte[] decValue = chiper.doFinal(decordedValue);
            String decryptedValue = new String(decValue);
            return decryptedValue;
    }

//generateKey() is used to generate a secret key for AES algorithm
    private static Key generateKey() throws Exception 
    {
            Key key = new SecretKeySpec(keyValue, algorithm);
            return key;
    }

    // performs encryption & decryption ",2
20759426,0,"            Cipher chiper = Cipher.getInstance(algorithm);
            chiper.init(Cipher.DECRYPT_MODE, key);
            byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedText);
            byte[] decValue = chiper.doFinal(decordedValue);",2
20759555,0,"    byte[] data = new byte[32];
    int i;

    System.out.println(""start encyption"");
    Key pubKey = readKeyFromFile(""public.key"");
    Cipher cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.ENCRYPT_MODE, pubKey);

    FileInputStream fileIn = new FileInputStream(file_loc);",3
20759555,0,"    byte[] data = new byte[32];
    int i;

    System.out.println(""start decyption"");

    Key priKey = readKeyFromFile(""private.key"");
    Cipher cipher = Cipher.getInstance(""RSA"");
    cipher.init(Cipher.DECRYPT_MODE, priKey);

    FileInputStream fileIn = new FileInputStream(file_loc);",3
20789379,4,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
20809005,2,"public class sample{
 public void foo(){
PBKDF_SecretKeyFactory kf = new PBKDF_SecretKeyFactory(""HmacSHA512"");
KeySpec ks = new PBEKeySpec(password,salt,iterations,bitlen);
byte key[] = kf.engineGenerateSecret(ks).getEncoded();

}",2
20897153,1,"KeyStore ks = KeyStore.getInstance(""pkcs12"");
ks.load(new FileInputStream(file), password.toCharArray());
Enumeration<String> enumeration = ks.aliases();",3
20905695,0,"                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(),
                            Base64.DEFAULT));
                }",4
20929131,0,"    {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception
    {
        if(text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)
        {           
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;
    }
",2
20929131,0,"    {
        ivspec = new IvParameterSpec(iv.getBytes());

        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public byte[] encrypt(String text) throws Exception
    {
        if(text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)
        {           
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;
    }

    public byte[] decrypt(String code) throws Exception
    {
        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)
        {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }



    public static String bytesToHex(byte[] data)
    {
        if (data==null)
        {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i=0; i<len; i++) {
            if ((data[i]&0xFF)<16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i]&0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        } else if (str.length() < 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i<len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            }
            return buffer;
        }
    }



    private static String padString(String source)
    {
      char paddingChar = ' ';
      int size = 16;
      int x = source.length() % size;
      int padLength = size - x;

      for (int i = 0; i < padLength; i++)
      {
          source += paddingChar;
      }

      return source;
    }",2
20929131,0,"        keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");

        try {
            cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }",2
20929131,0,"        if(text == null || text.length() == 0)
            throw new Exception(""Empty string"");

        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)",2
20929131,0,"        byte[] encrypted = null;

        try {
            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

            encrypted = cipher.doFinal(padString(text).getBytes());
        } catch (Exception e)
        {           
            throw new Exception(""[encrypt] "" + e.getMessage());
        }

        return encrypted;",2
20929131,0,"    public byte[] decrypt(String code) throws Exception
    {
        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)
        {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }



    public static String bytesToHex(byte[] data)
    {
        if (data==null)
        {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i=0; i<len; i++) {
            if ((data[i]&0xFF)<16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i]&0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        } else if (str.length() < 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i<len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            }
            return buffer;
        }
    }


",2
20929131,0,"        if(code == null || code.length() == 0)
            throw new Exception(""Empty string"");

        byte[] decrypted = null;

        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)",2
20929131,0,"        try {
            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            decrypted = cipher.doFinal(hexToBytes(code));
        } catch (Exception e)
        {
            throw new Exception(""[decrypt] "" + e.getMessage());
        }
        return decrypted;
    }



    public static String bytesToHex(byte[] data)
    {
        if (data==null)
        {
            return null;
        }

        int len = data.length;
        String str = """";
        for (int i=0; i<len; i++) {
            if ((data[i]&0xFF)<16)
                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
            else
                str = str + java.lang.Integer.toHexString(data[i]&0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
        if (str==null) {
            return null;
        } else if (str.length() < 2) {
            return null;
        } else {
            int len = str.length() / 2;
            byte[] buffer = new byte[len];
            for (int i=0; i<len; i++) {
                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
            }
            return buffer;
        }
    }



    private static String padString(String source)
    {
      char paddingChar = ' ';
      int size = 16;
      int x = source.length() % size;
      int padLength = size - x;

      for (int i = 0; i < padLength; i++)
      {
          source += paddingChar;
      }

      return source;
    }",2
20935751,1,"    keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");                        
    try {            
        cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
    } catch (NoSuchAlgorithmException e) {
         e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    }",2
20935751,1,"public byte[] decrypt(String code) throws Exception{
    if(code == null || code.length() == 0)  throw new Exception(""Empty string"");        
    byte[] decrypted = null;
    try {
        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);                
        decrypted = cipher.doFinal(hexToBytes(code));
    } catch (Exception e){
        throw new Exception(""[decrypt] "" + e.getMessage());
    }
    return decrypted;
}



    public static String bytesToHex(byte[] data){
        if (data==null){
            return null;
        }            
        int len = data.length;
        String str = """";
        for (int i=0; i<len; i++) {
            if ((data[i]&0xFF)<16)
                    str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
            else
                    str = str + java.lang.Integer.toHexString(data[i]&0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
            if (str==null) {
                    return null;
            } else if (str.length() < 2) {
                    return null;
            } else {
                    int len = str.length() / 2;
                    byte[] buffer = new byte[len];
                    for (int i=0; i<len; i++) {
                            buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
                    }
                    return buffer;
            }
    }


",2
20935751,1,"    if(code == null || code.length() == 0)  throw new Exception(""Empty string"");        
    byte[] decrypted = null;
    try {
        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);                
        decrypted = cipher.doFinal(hexToBytes(code));",2
20935751,1,"    try {
        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);                
        decrypted = cipher.doFinal(hexToBytes(code));
    } catch (Exception e){
        throw new Exception(""[decrypt] "" + e.getMessage());
    }
    return decrypted;
}



    public static String bytesToHex(byte[] data){
        if (data==null){
            return null;
        }            
        int len = data.length;
        String str = """";
        for (int i=0; i<len; i++) {
            if ((data[i]&0xFF)<16)
                    str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
            else
                    str = str + java.lang.Integer.toHexString(data[i]&0xFF);
        }
        return str;
    }


    public static byte[] hexToBytes(String str) {
            if (str==null) {
                    return null;
            } else if (str.length() < 2) {
                    return null;
            } else {
                    int len = str.length() / 2;
                    byte[] buffer = new byte[len];
                    for (int i=0; i<len; i++) {
                            buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
                    }
                    return buffer;
            }
    }


",2
20936188,4,"    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    // NOTE: last argument is the key length, and it is 128
    KeySpec spec = new PBEKeySpec(password, salt, 1024, 128);
    SecretKey tmp = factory.generateSecret(spec);
    SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
    return(secret);",2
20983857,2,"public final class PubKeyManager implements X509TrustManager
{
  private static String PUB_KEY = ""30820122300d06092a864886f70d0101..."";

  public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException
  {
    if (chain == null) {
      throw new IllegalArgumentException(""checkServerTrusted: X509Certificate array is null"");
    }

    if (!(chain.length > 0)) {
      throw new IllegalArgumentException(""checkServerTrusted: X509Certificate is empty"");
    }

    if (!(null != authType && authType.equalsIgnoreCase(""RSA""))) {
      throw new CertificateException(""checkServerTrusted: AuthType is not RSA"");
    }

    // Perform customary SSL/TLS checks
    try {
      TrustManagerFactory tmf = TrustManagerFactory.getInstance(""X509"");
      tmf.init((KeyStore) null);

      for (TrustManager trustManager : tmf.getTrustManagers()) {
        ((X509TrustManager) trustManager).checkServerTrusted(chain, authType);
      }
    } catch (Exception e) {
      throw new CertificateException(e);
    }

    // Hack ahead: BigInteger and toString(). We know a DER encoded Public Key begins
    // with 0x30 (ASN.1 SEQUENCE and CONSTRUCTED), so there is no leading 0x00 to drop.
    RSAPublicKey pubkey = (RSAPublicKey) chain[0].getPublicKey();
    String encoded = new BigInteger(1 /* positive */, pubkey.getEncoded()).toString(16);

    // Pin it!
    final boolean expected = PUB_KEY.equalsIgnoreCase(encoded);
    if (!expected) {
      throw new CertificateException(""checkServerTrusted: Expected public key: ""
                + PUB_KEY + "", got public key:"" + encoded);
      }
    }
  }",1
20989370,0,"public Socket createSocket(Socket socket, String host, int port,
                           boolean autoClose) throws IOException, UnknownHostException {
    return sslContext.getSocketFactory().createSocket(socket, host, port,
            autoClose);
}

@Override
public Socket createSocket() throws IOException {
    return sslContext.getSocketFactory().createSocket();
}",1
20989370,3,"  private X509Certificate getCertFromFile(String path) throws Exception {
     AssetManager assetManager = MyActivity.this.getResources().getAssets();
     InputStream inputStream = null;
     try {
         inputStream = assetManager.open(path);
     } catch (IOException e) {
         e.printStackTrace();
     }
     InputStream caInput = new BufferedInputStream(inputStream);
     X509Certificate cert = null;
     CertificateFactory cf = CertificateFactory.getInstance(""X509"");
     cert = (X509Certificate) cf.generateCertificate(caInput);
     cert.getSerialNumber();
     return cert;
  }
",1
21039407,1,"        byte[] cipherText = cipher.doFinal(PlainText.getBytes(""UTF-8""));

        cyphertext = String.format(""%s%s%s"", toBase64(salt), ""]"",
                toBase64(cipherText));
        edit_txt_enc_string.setText(cyphertext);
        return cyphertext;",2
21039407,1,"        byte[] plaintxt = cipher.doFinal(cyphertext.getBytes(""UTF-8""));

        PlainText = String.format(""%s%s%s"", fromBase64(salt), ""]"",
                fromBase64(plaintxt));
        edit_txt_dec_string.setText(PlainText);
        return PlainText;",2
21050497,1,"        IvParameterSpec ivSpec = new IvParameterSpec(ivBytes);
        cipher.init(Cipher.ENCRYPT_MODE, SKey, ivSpec);

        byte[] cipherText = cipher.doFinal(PlainText.getBytes(""UTF-8""));

        cyphertext = Base64.encodeToString(cipherText, Base64.DEFAULT);",2
21070062,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
21155095,0,"public class sample{
public static byte[] encrypt(String value) {
        byte[] encrypted = null;
        try {

            byte[] raw = new byte[]{'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};
            Key skeySpec = new SecretKeySpec(raw, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            byte[] iv = new byte[cipher.getBlockSize()];

            IvParameterSpec ivParams = new IvParameterSpec(iv);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec,ivParams);
            encrypted  = cipher.doFinal(value.getBytes());
            System.out.println(""encrypted string:"" + encrypted.length);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return encrypted;
    }

    public static  byte[]  decrypt(byte[] encrypted) {
         byte[] original = null;
         Cipher cipher = null;
        try {
            byte[] raw = new byte[]{'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};
            Key key = new SecretKeySpec(raw, ""AES"");
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            //the block size (in bytes), or 0 if the underlying algorithm is not a block cipher
            byte[] ivByte = new byte[cipher.getBlockSize()];
            //This class specifies an initialization vector (IV). Examples which use
            //IVs are ciphers in feedback mode, e.g., DES in CBC mode and RSA ciphers with OAEP encoding operation.
            IvParameterSpec ivParamsSpec = new IvParameterSpec(ivByte);
            cipher.init(Cipher.DECRYPT_MODE, key, ivParamsSpec);
            original= cipher.doFinal(encrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return original;
    }  
",2
21155176,0,"public class sample{
public static byte[] encrypt(String value) {
        byte[] encrypted = null;
        try {

            byte[] raw = new byte[]{'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};
            Key skeySpec = new SecretKeySpec(raw, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            byte[] iv = new byte[cipher.getBlockSize()];

            IvParameterSpec ivParams = new IvParameterSpec(iv);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec,ivParams);
            encrypted  = cipher.doFinal(value.getBytes());
            System.out.println(""encrypted string:"" + encrypted.length);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return encrypted;
    }

    public static  byte[]  decrypt(byte[] encrypted) {
         byte[] original = null;
         Cipher cipher = null;
        try {
            byte[] raw = new byte[]{'T', 'h', 'i', 's', 'I', 's', 'A', 'S', 'e', 'c', 'r', 'e', 't', 'K', 'e', 'y'};
            Key key = new SecretKeySpec(raw, ""AES"");
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            //the block size (in bytes), or 0 if the underlying algorithm is not a block cipher
            byte[] ivByte = new byte[cipher.getBlockSize()];
            //This class specifies an initialization vector (IV). Examples which use
            //IVs are ciphers in feedback mode, e.g., DES in CBC mode and RSA ciphers with OAEP encoding operation.
            IvParameterSpec ivParamsSpec = new IvParameterSpec(ivByte);
            cipher.init(Cipher.DECRYPT_MODE, key, ivParamsSpec);
            original= cipher.doFinal(encrypted);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return original;
    }  
",2
21333739,0,"        byte[] array = md.digest(md5.getBytes());
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < array.length; ++i) {
          sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3));
       }
        return sb.toString();",4
21376275,0,"        public static void main(String[] args)throws Exception
        {
             File file = new File(""D:\\Android Links.txt"");
            String outputTxt= """";
            String hashcode = null;

            try {

                FileInputStream input = new FileInputStream(file);

                ByteArrayOutputStream output = new ByteArrayOutputStream ();
                byte [] buffer = new byte [65536];
                int l;

                while ((l = input.read (buffer)) > 0)
                    output.write (buffer, 0, l);

                input.close ();
                output.close ();

                byte [] data = output.toByteArray ();


                    MessageDigest digest = MessageDigest.getInstance( ""SHA-1"" ); 

                byte[] bytes = data;

                digest.update(bytes, 0, bytes.length);
                bytes = digest.digest();

                StringBuilder sb = new StringBuilder();

                for( byte b : bytes )
                {
                    sb.append( String.format(""%02X"", b) );
                }

                    System.out.println(""Digest(in hex format):: "" + sb.toString());


            }catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
",4
21376275,0,"                FileInputStream input = new FileInputStream(file);

                ByteArrayOutputStream output = new ByteArrayOutputStream ();
                byte [] buffer = new byte [65536];
                int l;

                while ((l = input.read (buffer)) > 0)
                    output.write (buffer, 0, l);

                input.close ();
                output.close ();

                byte [] data = output.toByteArray ();


                    MessageDigest digest = MessageDigest.getInstance( ""SHA-1"" ); 

                byte[] bytes = data;

                digest.update(bytes, 0, bytes.length);
                bytes = digest.digest();

                StringBuilder sb = new StringBuilder();

                for( byte b : bytes )
                {
                    sb.append( String.format(""%02X"", b) );
                }
",4
21376847,0,"        public static void main(String[] args)throws Exception
        {
             File file = new File(""D:\\Android Links.txt"");
            String outputTxt= """";
            String hashcode = null;

            try {

                FileInputStream input = new FileInputStream(file);

                ByteArrayOutputStream output = new ByteArrayOutputStream ();
                byte [] buffer = new byte [65536];
                int l;

                while ((l = input.read (buffer)) > 0)
                    output.write (buffer, 0, l);

                input.close ();
                output.close ();

                byte [] data = output.toByteArray ();


                    MessageDigest digest = MessageDigest.getInstance( ""SHA-1"" ); 

                byte[] bytes = data;

                digest.update(bytes, 0, bytes.length);
                bytes = digest.digest();

                StringBuilder sb = new StringBuilder();

                for( byte b : bytes )
                {
                    sb.append( String.format(""%02X"", b) );
                }

                    System.out.println(""Digest(in hex format):: "" + sb.toString());


            }catch (FileNotFoundException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
",4
21376847,0,"                FileInputStream input = new FileInputStream(file);

                ByteArrayOutputStream output = new ByteArrayOutputStream ();
                byte [] buffer = new byte [65536];
                int l;

                while ((l = input.read (buffer)) > 0)
                    output.write (buffer, 0, l);

                input.close ();
                output.close ();

                byte [] data = output.toByteArray ();


                    MessageDigest digest = MessageDigest.getInstance( ""SHA-1"" ); 

                byte[] bytes = data;

                digest.update(bytes, 0, bytes.length);
                bytes = digest.digest();

                StringBuilder sb = new StringBuilder();

                for( byte b : bytes )
                {
                    sb.append( String.format(""%02X"", b) );
                }
",4
21411130,4,"Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());

byte[] input = new byte[] { (byte) 0xbe, (byte) 0xef };
Cipher cipher = Cipher.getInstance(""RSA/None/NoPadding"", ""BC"");

KeyFactory keyFactory = KeyFactory.getInstance(""RSA"", ""BC"");
RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(
    ""12345678"", 16), new BigInteger(""11"", 16));
RSAPrivateKeySpec privKeySpec = new RSAPrivateKeySpec(new BigInteger(
    ""12345678"", 16), new BigInteger(""12345678"",
    16));

RSAPublicKey pubKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);
RSAPrivateKey privKey = (RSAPrivateKey) keyFactory.generatePrivate(privKeySpec);

cipher.init(Cipher.ENCRYPT_MODE, pubKey);
",3
21496467,0,"    public static String encrypt(String seed, String cleartext) throws Exception {

        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext.getBytes());
        String fromHex = toHex(result);
        String base64 = new String(Base64.encodeToString(fromHex.getBytes(), 0));
        return base64;
    }     

    public static String decrypt(String seed, String encrypted) throws Exception {

        byte[] seedByte = seed.getBytes();
        System.arraycopy(seedByte, 0, key, 0, ((seedByte.length < 16) ? seedByte.length : 16));
        String base64 = new String(Base64.decode(encrypted, 0));
        byte[] rawKey = getRawKey(seedByte);
        byte[] enc = toByte(base64);
        byte[] result = decrypt(rawKey, enc);
        return new String(result);
    }

    public static byte[] encryptBytes(String seed, byte[] cleartext) throws Exception {

        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = encrypt(rawKey, cleartext);
        return result;
    }


    public static byte[] decryptBytes(String seed, byte[] encrypted) throws Exception {

        byte[] rawKey = getRawKey(seed.getBytes());
        byte[] result = decrypt(rawKey, encrypted);
        return result;

    }

    private static byte[] getRawKey(byte[] seed) throws Exception {

        KeyGenerator kgen = KeyGenerator.getInstance(""AES""); // , ""SC"");
        SecureRandom sr = null;
        if (android.os.Build.VERSION.SDK_INT >= JELLY_BEAN_4_2) {
         sr = SecureRandom.getInstance(""SHA1PRNG"", ""Crypto"");
        } else {
         sr = SecureRandom.getInstance(""SHA1PRNG"");
        }
        sr.setSeed(seed);
        try {
         kgen.init(256, sr);
         // kgen.init(128, sr);
        } catch (Exception e) {
         // Log.w(LOG, ""This device doesn't suppor 256bits, trying 192bits."");
         try {
          kgen.init(192, sr);
         } catch (Exception e1) {
          // Log.w(LOG, ""This device doesn't suppor 192bits, trying 128bits."");
          kgen.init(128, sr);
         }
       }
        SecretKey skey = kgen.generateKey();
        byte[] raw = skey.getEncoded();
        return raw;
    }
    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {

        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES""); // /ECB/PKCS7Padding"", ""SC"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }

    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {

        SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
        Cipher cipher = Cipher.getInstance(""AES""); // /ECB/PKCS7Padding"", ""SC"");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }

    public static String toHex(String txt) {
        return toHex(txt.getBytes());
    }

    public static String fromHex(String hex) {

        return new String(toByte(hex));
    }


    public static byte[] toByte(String hexString) {

        int len = hexString.length() / 2;
        byte[] result = new byte[len];
        for (int i = 0; i < len; i++)
            result[i] = Integer.valueOf(hexString.substring(2 * i, 2 * i + 2), 16).byteValue();
        return result;
    }


    public static String toHex(byte[] buf) {

        if (buf == null)
            return """";
        StringBuffer result = new StringBuffer(2 * buf.length);
        for (int i = 0; i < buf.length; i++) {
            appendHex(result, buf[i]);
        }
        return result.toString();
    }

    private static void appendHex(StringBuffer sb, byte b) {
        sb.append(HEX.charAt((b >> 4) & 0x0f)).append(HEX.charAt(b & 0x0f));
    }
",5
21517697,0,"byte[] dataBytes = new byte[1024];

int nread = 0; 
while ((nread = fis.read(dataBytes)) != -1) {
  md.update(dataBytes, 0, nread);
};
byte[] mdbytes = md.digest();

//Convert ""mdbytes"" to hex String:
StringBuffer hexString = new StringBuffer();",4
21517697,0,"byte[] mdbytes = md.digest();

//Convert ""mdbytes"" to hex String:
StringBuffer hexString = new StringBuffer();
for (int i=0;i<mdbytes.length;i++) {
  hexString.append(Integer.toHexString(0xFF & mdbytes[i]));
}

return hexString.toString();
",4
21517697,0,"byte[] mdbytes = md.digest();

//Convert ""mdbytes"" to hex String:
StringBuffer hexString = new StringBuffer();
for (int i=0;i<mdbytes.length;i++) {
  hexString.append(Integer.toHexString(0xFF & mdbytes[i]));
}
",4
21517697,0,"byte[] mdbytes = md.digest();

//Convert ""mdbytes"" to hex String:
StringBuffer hexString = new StringBuffer();
for (int i=0;i<mdbytes.length;i++) {
  hexString.append(Integer.toHexString(0xFF & mdbytes[i]));
}

return hexString.toString();
",4
21517697,1,"MessageDigest md = MessageDigest.getInstance(""SHA-256"");
md.update(password.getBytes());

byte byteData[] = md.digest();

//Convert ""byteData"" to hex String:
StringBuffer sb = new StringBuffer();
for (int i = 0; i < byteData.length; i++) {
    sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));
}

return sb.toString();
",4
21565874,0,"Pkcs5S2ParametersGenerator kdf = new Pkcs5S2ParametersGenerator();
kdf.init(passwordToSave.getBytes(""UTF-8""), salt, iterations);

byte[] hash =
    ((KeyParameter) kdf.generateDerivedMacParameters(8*hashBytes)).getKey();

// now save salt and hash

// to check a password, given the known previous salt and hash:
",2
21565874,0,"kdf = new Pkcs5S2ParametersGenerator();
kdf.init(passwordToCheck.getBytes(""UTF-8""), salt, iterations);

byte[] hashToCheck =
    ((KeyParameter) kdf.generateDerivedMacParameters(8*hashBytes)).getKey();

// if the bytes of hashToCheck don't match the bytes of hash
// that means the password is invalid
",2
21609678,0,"        rnd.nextBytes(IV);
        IvParameterSpec IVSpec = new IvParameterSpec(IV);

        //Create the cipher object to perform AES operations.
        //Specify Advanced Encryption Standard - Cipher Feedback Mode - No Padding
        Cipher AESCipher = Cipher.getInstance(""AES/CFB/NoPadding"");

        //Initialize the Cipher with the key and initialization vector.
        AESCipher.init(Cipher.ENCRYPT_MODE, key, IVSpec);

        //Encrypts the plaintext data",2
21609678,0,"        IvParameterSpec IVSpec = new IvParameterSpec(IV);

        //Create the cipher object to perform AES operations.
        //Specify Advanced Encryption Standard - Cipher Feedback Mode - No Padding
        Cipher AESCipher = Cipher.getInstance(""AES/CFB/NoPadding"");

        //Initialize the Cipher with the key and initialization vector.
        AESCipher.init(Cipher.ENCRYPT_MODE, key, IVSpec);

        //Encrypts the plaintext data
        byte[] ciphertext = AESCipher.doFinal(plaintext);

       /*
        * The IV must now be transferred with the ciphertext somehow. The easiest 
        * way to accomplish this would be to prepend the IV to the ciphertext 
        * message.
        */

        //Allocate new array to hold ciphertext + IV",2
21628540,0,"        SecretKeySpec sks = new SecretKeySpec(""yourkey"".getBytes(), ""AES"");
        // Create cipher
        Cipher cipher = Cipher.getInstance(""AES/CBC"");
        cipher.init(Cipher.ENCRYPT_MODE, sks);
        // Wrap the output stream
        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        // Write bytes
        int b;
        byte[] d = new byte[8];",2
21628540,0,"        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        // Write bytes
        int b;
        byte[] d = new byte[8];
        while ((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }
        // Flush and close streams.
        cos.flush();
        cos.close();
        fis.close();",2
21628540,1,"public class sample{
public  void decrypt() throws IOException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException {
        FileInputStream fis = new FileInputStream(""data/encrypted"");

        FileOutputStream fos = new FileOutputStream(""data/decrypted"");
        SecretKeySpec sks = new SecretKeySpec(""yourkey"".getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC"");
        cipher.init(Cipher.DECRYPT_MODE, sks);
        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = cis.read(d)) != -1) {
            fos.write(d, 0, b);
        }
        fos.flush();
        fos.close();
        cis.close();
    }
",2
21628540,1,"        SecretKeySpec sks = new SecretKeySpec(""yourkey"".getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC"");
        cipher.init(Cipher.DECRYPT_MODE, sks);
        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];",2
21628540,1,"        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = cis.read(d)) != -1) {
            fos.write(d, 0, b);
        }
        fos.flush();
        fos.close();
        cis.close();",2
21628540,1,"        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = cis.read(d)) != -1) {
            fos.write(d, 0, b);
        }
        fos.flush();
        fos.close();
        cis.close();",2
21647527,0,"public class sample{
 public void foo(){
RSAPrivateCrtKey privateKey = (RSAPrivateCrtKey) ks.getKey(keyAlias, ksPassword.trim().toCharArray());
RSAPublicKeySpec spec = new RSAPublicKeySpec(
   privateKey.getModulus(),
   privateKey.getPrivateExponent()
);
Key fakePublicKey = KeyFactory.getInstance(""RSA"").generatePublic(spec);
encryptCipher.init(Cipher.ENCRYPT_MODE, fakePublicKey);

}",3
21659203,2,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
21708424,0,"        byte[] array = md.digest(md5.getBytes());
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < array.length; ++i) {
            sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3));
        }
        return sb.toString();",4
21750456,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.e(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }",4
21763107,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
21794329,0,"        FileInputStream input = new FileInputStream(file);
        ByteArrayOutputStream output = new ByteArrayOutputStream ();
        byte [] buffer = new byte [65536];
        int l;
        while ((l = input.read (buffer)) > 0)
               output.write (buffer, 0, l);
        input.close ();
        output.close ();
        byte [] data = output.toByteArray ();
        MessageDigest digest = MessageDigest.getInstance( ""SHA-1"" );
        byte[] bytes = data;
        digest.update(bytes, 0, bytes.length);
        bytes = digest.digest();
        StringBuilder sb = new StringBuilder();
        for( byte b : bytes )
           sb.append( String.format(""%02X"", b) );",4
21797670,0,"    public ConnectionFactory(String proxyHost, Integer proxyPort) {
        this.proxyHost = proxyHost;
        this.proxyPort = proxyPort;
    }

    private void initializeProxy() {
        proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));
    }

    @Override
    public HttpURLConnection getHttpURLConnection(URL url) throws IOException {
        initializeProxy();
        HttpURLConnection con = (HttpURLConnection) url.openConnection(proxy);
        if (con instanceof HttpsURLConnection) {
            System.out.println(""The valus is...."");
            HttpsURLConnection httpsCon = (HttpsURLConnection) url.openConnection(proxy);
            httpsCon.setHostnameVerifier(getHostnameVerifier());
            httpsCon.setSSLSocketFactory(getSslContext().getSocketFactory());
            return httpsCon;
        } else {
            return con;
        }

    }
",1
21797729,0,"    public ConnectionFactory(String proxyHost, Integer proxyPort) {
        this.proxyHost = proxyHost;
        this.proxyPort = proxyPort;
    }

    private void initializeProxy() {
        proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));
    }

    @Override
    public HttpURLConnection getHttpURLConnection(URL url) throws IOException {
        initializeProxy();
        HttpURLConnection con = (HttpURLConnection) url.openConnection(proxy);
        if (con instanceof HttpsURLConnection) {
            System.out.println(""The valus is...."");
            HttpsURLConnection httpsCon = (HttpsURLConnection) url.openConnection(proxy);
            httpsCon.setHostnameVerifier(getHostnameVerifier());
            httpsCon.setSSLSocketFactory(getSslContext().getSocketFactory());
            return httpsCon;
        } else {
            return con;
        }

    }
",1
21805148,0,"  final byte[] rawData = key.getBytes(Charset.forName(""US-ASCII""));
  if (rawData.length != 16) {
    // If this is not 16 in length, there's a problem with the key size, nothing to do here
    throw new IllegalArgumentException(""You've provided an invalid key size"");
  }

  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, ""AES"");
  final Cipher ciph = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
",2
21805148,0,"  final byte[] rawData = key.getBytes(Charset.forName(""US-ASCII""));
  if (rawData.length != 16) {
    // If this is not 16 in length, there's a problem with the key size, nothing to do here
    throw new IllegalArgumentException(""Invalid key size."");
  }

  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, ""AES"");

  final Cipher ciph = Cipher.getInstance(""AES/CBC/PKCS5Padding"");",2
21805148,0,"  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, ""AES"");

  final Cipher ciph = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
  ciph.init(Cipher.DECRYPT_MODE, seckeySpec, new IvParameterSpec(new byte[16]));
  final byte[] decryptedmess = ciph.doFinal(encrypted);
",2
21837411,0,"        KeyStore keyStore = KeyStore.getInstance(""JKS"");
        keyStore.load(new FileInputStream(keyStoreFile), keyStorePass.toCharArray());

        KeyManagerFactory keyFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        keyFactory.init(keyStore, keyStorePass.toCharArray());

        KeyManager[] km = keyFactory.getKeyManagers();


        // loads trustmanager",2
21837411,0,"        KeyStore trustStore = KeyStore.getInstance(""JKS"");
        trustStore.load(new FileInputStream(trustStoreFile), trustStorePass.toCharArray());

        TrustManagerFactory trustFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustFactory.init(trustStore);

        TrustManager[] tm = trustFactory.getTrustManagers();

        // configuring the connection",1
21891215,1,"public class sample{
private final String characterEncoding = ""UTF-8"";
private final String cipherTransformation = ""AES/CBC/PKCS5Padding"";
private final String aesEncryptionAlgorithm = ""AES"";

public  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);
    cipherText = cipher.doFinal(cipherText);
    return cipherText;
}

public byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
    plainText = cipher.doFinal(plainText);
    return plainText;
}

private byte[] getKeyBytes(String key) throws UnsupportedEncodingException{
    byte[] keyBytes= new byte[16];
    byte[] parameterKeyBytes= key.getBytes(characterEncoding);
    System.arraycopy(parameterKeyBytes, 0, keyBytes, 0, Math.min(parameterKeyBytes.length, keyBytes.length));
    return keyBytes;
}


public String encrypt(String plainText, String key) throws UnsupportedEncodingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException{
    byte[] plainTextbytes = plainText.getBytes(characterEncoding);
    byte[] keyBytes = getKeyBytes(key);
    return Base64.encodeToString(encrypt(plainTextbytes,keyBytes, keyBytes), Base64.DEFAULT);
}


public String decrypt(String encryptedText, String key) throws KeyException, GeneralSecurityException, GeneralSecurityException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException{
    byte[] cipheredBytes = Base64.decode(encryptedText, Base64.DEFAULT);
    byte[] keyBytes = getKeyBytes(key);
    return new String(decrypt(cipheredBytes, keyBytes, keyBytes), characterEncoding);
}
",2
21891215,1,"public  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);
    cipherText = cipher.doFinal(cipherText);
    return cipherText;
}
",2
21891215,1,"public  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);
    cipherText = cipher.doFinal(cipherText);
    return cipherText;
}

public byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
    plainText = cipher.doFinal(plainText);
    return plainText;
}
",2
21891215,1,"public byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
    plainText = cipher.doFinal(plainText);
    return plainText;
}
",2
21912294,1,"    X509Certificate[] chain = tm.chain;
    if (chain == null) {
        System.out.println(""Could not obtain server certificate chain"");
        return;
    }

    BufferedReader reader = new BufferedReader(new InputStreamReader(
            System.in));

    System.out.println();
    System.out.println(""Server sent "" + chain.length + "" certificate(s):"");
    System.out.println();
    MessageDigest sha1 = MessageDigest.getInstance(""SHA1"");
    MessageDigest md5 = MessageDigest.getInstance(""MD5"");
    for (int i = 0; i < chain.length; i++) {
        X509Certificate cert = chain[i];
        System.out.println("" "" + (i + 1) + "" Subject ""
                + cert.getSubjectDN());
        System.out.println(""   Issuer  "" + cert.getIssuerDN());
        sha1.update(cert.getEncoded());
        System.out.println(""   sha1    "" + toHexString(sha1.digest()));
        md5.update(cert.getEncoded());
        System.out.println(""   md5     "" + toHexString(md5.digest()));
        System.out.println();
    }

    System.out
    .println(""Enter certificate to add to trusted keystore or 'q' to quit: [1]"");
    String line = reader.readLine().trim();
    int k;
    try {
        k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;
    } catch (NumberFormatException e) {
        System.out.println(""KeyStore not changed"");
        return;
    }

    X509Certificate cert = chain[k];
    String alias = host + ""-"" + (k + 1);
    ks.setCertificateEntry(alias, cert);

    /*
    OutputStream out = new FileOutputStream(""jssecacerts"");
    ks.store(out, passphrase);
    out.close();
     */",4
21912294,1,"private static String toHexString(byte[] bytes) {
    StringBuilder sb = new StringBuilder(bytes.length * 3);
    for (int b : bytes) {
        b &= 0xff;
        sb.append(HEXDIGITS[b >> 4]);
        sb.append(HEXDIGITS[b & 15]);
        sb.append(' ');
    }
    return sb.toString();
}

private static class SavingTrustManager implements X509TrustManager {

    private final X509TrustManager tm;
    private X509Certificate[] chain;

    SavingTrustManager(X509TrustManager tm) {
        this.tm = tm;
    }

    public X509Certificate[] getAcceptedIssuers() {
        throw new UnsupportedOperationException();
    }

    public void checkClientTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
        throw new UnsupportedOperationException();
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
        this.chain = chain;
        tm.checkServerTrusted(chain, authType);
    }
}",1
21912294,1,"    public void checkClientTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
        throw new UnsupportedOperationException();
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType)
            throws CertificateException {
        this.chain = chain;
        tm.checkServerTrusted(chain, authType);
    }",1
21936109,1,"        SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());  

        if ((localAddress != null) || (localPort > 0)) 
        {  
            // we need to bind explicitly  
            if (localPort < 0) 
            {  
                localPort = 0; // indicates ""any""  
            }  
            InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);  
            sslsock.bind(isa);  
        }  
",1
21936109,1,"    public Socket createSocket(Socket socket,
            String host, 
            int port,
            boolean autoClose) throws IOException,  
            UnknownHostException 
            {  
        return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);  
            }  

    // -------------------------------------------------------------------  
    // javadoc in org.apache.http.conn.scheme.SocketFactory says :  
    // Both Object.equals() and Object.hashCode() must be overridden  
    // for the correct operation of some connection managers  
    // -------------------------------------------------------------------  

    public boolean equals(Object obj) {  
        return ((obj != null) && obj.getClass().equals(EasySSLSocketFactory.class));  
    }  

    public int hashCode() {  
        return EasySSLSocketFactory.class.hashCode();  
    }  ",1
21936109,2,"        TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());  
        factory.init(keystore);  
        TrustManager[] trustmanagers = factory.getTrustManagers();  
        if (trustmanagers.length == 0) 
        {  
            throw new NoSuchAlgorithmException(""no trust manager found"");  
        }  
        this.standardTrustManager = (X509TrustManager) trustmanagers[0];  ",1
21963465,0,"public class sample{
 public void foo(){
URL url = new URL(""https://www.google.com/"");
HttpsURLConnection con = (HttpsURLConnection) url.openConnection();
con.connect();
Certificate userCert[] = con.getServerCertificates();
        X509Certificate x509cert = ((X509Certificate) userCert[0]);


        byte[] tbs=x509cert.getTBSCertificate(); 

}",1
21964694,0,"public class sample{
 public void foo(){
URL url = new URL(""https://www.google.com/"");
HttpsURLConnection con = (HttpsURLConnection) url.openConnection();
con.connect();
Certificate userCert[] = con.getServerCertificates();
        X509Certificate x509cert = ((X509Certificate) userCert[0]);


    byte[] tbs=x509cert.getTBSCertificate(); 

}",1
21983231,0,"    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"", ""SunJCE"");
    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(""UTF-8""), ""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, key,new IvParameterSpec(new byte[cipher.getBlockSize()]));",2
21983231,0,"    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"", ""SunJCE"");
    SecretKeySpec key = new SecretKeySpec(encryptionKey.getBytes(""UTF-8""), ""AES"");
    cipher.init(Cipher.DECRYPT_MODE, key,new IvParameterSpec(new byte[cipher.getBlockSize()]));",2
22046174,0,"                Certificate ca;
                try {
                    ca = cf.generateCertificate(caInput);
                    System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
                } finally {
                    caInput.close();
                }
                // Create a KeyStore containing our trusted CAs
                String keyStoreType = KeyStore.getDefaultType();
                KeyStore keyStore = KeyStore.getInstance(keyStoreType);
                keyStore.load(null, null);
                keyStore.setCertificateEntry(""ca"", ca);

                // Create a TrustManager that trusts the CAs in our KeyStore",1
22046174,0,"                Certificate ca;
                try {
                    ca = cf.generateCertificate(caInput);
                    System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
                } finally {
                    caInput.close();
                }
                // Create a KeyStore containing our trusted CAs
                String keyStoreType = KeyStore.getDefaultType();
                KeyStore keyStore = KeyStore.getInstance(keyStoreType);
                keyStore.load(null, null);
                keyStore.setCertificateEntry(""ca"", ca);

                // Create a TrustManager that trusts the CAs in our KeyStore
                String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
                TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
                tmf.init(keyStore);

                // Create an SSLContext that uses our TrustManager",1
22060679,3,"public byte[] createSha1(File file) throws Exception  {
    MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
    InputStream fis = new FileInputStream(file);
    int n = 0;
    byte[] buffer = new byte[8192];
    while (n != -1) {
        n = fis.read(buffer);
        if (n > 0) {
            digest.update(buffer, 0, n);
        }
    }
    return digest.digest();
}
",4
22150331,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
22218410,0,"        public Crypto(String passphrase) {
            byte[] passwordKey = encodeDigest(passphrase);

            try {
                aesCipher = Cipher.getInstance(CIPHER_TRANSFORMATION);
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, ""No such algorithm "" + CIPHER_ALGORITHM, e);
            } catch (NoSuchPaddingException e) {
                Log.e(TAG, ""No such padding PKCS5"", e);
            }

            secretKey = new SecretKeySpec(passwordKey, CIPHER_ALGORITHM);
            ivParameterSpec = new IvParameterSpec(rawSecretKey);",2
22218410,0,"        public byte[] encrypt(byte[] clearData) {
            try {
                aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
            } catch (InvalidKeyException e) {
                Log.e(TAG, ""Invalid key"", e);
                return null;
            } catch (InvalidAlgorithmParameterException e) {
                Log.e(TAG, ""Invalid algorithm "" + CIPHER_ALGORITHM, e);
                return null;
            }

            byte[] encryptedData;
            try {
                encryptedData = aesCipher.doFinal(clearData);
            } catch (IllegalBlockSizeException e) {
                Log.e(TAG, ""Illegal block size"", e);
                return null;
            } catch (BadPaddingException e) {
                Log.e(TAG, ""Bad padding"", e);
                return null;
            }
            return encryptedData;
        }

        private byte[] encodeDigest(String text) {
            MessageDigest digest;
            try {
                digest = MessageDigest.getInstance(MESSAGEDIGEST_ALGORITHM);
                return digest.digest(text.getBytes());
            } catch (NoSuchAlgorithmException e) {
                Log.e(TAG, ""No such algorithm "" + MESSAGEDIGEST_ALGORITHM, e);
            }

            return null;
        }",4
22218410,0,"            try {
                aesCipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec);
            } catch (InvalidKeyException e) {
                Log.e(TAG, ""Invalid key"", e);
                return null;
            } catch (InvalidAlgorithmParameterException e) {
                Log.e(TAG, ""Invalid algorithm "" + CIPHER_ALGORITHM, e);
                return null;
            }
",2
22247129,0,"            const int keyStrength = 2048;

            // Generating Random Numbers
            CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
            SecureRandom random = new SecureRandom(randomGenerator);

            // The Certificate Generator
            X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

            // Serial Number
            BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
            certificateGenerator.SetSerialNumber(serialNumber);

            // Signature Algorithm",4
22247129,0,"            const int keyStrength = 2048;

            // Generating Random Numbers
            CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
            SecureRandom random = new SecureRandom(randomGenerator);

            // The Certificate Generator
            X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

            // Serial Number
            BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
            certificateGenerator.SetSerialNumber(serialNumber);

            // Signature Algorithm
            const string signatureAlgorithm = ""SHA256WithRSA"";
            certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

            // Issuer and Subject Name
            X509Name subjectDN = new X509Name(subjectName);",4
22247129,0,"            const int keyStrength = 2048;

            // Generating Random Numbers
            CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
            SecureRandom random = new SecureRandom(randomGenerator);

            // The Certificate Generator
            X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

            // Serial Number
            BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
            certificateGenerator.SetSerialNumber(serialNumber);

            // Signature Algorithm
            const string signatureAlgorithm = ""SHA256WithRSA"";
            certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

            // Issuer and Subject Name
            X509Name subjectDN = new X509Name(subjectName);
            X509Name issuerDN = new X509Name(issuerName);
            certificateGenerator.SetIssuerDN(issuerDN);
            certificateGenerator.SetSubjectDN(subjectDN);

            // Valid For
            DateTime notBefore = DateTime.UtcNow.Date;
            DateTime notAfter = notBefore.AddYears(2);

            certificateGenerator.SetNotBefore(notBefore);
            certificateGenerator.SetNotAfter(notAfter);

            // Subject Public Key
            AsymmetricCipherKeyPair subjectKeyPair;
            var keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
            var keyPairGenerator = new RsaKeyPairGenerator();
            keyPairGenerator.Init(keyGenerationParameters);
            subjectKeyPair = keyPairGenerator.GenerateKeyPair();

            certificateGenerator.SetPublicKey(subjectKeyPair.Public);

            // Generating the Certificate
            AsymmetricCipherKeyPair issuerKeyPair = subjectKeyPair;

            // selfsign certificate
            Org.BouncyCastle.X509.X509Certificate certificate = certificateGenerator.Generate(issuerPrivKey, random);

            // correcponding private key
            PrivateKeyInfo info = PrivateKeyInfoFactory.CreatePrivateKeyInfo(subjectKeyPair.Private);


            // merge into X509Certificate2
            X509Certificate2 x509 = new System.Security.Cryptography.X509Certificates.X509Certificate2(certificate.GetEncoded());

            Asn1Sequence seq = (Asn1Sequence)Asn1Object.FromByteArray(info.PrivateKey.GetDerEncoded());
            if (seq.Count != 9)
            {
                //throw new PemException(""malformed sequence in RSA private key"");
            }

            RsaPrivateKeyStructure rsa = new RsaPrivateKeyStructure(seq);
            RsaPrivateCrtKeyParameters rsaparams = new RsaPrivateCrtKeyParameters(
                rsa.Modulus, rsa.PublicExponent, rsa.PrivateExponent, rsa.Prime1, rsa.Prime2, rsa.Exponent1, rsa.Exponent2, rsa.Coefficient);
",4
22247129,0,"        public static X509Certificate2 GenerateCACertificate(string subjectName, ref AsymmetricKeyParameter CaPrivateKey)
        {
            const int keyStrength = 2048;

            // Generating Random Numbers
            CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
            SecureRandom random = new SecureRandom(randomGenerator);

            // The Certificate Generator
            X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

            // Serial Number
            BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
            certificateGenerator.SetSerialNumber(serialNumber);

            // Signature Algorithm
            const string signatureAlgorithm = ""SHA256WithRSA"";
            certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

            // Issuer and Subject Name
            X509Name subjectDN = new X509Name(subjectName);
            X509Name issuerDN = subjectDN;
            certificateGenerator.SetIssuerDN(issuerDN);
            certificateGenerator.SetSubjectDN(subjectDN);

            // Valid For
            DateTime notBefore = DateTime.UtcNow.Date;
            DateTime notAfter = notBefore.AddYears(2);

            certificateGenerator.SetNotBefore(notBefore);
            certificateGenerator.SetNotAfter(notAfter);

            // Subject Public Key
            AsymmetricCipherKeyPair subjectKeyPair;
            KeyGenerationParameters keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
            RsaKeyPairGenerator keyPairGenerator = new RsaKeyPairGenerator();
            keyPairGenerator.Init(keyGenerationParameters);
            subjectKeyPair = keyPairGenerator.GenerateKeyPair();

            certificateGenerator.SetPublicKey(subjectKeyPair.Public);

            // Generating the Certificate
            AsymmetricCipherKeyPair issuerKeyPair = subjectKeyPair;

            // selfsign certificate
            Org.BouncyCastle.X509.X509Certificate certificate = certificateGenerator.Generate(issuerKeyPair.Private, random);
            X509Certificate2 x509 = new System.Security.Cryptography.X509Certificates.X509Certificate2(certificate.GetEncoded());

            CaPrivateKey = issuerKeyPair.Private;

            return x509;
            //return issuerKeyPair.Private;

        }

        public static bool addCertToStore(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Security.Cryptography.X509Certificates.StoreName st, System.Security.Cryptography.X509Certificates.StoreLocation sl)
        {
            bool bRet = false;

            try
            {
                X509Store store = new X509Store(st, sl);
                store.Open(OpenFlags.ReadWrite);
                store.Add(cert);

                store.Close();
            }
            catch
            {

            }

            return bRet;
        }
",4
22247129,0,"            const int keyStrength = 2048;

            // Generating Random Numbers
            CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
            SecureRandom random = new SecureRandom(randomGenerator);

            // The Certificate Generator
            X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

            // Serial Number
            BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
            certificateGenerator.SetSerialNumber(serialNumber);

            // Signature Algorithm",4
22247129,0,"            const int keyStrength = 2048;

            // Generating Random Numbers
            CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
            SecureRandom random = new SecureRandom(randomGenerator);

            // The Certificate Generator
            X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

            // Serial Number
            BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
            certificateGenerator.SetSerialNumber(serialNumber);

            // Signature Algorithm
            const string signatureAlgorithm = ""SHA256WithRSA"";
            certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

            // Issuer and Subject Name
            X509Name subjectDN = new X509Name(subjectName);",4
22247129,0,"            const int keyStrength = 2048;

            // Generating Random Numbers
            CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
            SecureRandom random = new SecureRandom(randomGenerator);

            // The Certificate Generator
            X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

            // Serial Number
            BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
            certificateGenerator.SetSerialNumber(serialNumber);

            // Signature Algorithm
            const string signatureAlgorithm = ""SHA256WithRSA"";
            certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

            // Issuer and Subject Name
            X509Name subjectDN = new X509Name(subjectName);
            X509Name issuerDN = subjectDN;
            certificateGenerator.SetIssuerDN(issuerDN);
            certificateGenerator.SetSubjectDN(subjectDN);

            // Valid For
            DateTime notBefore = DateTime.UtcNow.Date;
            DateTime notAfter = notBefore.AddYears(2);

            certificateGenerator.SetNotBefore(notBefore);
            certificateGenerator.SetNotAfter(notAfter);

            // Subject Public Key
            AsymmetricCipherKeyPair subjectKeyPair;
            KeyGenerationParameters keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
            RsaKeyPairGenerator keyPairGenerator = new RsaKeyPairGenerator();
            keyPairGenerator.Init(keyGenerationParameters);
            subjectKeyPair = keyPairGenerator.GenerateKeyPair();

            certificateGenerator.SetPublicKey(subjectKeyPair.Public);

            // Generating the Certificate
            AsymmetricCipherKeyPair issuerKeyPair = subjectKeyPair;

            // selfsign certificate
            Org.BouncyCastle.X509.X509Certificate certificate = certificateGenerator.Generate(issuerKeyPair.Private, random);",4
22278971,0,"public class sample{
public void PrintHashKeyInLog() {

        PackageInfo info;
        try {
            info = getPackageManager().getPackageInfo(
                    ""Your package name here"",
                    PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md;
                md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String something = new String(Base64.encode(md.digest(), 0)); // String
            //  something = new String(Base64.encode(md.digest(), 0));
                Log.e(""hash key"", something);
            }
        } catch (NameNotFoundException e1) {
            Log.e(""name not found"", e1.toString());
        } catch (NoSuchAlgorithmException e) {
            Log.e(""no such an algorithm"", e.toString());
        } catch (Exception e) {
            Log.e(""exception"", e.toString());
        }
    }
",4
22278971,0,"            for (Signature signature : info.signatures) {
                MessageDigest md;
                md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String something = new String(Base64.encode(md.digest(), 0)); // String
            //  something = new String(Base64.encode(md.digest(), 0));
                Log.e(""hash key"", something);
            }",4
22278971,0,"            for (Signature signature : info.signatures) {
                MessageDigest md;
                md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String something = new String(Base64.encode(md.digest(), 0)); // String
            //  something = new String(Base64.encode(md.digest(), 0));
                Log.e(""hash key"", something);
            }
        } catch (NameNotFoundException e1) {
            Log.e(""name not found"", e1.toString());
        } catch (NoSuchAlgorithmException e) {
            Log.e(""no such an algorithm"", e.toString());
        } catch (Exception e) {
            Log.e(""exception"", e.toString());
        }",4
22296721,1,"ContentSigner getContentSigner(PrivateKey privateKey) {
    AsymmetricKeyParameter keyParameter = PrivateKeyFactory.createKey(privateKey.getEncoded());
    AlgorithmIdentifier sigAlgId = new DefaultSignatureAlgorithmIdentifierFinder().find(""SHA256WITHRSA""); // or what you want
    AlgorithmIdentifier digAlgId = new DefaultDigestAlgorithmIdentifierFinder().find(sigAlgId);
    return new BcRSAContentSignerBuilder(sigAlgId, digAlgId).build(keyParameter);
}
",3
22350934,0,"        final byte[] ivData = new byte[blockSize];
        final SecureRandom rnd = SecureRandom.getInstance(""SHA1PRNG"");
        rnd.nextBytes(ivData);
        final IvParameterSpec iv = new IvParameterSpec(ivData);

        cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);

        final byte[] encryptedMessage = cipher.doFinal(encodedMessage);

        // concatenate IV and encrypted message
        final byte[] ivAndEncryptedMessage = new byte[ivData.length
                + encryptedMessage.length];
        System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);
        System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage,
                blockSize, encryptedMessage.length);
",2
22350934,1,"        final byte[] ivData = new byte[blockSize];
        final SecureRandom rnd = SecureRandom.getInstance(""SHA1PRNG"");
        rnd.nextBytes(ivData);
        final IvParameterSpec iv = new IvParameterSpec(ivData);

        cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);

        final byte[] encryptedMessage = cipher.doFinal(encodedMessage);

        // concatenate IV and encrypted message
        final byte[] ivAndEncryptedMessage = new byte[ivData.length
                + encryptedMessage.length];
        System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);
        System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage,
                blockSize, encryptedMessage.length);

        //final String ivAndEncryptedMessageBase64 = Base64.encodeBase64String(ivAndEncryptedMessage);",2
22419149,0,"public class sample{
 public void foo(){
 PKCS5S2ParametersGenerator generator = new PKCS5S2ParametersGenerator(new SHA256Digest());
 generator.init(PBEParametersGenerator.PKCS5PasswordToUTF8Bytes(password), salt, iterations);
 KeyParameter key = (KeyParameter)generator.generateDerivedMacParameters(keySizeInBits);

}",2
22419149,1,"public static SecretKey generateKey(char[] passphraseOrPin, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
// Number of PBKDF2 hardening rounds to use. Larger values increase
// computation time. You should select a value that causes computation
// to take >100ms.
final int iterations = 8000; 

// Generate a 160-bit key
final int outputKeyLength = 160;

SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength);
SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
return secretKey;
",2
22445878,0,"            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
",2
22445878,0,"            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

            byte[] encrypted = cipher.doFinal(value.getBytes());
            System.out.println(""encrypted string: ""
                    + Base64.encodeBase64String(encrypted));

            return Base64.encodeBase64String(encrypted);",2
22445878,0,"            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
",2
22445878,0,"            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

            byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));

            return new String(original);",2
22445904,0,"            IvParameterSpec iv = new IvParameterSpec(key2.getBytes(""UTF-8""));

            SecretKeySpec skeySpec = new SecretKeySpec(key1.getBytes(""UTF-8""),
                    ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);",2
22445904,0,"            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
            byte[] encrypted = cipher.doFinal(value.getBytes());
            System.out.println(""encrypted string:""
                    + Base64.encodeBase64String(encrypted));
            return Base64.encodeBase64String(encrypted);",2
22445904,0,"            IvParameterSpec iv = new IvParameterSpec(key2.getBytes(""UTF-8""));

            SecretKeySpec skeySpec = new SecretKeySpec(key1.getBytes(""UTF-8""),
                    ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);",2
22445904,0,"            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
            byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));

            return new String(original);",2
22455844,0,"                public ConnectionFactory(String proxyHost, Integer proxyPort) {
                    this.proxyHost = proxyHost;
                    this.proxyPort = proxyPort;
                }

                private void initializeProxy() {
                    proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));
                }

                @Override
                public HttpURLConnection getHttpURLConnection(URL url) throws IOException {
                    initializeProxy();
                    HttpURLConnection con = (HttpURLConnection) url.openConnection(proxy);
                    if (con instanceof HttpsURLConnection) {
                        System.out.println(""The valus is...."");
                        HttpsURLConnection httpsCon = (HttpsURLConnection) url.openConnection(proxy);
                        httpsCon.setHostnameVerifier(getHostnameVerifier());
                        httpsCon.setSSLSocketFactory(getSslContext().getSocketFactory());
                        return httpsCon;
                    } else {
                        return con;
                    }

                }
",1
22473854,0,"public class sample{
 public void foo(){
System.setProperty(""javax.net.ssl. keyStore"",""mySrvKeystore""); System.setProperty(""javax.net.ssl. keyStorePassword"",""123456"");

ServerSocketFactory ssocketFactory = SSLServerSocketFactory.getDefault(); 
ServerSocket ssocket = null; 
System.out.println(""SSL_Server started"");

}",1
22475656,1,"public class sample{
 public void foo(){
// DO NOT FORGET TO REMOVE
PackageInfo info;
try {
    info = getPackageManager().getPackageInfo(""com.you.name"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }
} catch (NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}
// DO NOT FORGET TO REMOVE

}",4
22475656,1,"    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }",4
22475656,1,"    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }
} catch (NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}
// DO NOT FORGET TO REMOVE
",4
22494883,2,"FileInputStream fis = new FileInputStream(CA_FILE);
X509Certificate ca = (X509Certificate) CertificateFactory.getInstance(
        ""X.509"").generateCertificate(new BufferedInputStream(fis));

KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
ks.load(null, null);
ks.setCertificateEntry(Integer.toString(1), ca);

TrustManagerFactory tmf = TrustManagerFactory
        .getInstance(TrustManagerFactory.getDefaultAlgorithm());
tmf.init(ks);
",1
22498266,2,"FileInputStream fis = new FileInputStream(CA_FILE);
X509Certificate ca = (X509Certificate) CertificateFactory.getInstance(
        ""X.509"").generateCertificate(new BufferedInputStream(fis));

KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
ks.load(null, null);
ks.setCertificateEntry(Integer.toString(1), ca);

TrustManagerFactory tmf = TrustManagerFactory
        .getInstance(TrustManagerFactory.getDefaultAlgorithm());
tmf.init(ks);",1
22502525,0,"SecretKey tmp = factory.generateSecret(spec);
SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");


/* Encrypt the message. */
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, secret);
AlgorithmParameters params = cipher.getParameters();
byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();",2
22502525,0,"Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, secret);
AlgorithmParameters params = cipher.getParameters();
byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();",2
22524546,0,"        HostnameVerifier hv = new HostnameVerifier() {
            public boolean verify(String urlHostName, SSLSession session) {
                if (!urlHostName.equalsIgnoreCase(session.getPeerHost())) {
                    System.out.println(""Warning: URL host '"" + urlHostName + ""' is different to SSLSession host '"" + session.getPeerHost() + ""'."");
                }
                return true;
            }",1
22569165,0,"    private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, SECRET_KEY_ALGORITHM);
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ips);
        byte[] encrypted = cipher.doFinal(clear);
        return encrypted;
    }
",2
22569165,0,"    private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
        SecretKeySpec skeySpec = new SecretKeySpec(raw, SECRET_KEY_ALGORITHM);
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, ips);
        byte[] decrypted = cipher.doFinal(encrypted);
        return decrypted;
    }
",2
22570128,0,"              File truststore = new File(""certs\\truststore.jks"");
              keyStore.load(new FileInputStream(truststore), trustpass.toCharArray());
              TrustManagerFactory trustFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
              trustFactory.init(keyStore);
              TrustManager[] tm = trustFactory.getTrustManagers();",1
22570128,0,"              truststore = new File(""certs\\wibble.jks"");
              keyStore.load(new FileInputStream(truststore), trustpass.toCharArray());
              KeyManagerFactory keyFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
              keyFactory.init(keyStore, trustpass.toCharArray());
              KeyManager[] km = keyFactory.getKeyManagers();",2
22587756,0,"public class sample{
 public void foo(){
try {

   PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);

   for (Signature signature : info.signatures) 
   {
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
   }

  } catch (NameNotFoundException e) {
   Log.e(""name not found"", e.toString());
  } catch (NoSuchAlgorithmException e) {
   Log.e(""no such an algorithm"", e.toString());
  }

}",4
22587756,0,"   for (Signature signature : info.signatures) 
   {
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
   }
",4
22587767,0,"public class sample{
 public void foo(){
try {

   PackageInfo info = getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);

   for (Signature signature : info.signatures) 
   {
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
   }

  } catch (NameNotFoundException e) {
   Log.e(""name not found"", e.toString());
  } catch (NoSuchAlgorithmException e) {
   Log.e(""no such an algorithm"", e.toString());
  }

}",4
22587767,0,"   for (Signature signature : info.signatures) 
   {
    MessageDigest md = MessageDigest.getInstance(""SHA"");
    md.update(signature.toByteArray());
    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
   }
",4
22654013,0,"   public  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);
    cipherText = cipher.doFinal(cipherText);
    return cipherText;
}
",2
22654013,0,"   public  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);
    cipherText = cipher.doFinal(cipherText);
    return cipherText;
}

public byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
    plainText = cipher.doFinal(plainText);
    return plainText;
}
",2
22654013,0,"public byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
{
    Cipher cipher = Cipher.getInstance(cipherTransformation);
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
    plainText = cipher.doFinal(plainText);
    return plainText;
}
",2
22695880,6,"Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, secret);
AlgorithmParameters params = cipher.getParameters();
byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();",2
22779013,0,"public PublicKey getPublicKey(String key,Context context) {

    PublicKey pKey = null;
    try {

        String pubString = this.getString(key, context);

        if(pubString!=null) {
            byte[] binCpk = Base64.decode(pubString);
            KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(binCpk);
            pKey = keyFactory.generatePublic(publicKeySpec);
        }
        }catch(Exception e){
    }
    return pKey;
}
",4
22779013,1,"public PrivateKey getPrivateKey(String key, Context context) {

    PrivateKey privateKey = null;

    try {
        String privateString = this.getString(key, context);
        if(privateString!=null){
            byte[] binCpk = Base64.decode(privateString);
            KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
            PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(binCpk);
            privateKey = keyFactory.generatePrivate(privateKeySpec);
        }
    } 
    catch(Exception e){
    }
    return privateKey;
}
",4
22829673,7,"byte[] inputBuffer = new byte[ BUFFER_SIZE ];
int r = in.read(inputBuffer);
while ( r >= 0 ) {
    byte[] outputUpdate = cipher.update( inputBuffer, 0, r );
    out.write( outputUpdate );
    r = in.read(inputBuffer);
}
byte[] outputFinalUpdate = cipher.doFinal();
out.write( outputFinalUpdate );
",2
22864127,2,"  final byte[] rawData = key.getBytes(Charset.forName(""US-ASCII""));
  if (rawData.length != 16) {
    // If this is not 16 in length, there's a problem with the key size, nothing to do here
    throw new IllegalArgumentException(""You've provided an invalid key size"");
  }

  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, ""AES"");
  final Cipher ciph = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
",2
22864127,3,"  final byte[] rawData = key.getBytes(Charset.forName(""US-ASCII""));
  if (rawData.length != 16) {
    // If this is not 16 in length, there's a problem with the key size, nothing to do here
    throw new IllegalArgumentException(""Invalid key size."");
  }

  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, ""AES"");

  final Cipher ciph = Cipher.getInstance(""AES/CBC/PKCS5Padding"");",2
22864127,3,"  final SecretKeySpec seckeySpec = new SecretKeySpec(rawData, ""AES"");

  final Cipher ciph = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
  ciph.init(Cipher.DECRYPT_MODE, seckeySpec, new IvParameterSpec(new byte[16]));
  final byte[] decryptedmess = ciph.doFinal(encrypted);
",2
22900738,0,"byte[] keyBytes = Base64.decode(publicK.getBytes(""utf-8""));
X509EncodedKeySpec spec = new X509EncodedKeySpec(keyBytes);
KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
PublicKey key = keyFactory.generatePublic(spec);
",3
22900738,1,"byte[] keyBytes = Base64.decode(privateK.getBytes(""utf-8""));
PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(keyBytes);
KeyFactory fact = KeyFactory.getInstance(""RSA"");
PrivateKey priv = fact.generatePrivate(keySpec);
",3
22906521,0,"    byte[] inputBuffer = new byte[ BUFFER_SIZE ]; // 4K or 8K are pretty good buffer size values 
    int r = in.read( inputBuffer );
    while ( r >= 0 ) {
        byte[] outputUpdate = dcipher.update( inputBuffer, 0, r );
        out.write( outputUpdate );
        r = in.read( inputBuffer );
    }
    byte[] outputFinalUpdate = dcipher.doFinal();
    out.write( outputFinalUpdate );",2
22917050,3,"  public static String getSignatureHash(Context ctxt, String packageName)
                                                                         throws NameNotFoundException,
                                                                         NoSuchAlgorithmException {
    MessageDigest md=MessageDigest.getInstance(""SHA-1"");
    Signature sig=
        ctxt.getPackageManager()
            .getPackageInfo(packageName, PackageManager.GET_SIGNATURES).signatures[0];

    return(toHexStringWithColons(md.digest(sig.toByteArray())));",4
22924795,0,"    Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
    cipher.init(Cipher.DECRYPT_MODE, key);
    byte[] decoded = Base64.decodeBase64(encrypted);
    byte[] decrypted = cipher.doFinal(decoded);",3
23015267,2,"public class sample{
    /**
     * Encode PublicKey (DSA or RSA encoded) to authorized_keys like string
     *
     * @param publicKey DSA or RSA encoded
     * @param user username for output authorized_keys like string
     * @return authorized_keys like string
     * @throws IOException
     */
    public static String encodePublicKey(PublicKey publicKey, String user)
            throws IOException {
        String publicKeyEncoded;
        if(publicKey.getAlgorithm().equals(""RSA"")){
            RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
            ByteArrayOutputStream byteOs = new ByteArrayOutputStream();
            DataOutputStream dos = new DataOutputStream(byteOs);
            dos.writeInt(""ssh-rsa"".getBytes().length);
            dos.write(""ssh-rsa"".getBytes());
            dos.writeInt(rsaPublicKey.getPublicExponent().toByteArray().length);
            dos.write(rsaPublicKey.getPublicExponent().toByteArray());
            dos.writeInt(rsaPublicKey.getModulus().toByteArray().length);
            dos.write(rsaPublicKey.getModulus().toByteArray());
            publicKeyEncoded = new String(
                    Base64.encodeBase64(byteOs.toByteArray()));
            return ""ssh-rsa "" + publicKeyEncoded + "" "" + user;
        }
        else if(publicKey.getAlgorithm().equals(""DSA"")){
            DSAPublicKey dsaPublicKey = (DSAPublicKey) publicKey;
            DSAParams dsaParams = dsaPublicKey.getParams();

            ByteArrayOutputStream byteOs = new ByteArrayOutputStream();
            DataOutputStream dos = new DataOutputStream(byteOs);
            dos.writeInt(""ssh-dss"".getBytes().length);
            dos.write(""ssh-dss"".getBytes());
            dos.writeInt(dsaParams.getP().toByteArray().length);
            dos.write(dsaParams.getP().toByteArray());
            dos.writeInt(dsaParams.getQ().toByteArray().length);
            dos.write(dsaParams.getQ().toByteArray());
            dos.writeInt(dsaParams.getG().toByteArray().length);
            dos.write(dsaParams.getG().toByteArray());
            dos.writeInt(dsaPublicKey.getY().toByteArray().length);
            dos.write(dsaPublicKey.getY().toByteArray());
            publicKeyEncoded = new String(
                    Base64.encodeBase64(byteOs.toByteArray()));
            return ""ssh-dss "" + publicKeyEncoded + "" "" + user;
        }
        else{
            throw new IllegalArgumentException(
                    ""Unknown public key encoding: "" + publicKey.getAlgorithm());
        }
    }
",3
23015267,2,"            dos.writeInt(rsaPublicKey.getModulus().toByteArray().length);
            dos.write(rsaPublicKey.getModulus().toByteArray());
            publicKeyEncoded = new String(
                    Base64.encodeBase64(byteOs.toByteArray()));
            return ""ssh-rsa "" + publicKeyEncoded + "" "" + user;",3
23015267,2,"            dos.writeInt(dsaPublicKey.getY().toByteArray().length);
            dos.write(dsaPublicKey.getY().toByteArray());
            publicKeyEncoded = new String(
                    Base64.encodeBase64(byteOs.toByteArray()));
            return ""ssh-dss "" + publicKeyEncoded + "" "" + user;",3
23047317,0,"for (Signature signature : info.signatures){
   MessageDigest md = MessageDigest.getInstance(""SHA"");
   md.update(signature.toByteArray());
   Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
}
",4
23052978,2,"public void checkClientTrusted(X509Certificate[] ax509certificate, String s)
        throws CertificateException {
    // TODO Auto-generated method stub
    try {
        myTrustManager.checkClientTrusted(ax509certificate, s);
    } catch (CertificateException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        defaultTrustManager.checkClientTrusted(ax509certificate, s);
    }
}

@Override",1
23052978,2,"public void checkServerTrusted(X509Certificate[] ax509certificate, String s)
        throws CertificateException {
    // TODO Auto-generated method stub
    try {
        myTrustManager.checkServerTrusted(ax509certificate, s);
    } catch (CertificateException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        defaultTrustManager.checkServerTrusted(ax509certificate, s);
    }
}

public X509Certificate[] getAcceptedIssuers() {
    // TODO Auto-generated method stub
    return acceptedIssuers;
}
",1
23076839,0,"        byte messageDigest[] = digest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i < messageDigest.length; i++) {
            String h = Integer.toHexString(0xFF & messageDigest[i]);
            while (h.length() < 2)
                h = ""0"" + h;
            hexString.append(h);
        }",4
23081786,0,"            byte messageDigest[] = digest.digest();

            StringBuffer hexString = new StringBuffer();
            for (int i = 0; i < messageDigest.length; i++) 
            {
                String h = Integer.toHexString(0xFF & messageDigest[i]);
                while (h.length() < 2)
                    h = ""0"" + h;
                hexString.append(h);
            }",4
23134124,2,"  public Socket createSocket(Socket socket, String host, int port, boolean autoClose)
     throws IOException, UnknownHostException {
      return sslContext.getSocketFactory()
         .createSocket(socket, host, port, autoClose);  
  }

  @Override
  public Socket createSocket() throws IOException {
     return sslContext.getSocketFactory().createSocket();
  }",1
23236998,0,"        byte msgDigestBytes[] = msgDigest.digest();

        // Create Hex String
        StringBuffer hexString = new StringBuffer();
        for (int i = 0; i < msgDigestBytes.length; i++) {
            String h = Integer.toHexString(0xFF & msgDigestBytes[i]);
            while (h.length() < 2)
                h = ""0"" + h;
            hexString.append(h);
        }",4
23277782,1,"            final PemReader certReader = new PemReader(new FileReader(args[0]));
            final PemObject certAsPemObject = certReader.readPemObject();
            if (!certAsPemObject.getType().equalsIgnoreCase(""CERTIFICATE"")) {
                throw new IllegalArgumentException(""Certificate file does not contain a certificate but a "" + certAsPemObject.getType());
            }
            final byte[] x509Data = certAsPemObject.getContent();
            final CertificateFactory fact = CertificateFactory.getInstance(""X509"");",3
23277782,1,"            final PemReader keyReader = new PemReader(new FileReader(args[1]));
            final PemObject keyAsPemObject = keyReader.readPemObject();
            if (!keyAsPemObject.getType().equalsIgnoreCase(""PRIVATE KEY"")) {
                throw new IllegalArgumentException(""Key file does not contain a private key but a "" + keyAsPemObject.getType());
            }

            final byte[] privateKeyData = keyAsPemObject.getContent();
            final KeyFactory keyFact = KeyFactory.getInstance(""RSA"");",3
23317730,2,"FileInputStream fis = new FileInputStream(CA_FILE);
X509Certificate ca = (X509Certificate) CertificateFactory.getInstance(
        ""X.509"").generateCertificate(new BufferedInputStream(fis));

KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
ks.load(null, null);
ks.setCertificateEntry(Integer.toString(1), ca);

TrustManagerFactory tmf = TrustManagerFactory.getInstance(
        TrustManagerFactory.getDefaultAlgorithm());
tmf.init(ks);
",1
23365536,17,"    public Socket createSocket(InetAddress host, int port) throws IOException
    {
        SSLSocketFactory factory = m_ctx.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);

        ss.setEnabledProtocols(m_protocols);
        ss.setEnabledCipherSuites(m_ciphers);

        return ss;
    }
",1
23365536,17,"    public Socket createSocket(String host, int port) throws IOException
    {
        SSLSocketFactory factory = m_ctx.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);

        ss.setEnabledProtocols(m_protocols);
        ss.setEnabledCipherSuites(m_ciphers);

        return ss;
    }
",1
23455539,0,"    PBKDF2(){
        @Override
        public String getHashString()
        {
            return ""PBKDF2WithHmacSHA1"";
        }
    }, SHA512(){
        @Override
        public String getHashString() {
            return ""SHA-512"";
        }
    }, SHA384() {
        @Override
        public String getHashString() {
            return ""SHA-384"";
        }",-1
23455539,0,"    PBKDF2(){
        @Override
        public String getHashString()
        {
            return ""PBKDF2WithHmacSHA1"";
        }
    }, SHA512(){
        @Override
        public String getHashString() {
            return ""SHA-512"";
        }
    }, SHA384() {
        @Override
        public String getHashString() {
            return ""SHA-384"";
        }
    }, SHA256() {
        @Override
        public String getHashString () {
            return ""SHA-256"";
        }
    }",-1
23455539,0,"    }, SHA512(){
        @Override
        public String getHashString() {
            return ""SHA-512"";
        }
    }, SHA384() {
        @Override
        public String getHashString() {
            return ""SHA-384"";
        }
    }, SHA256() {
        @Override
        public String getHashString () {
            return ""SHA-256"";
        }
    }
    , SHA1()
    {
        @Override
        public String getHashString() {
            return ""SHA-1"";
        }",-1
23455539,0,"    }, SHA384() {
        @Override
        public String getHashString() {
            return ""SHA-384"";
        }
    }, SHA256() {
        @Override
        public String getHashString () {
            return ""SHA-256"";
        }
    }
    , SHA1()
    {
        @Override
        public String getHashString() {
            return ""SHA-1"";
        }",-1
23455539,0,"    {
        method = HashMethod.PBKDF2;
    }
    else if( isDigestAvailable( HashMethod.SHA512.getHashString() ) )
    {
        method = HashMethod.SHA512;
    }
    else if( isDigestAvailable( HashMethod.SHA384.getHashString() ) )
    {
        method = HashMethod.SHA384;
    }
    else if( isDigestAvailable( HashMethod.SHA256.getHashString() ) )
    {
        method = HashMethod.SHA256;
    }",4
23455539,0,"    {
        method = HashMethod.SHA512;
    }
    else if( isDigestAvailable( HashMethod.SHA384.getHashString() ) )
    {
        method = HashMethod.SHA384;
    }
    else if( isDigestAvailable( HashMethod.SHA256.getHashString() ) )
    {
        method = HashMethod.SHA256;
    }
    else if( isDigestAvailable( HashMethod.SHA1.getHashString() ) )
    {
        method = HashMethod.SHA1;
    }
",4
23455539,0,"    byte[] buffer = password.getBytes();

    try {
        MessageDigest messageDigest = MessageDigest.getInstance( algorithm );
        messageDigest.reset();
        messageDigest.update( buffer );
        digest = messageDigest.digest();
    }
    catch ( NoSuchAlgorithmException ex )
    {}
",4
23512148,0,"        String passwd = properties.getProperty(KEYSTORE_PASSWORD, ""security"");
        if (passwd != null) {
            passwd = passwd.trim();
        }
        String type = properties.getProperty(KEYSTORE_TYPE, KeyStore.getDefaultType());
        if (type != null) {
            type = type.trim();
        }
",2
23512148,0,"        String pin = properties.getProperty(KEYSTORE_PRIVATE_PASSWORD);
        char[] pin_arr = pin.toCharArray();
        String pkcs11config = ""name = SmartCard\n"" + ""library = "" + properties.getProperty(KEYSTORE_FILE);
        byte[] pkcs11configBytes = pkcs11config.getBytes();
        ByteArrayInputStream configStream = new ByteArrayInputStream(pkcs11configBytes);
        Provider pkcs11Provider = new sun.security.pkcs11.SunPKCS11(configStream);
        try {
            Security.addProvider(pkcs11Provider);

            keystore = KeyStore.getInstance(type,pkcs11Provider);

            keystore.load(null, pin_arr);


        } catch (Exception ex) {
            // nothing
        }
        //keystore = load(is, passwd, provider, type);",2
23512148,0,"        String passwd = properties.getProperty(TRUSTSTORE_PASSWORD, ""changeit"");
        if (passwd != null) {
            passwd = passwd.trim();
        }
        String type = properties.getProperty(TRUSTSTORE_TYPE, KeyStore.getDefaultType());
        if (type != null) {
            type = type.trim();
        }",2
23512148,1,"            String pin = properties.getProperty(KEYSTORE_PRIVATE_PASSWORD);
            char[] pin_arr = pin.toCharArray();
            String pkcs11config = ""name = SmartCard\n"" + ""library = "" + properties.getProperty(KEYSTORE_FILE);
            byte[] pkcs11configBytes = pkcs11config.getBytes();
            ByteArrayInputStream configStream = new ByteArrayInputStream(pkcs11configBytes);
            Provider pkcs11Provider = new sun.security.pkcs11.SunPKCS11(configStream);
            try {
                Security.addProvider(pkcs11Provider);

                keystore = KeyStore.getInstance(type,pkcs11Provider);

                keystore.load(null, pin_arr);


            } catch (Exception ex) {
                // nothing
            }
",2
23535232,0,"PEMParser pemParser = new PEMParser(new FileReader(privateKeyFile));
Object object = pemParser.readObject();
PEMDecryptorProvider decProv = new    JcePEMDecryptorProviderBuilder().build(password.toCharArray());
JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(""BC"");
KeyPair kp;
if (object instanceof PEMEncryptedKeyPair) {
    kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));
}
",3
23654324,0,"    public Socket createSocket(Socket socket, String host, int port,
            boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host,
                port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
23679143,4,"    MessageDigest sha1 = MessageDigest.getInstance( ""SHA1"" );
    byte[] keyBytes = Arrays.copyOf( sha1.digest( password.getBytes( ""UTF-8"" ) ), 24 );
    SecretKeySpec key = new SecretKeySpec( keyBytes, ""DESede"" );

    IvParameterSpec iv = new IvParameterSpec( ivBytes );

    Cipher cipher = Cipher.getInstance( ""DESede/CTR/PKCS5Padding"" );
    cipher.init( Cipher.ENCRYPT_MODE, key, iv );
",4
23679143,4,"    MessageDigest sha1 = MessageDigest.getInstance( ""SHA1"" );
    byte[] keyBytes = Arrays.copyOf( sha1.digest( password.getBytes( ""UTF-8"" ) ), 24 );
    SecretKeySpec key = new SecretKeySpec( keyBytes, ""DESede"" );

    IvParameterSpec iv = new IvParameterSpec( ivBytes );

    Cipher cipher = Cipher.getInstance( ""DESede/CTR/PKCS5Padding"" );
    cipher.init( Cipher.DECRYPT_MODE, key, iv );

    // exact mirror of encryption sequence",4
23723450,0,"    while (idx < data.length) {
        int len = Math.min(data.length-idx, chunkSize);
        byte[] encChunk = pkCipher.doFinal(data, idx, len);
        buf.put(encChunk);
        idx += len;
    }

    // fully encrypted data     ",-1
23723450,1,"while(idx < data.length) {
    int len = Math.min(data.length-idx, chunkSize);
    byte[] chunk = rsaCipher.doFinal(data, idx, len);
    buf.put(chunk);
    idx += len;
}

// fully decrypted data",-1
23744623,2,"public static final void jumpToOffset(final Cipher c,
        final SecretKey aesKey, final IvParameterSpec iv, final long offset) {
    if (!c.getAlgorithm().toUpperCase().startsWith(""AES/CTR"")) {
        throw new IllegalArgumentException(
                ""Invalid algorithm, only AES/CTR mode supported"");
    }

    if (offset < 0) {
        throw new IllegalArgumentException(""Invalid offset"");
    }

    final int skip = (int) (offset % AES_BLOCK_SIZE);
    final IvParameterSpec calculatedIVForOffset = calculateIVForOffset(iv,
            offset - skip);
    try {
        c.init(Cipher.ENCRYPT_MODE, aesKey, calculatedIVForOffset);
        final byte[] skipBuffer = new byte[skip];
        c.update(skipBuffer, 0, skip, skipBuffer);
        Arrays.fill(skipBuffer, (byte) 0);
    } catch (ShortBufferException | InvalidKeyException
            | InvalidAlgorithmParameterException e) {
        throw new IllegalStateException(e);
    }
}

private static IvParameterSpec calculateIVForOffset(final IvParameterSpec iv,
        final long blockOffset) {
    final BigInteger ivBI = new BigInteger(1, iv.getIV());
    final BigInteger ivForOffsetBI = ivBI.add(BigInteger.valueOf(blockOffset
            / AES_BLOCK_SIZE));

    final byte[] ivForOffsetBA = ivForOffsetBI.toByteArray();
    final IvParameterSpec ivForOffset;
    if (ivForOffsetBA.length >= AES_BLOCK_SIZE) {
        ivForOffset = new IvParameterSpec(ivForOffsetBA, ivForOffsetBA.length - AES_BLOCK_SIZE,
                AES_BLOCK_SIZE);
    } else {
        final byte[] ivForOffsetBASized = new byte[AES_BLOCK_SIZE];
        System.arraycopy(ivForOffsetBA, 0, ivForOffsetBASized, AES_BLOCK_SIZE
                - ivForOffsetBA.length, ivForOffsetBA.length);
        ivForOffset = new IvParameterSpec(ivForOffsetBASized);
    }

    return ivForOffset;
}
",2
23879822,0,"public  PrivateKey getPemPrivateKey(String filename, String algorithm) throws Exception {
          File f = new File(filename);
          FileInputStream fis = new FileInputStream(f);
          DataInputStream dis = new DataInputStream(fis);
          byte[] keyBytes = new byte[(int) f.length()];
          dis.readFully(keyBytes);
          dis.close();

      String temp = new String(keyBytes);
      String privKeyPEM = temp.replace(""-----BEGIN PRIVATE KEY-----"", """");
      privKeyPEM = privKeyPEM.replace(""-----END PRIVATE KEY-----"", """");
      //System.out.println(""Private key\n""+privKeyPEM);

      BASE64Decoder b64=new BASE64Decoder();
      byte[] decoded = b64.decodeBuffer(privKeyPEM);

      PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(decoded);
      KeyFactory kf = KeyFactory.getInstance(algorithm);
      return kf.generatePrivate(spec);
      }
",3
23879822,0,"      String privKeyPEM = temp.replace(""-----BEGIN PRIVATE KEY-----"", """");
      privKeyPEM = privKeyPEM.replace(""-----END PRIVATE KEY-----"", """");
      //System.out.println(""Private key\n""+privKeyPEM);

      BASE64Decoder b64=new BASE64Decoder();
      byte[] decoded = b64.decodeBuffer(privKeyPEM);

      PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(decoded);",3
23881820,1,"public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
    return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
}

@Override
public Socket createSocket() throws IOException {
    return sslContext.getSocketFactory().createSocket();
}",1
23888540,1,"    byte[] ivData = new byte[cipher.getBlockSize()];
    rng.nextBytes(ivData);

    cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(ivData));
    byte[] ciphertext = cipher.doFinal(buffer);
",5
23893399,0,"    public Socket createSocket(Socket socket, String host, int port,
            boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port,
                autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
",1
24005019,0,"    public  PrivateKey getPemPrivateKey(String filename, String algorithm) throws Exception {
          File f = new File(filename);
          FileInputStream fis = new FileInputStream(f);
          DataInputStream dis = new DataInputStream(fis);
          byte[] keyBytes = new byte[(int) f.length()];
          dis.readFully(keyBytes);
          dis.close();

          String temp = new String(keyBytes);
          String privKeyPEM = temp.replace(""-----BEGIN PRIVATE KEY-----"", """");
          privKeyPEM = privKeyPEM.replace(""-----END PRIVATE KEY-----"", """");
          //System.out.println(""Private key\n""+privKeyPEM);

          BASE64Decoder b64=new BASE64Decoder();
          byte[] decoded = b64.decodeBuffer(privKeyPEM);

          PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(decoded);
          KeyFactory kf = KeyFactory.getInstance(algorithm);
          return kf.generatePrivate(spec);
          }



    /**
     * Saves the private key to a pem file.
     * @param filename  name of the file to write the key into 
     * @param key the Private key to save.
     * @return  String representation of the pkcs8 object.
     * @throws Exception
     */",3
24005019,0,"          String privKeyPEM = temp.replace(""-----BEGIN PRIVATE KEY-----"", """");
          privKeyPEM = privKeyPEM.replace(""-----END PRIVATE KEY-----"", """");
          //System.out.println(""Private key\n""+privKeyPEM);

          BASE64Decoder b64=new BASE64Decoder();
          byte[] decoded = b64.decodeBuffer(privKeyPEM);

          PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(decoded);",3
24005019,0,"          pkcs8.decode(keyBytes);
          byte[] b=pkcs8.encode();

          BASE64Encoder b64=new BASE64Encoder();
          String  encoded = b64.encodeBuffer(b);

          encoded= ""-----BEGIN PRIVATE KEY-----\r\n"" + encoded + ""-----END PRIVATE KEY-----"";

         dos.writeBytes(encoded);
         dos.flush();
         dos.close();

          //System.out.println(""Private key\n""+privKeyPEM);",3
24005019,0,"          DataOutputStream dos = new DataOutputStream(fos);


          byte[] keyBytes = key.getEncoded();
          BASE64Encoder b64=new BASE64Encoder();
          String  encoded = b64.encodeBuffer(keyBytes);

          encoded= ""-----BEGIN PUBLIC KEY-----\r\n"" + encoded + ""-----END PUBLIC KEY-----"";

         dos.writeBytes(encoded);
         dos.flush();
         dos.close();

          //System.out.println(""Private key\n""+privKeyPEM);",3
24005019,0,"    public  PublicKey getPemPublicKey(String filename, String algorithm) throws Exception {
          File f = new File(filename);
          FileInputStream fis = new FileInputStream(f);
          DataInputStream dis = new DataInputStream(fis);
          byte[] keyBytes = new byte[(int) f.length()];
          dis.readFully(keyBytes);
          dis.close();

          String temp = new String(keyBytes);
          String publicKeyPEM = temp.replace(""-----BEGIN PUBLIC KEY-----\n"", """");
          publicKeyPEM = publicKeyPEM.replace(""-----END PUBLIC KEY-----"", """");


          BASE64Decoder b64=new BASE64Decoder();
          byte[] decoded = b64.decodeBuffer(publicKeyPEM);

          X509EncodedKeySpec spec =
                new X509EncodedKeySpec(decoded);
          KeyFactory kf = KeyFactory.getInstance(algorithm);
          return kf.generatePublic(spec);
          }



",3
24005019,0,"          String publicKeyPEM = temp.replace(""-----BEGIN PUBLIC KEY-----\n"", """");
          publicKeyPEM = publicKeyPEM.replace(""-----END PUBLIC KEY-----"", """");


          BASE64Decoder b64=new BASE64Decoder();
          byte[] decoded = b64.decodeBuffer(publicKeyPEM);

          X509EncodedKeySpec spec =
                new X509EncodedKeySpec(decoded);",3
24013606,4,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
24049807,0,"public static String hmacSha1(String value, String key) throws UnsupportedEncodingException,
        NoSuchAlgorithmException, InvalidKeyException {
    String type = ""HmacSHA1"";
    SecretKeySpec secret = new SecretKeySpec(key.getBytes(), type);
    Mac mac = Mac.getInstance(type);
    mac.init(secret);
    byte[] bytes = mac.doFinal(value.getBytes());
    return bytesToHex(bytes);
}

private final static char[] hexArray = ""0123456789abcdef"".toCharArray();

private static String bytesToHex(byte[] bytes) {
    char[] hexChars = new char[bytes.length * 2];
    int v;
    for (int j = 0; j < bytes.length; j++) {
        v = bytes[j] & 0xFF;
        hexChars[j * 2] = hexArray[v >>> 4];
        hexChars[j * 2 + 1] = hexArray[v & 0x0F];
    }
    return new String(hexChars);
}",4
24049807,0,"    SecretKeySpec secret = new SecretKeySpec(key.getBytes(), type);
    Mac mac = Mac.getInstance(type);
    mac.init(secret);
    byte[] bytes = mac.doFinal(value.getBytes());",4
24104890,2,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
",1
24115112,0,"FileInputStream fis = new FileInputStream(CA_FILE);
X509Certificate ca = (X509Certificate) CertificateFactory.getInstance(""X.509"")
                        .generateCertificate(new BufferedInputStream(fis));

KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
ks.load(null, null);
ks.setCertificateEntry(Integer.toString(1), ca);

TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
tmf.init(ks);
",1
24153608,0,"   public static String hashMac(String text, String secretKey)
                  throws SignatureException {

                 try {
                  Key sk = new SecretKeySpec(secretKey.getBytes(), HASH_ALGORITHM);
                  Mac mac = Mac.getInstance(sk.getAlgorithm());
                  mac.init(sk);
                  final byte[] hmac = mac.doFinal(text.getBytes());
                  return toHexString(hmac);
                 } catch (NoSuchAlgorithmException e1) {
                  // throw an exception or pick a different encryption method
                  throw new SignatureException(
                    ""error building signature, no such algorithm in device ""
                      + HASH_ALGORITHM);
                 } catch (InvalidKeyException e) {
                  throw new SignatureException(
                    ""error building signature, invalid key "" + HASH_ALGORITHM);
                 }",4
24262342,0,"PEMParser pemParser = new PEMParser(new FileReader(file));
Object object = pemParser.readObject();
JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(""BC"");
KeyPair kp;
if (object instanceof PEMEncryptedKeyPair)
{
    // Encrypted key - we will use provided password
    PEMEncryptedKeyPair ckp = (PEMEncryptedKeyPair) object;
    PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(password.toCharArray());
    kp = converter.getKeyPair(ckp.decryptKeyPair(decProv));
}
else
{
    // Unencrypted key - no password needed
    PEMKeyPair ukp = (PEMKeyPair) object;
    kp = converter.getKeyPair(ukp);
}

// RSA
KeyFactory keyFac = KeyFactory.getInstance(""RSA"");
RSAPrivateCrtKeySpec privateKey = keyFac.getKeySpec(kp.getPrivate(), RSAPrivateCrtKeySpec.class);
",3
24264671,4,"public class sample{
 public void foo(){
byte[] decoded = BASE64DecoderStream.decode(KEY.getBytes());
KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
PublicKey publicKey = keyFactory.generatePublic(new X509EncodedKeySpec(decoded));
Signature sig = Signature.getInstance(""SHA1withRSA"");
sig.initVerify(publicKey);
sig.update(signedData.getBytes());
if (sig.verify(BASE64DecoderStream.decode(signature.getBytes())))
{
    // Valid
}

}",4
24264696,4,"public class sample{
 public void foo(){
byte[] decoded = BASE64DecoderStream.decode(KEY.getBytes());
KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
PublicKey publicKey = keyFactory.generatePublic(new X509EncodedKeySpec(decoded));
Signature sig = Signature.getInstance(""SHA1withRSA"");
sig.initVerify(publicKey);
sig.update(signedData.getBytes());
if (sig.verify(BASE64DecoderStream.decode(signature.getBytes())))
{
    // Valid
}

}",4
24339146,0,"    String publicKeyFilename = in.readLine();

    // Load the public key bytes
    FileInputStream fis = new FileInputStream(publicKeyFilename);
    ByteArrayOutputStream baos = new ByteArrayOutputStream();

    int theByte = 0;
    while ((theByte = fis.read()) != -1)",3
24339146,0,"    byte[] iv = new byte[16];
    dis.read(iv);
    IvParameterSpec spec = new IvParameterSpec(iv);

    Cipher cipher = Cipher.getInstance(""Rijndael/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, rijndaelKey, spec);",52
24379185,6,"    public Socket createSocket(InetAddress host, int port) throws IOException
    {
        SSLSocketFactory factory = m_ctx.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);

        ss.setEnabledProtocols(m_protocols);
        ss.setEnabledCipherSuites(m_ciphers);

        return ss;
    }
",1
24379185,6,"    public Socket createSocket(String host, int port) throws IOException
    {
        SSLSocketFactory factory = m_ctx.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);

        ss.setEnabledProtocols(m_protocols);
        ss.setEnabledCipherSuites(m_ciphers);

        return ss;
    }
",1
24408462,2,"    String principal = ""CN=company1, OU=company1, O=company1, C=GB"";
    AsymmetricKeyParameter privateKey = PrivateKeyFactory.createKey(keyPair.getPrivate().getEncoded());
    AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder()
            .find(""SHA1WITHRSA"");
    AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(""SHA-1"");
    ContentSigner signer = new BcRSAContentSignerBuilder(signatureAlgorithm, digestAlgorithm).build(privateKey);

    PKCS10CertificationRequestBuilder csrBuilder = new JcaPKCS10CertificationRequestBuilder(new X500Name(
            principal), keyPair.getPublic());
    ExtensionsGenerator extensionsGenerator = new ExtensionsGenerator();
    extensionsGenerator.addExtension(X509Extension.basicConstraints, true, new BasicConstraints(true));
    extensionsGenerator.addExtension(X509Extension.keyUsage, true, new KeyUsage(KeyUsage.keyCertSign
            | KeyUsage.cRLSign));
    csrBuilder.addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensionsGenerator.generate());",3
24474891,0,"    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
24498252,0,"    CipherInputStream cis = new CipherInputStream(fis, cipher);
    int b;
    byte[] d = new byte[8];
    while ((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }
    fos.flush();
    fos.close();
    cis.close();",2
24498252,0,"    CipherInputStream cis = new CipherInputStream(fis, cipher);
    int b;
    byte[] d = new byte[8];
    while ((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }
    fos.flush();
    fos.close();
    cis.close();",2
24541756,0,"            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            tmf.init((KeyStore)null);
            // Copy current certs into our keystore so we can use it...
            // TODO: don't actually do this...
            X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];",1
24594974,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
24617286,18,"        Store store = signedData.getCertificates(); 
        SignerInformationStore signers = signedData.getSignerInfos(); 
        Collection c = signers.getSigners(); 
        Iterator it = c.iterator();
        while (it.hasNext()) { 
            SignerInformation signer = (SignerInformation) it.next(); 
            Collection certCollection = store.getMatches(signer.getSID()); 
            Iterator certIt = certCollection.iterator();
            X509CertificateHolder certHolder = (X509CertificateHolder) certIt.next();",3
24617286,18,"        Store store = signedData.getCertificates(); 
        SignerInformationStore signers = signedData.getSignerInfos(); 
        Collection c = signers.getSigners(); 
        Iterator it = c.iterator();
        while (it.hasNext()) { 
            SignerInformation signer = (SignerInformation) it.next(); 
            Collection certCollection = store.getMatches(signer.getSID()); 
            Iterator certIt = certCollection.iterator();
            X509CertificateHolder certHolder = (X509CertificateHolder) certIt.next();
            X509Certificate certFromSignedData = new JcaX509CertificateConverter().setProvider(BC_PROVIDER).getCertificate(certHolder);
            if (signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(BC_PROVIDER).build(certFromSignedData))) {
                System.out.println(""Signature verified"");
            } else {
                System.out.println(""Signature verification failed"");
            }
        }",3
24652614,1,"            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i=0; i<messageDigest.length; i++)
                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
            return hexString.toString();
",4
24652614,1,"            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i=0; i<messageDigest.length; i++)
                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
            return hexString.toString();
",4
24652614,1,"            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i=0; i<messageDigest.length; i++)
                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));",4
24652614,1,"            byte messageDigest[] = digest.digest();

            // Create Hex String
            StringBuffer hexString = new StringBuffer();
            for (int i=0; i<messageDigest.length; i++)
                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
            return hexString.toString();
",4
24718746,0,"            IvParameterSpec ivSpec = ivCreator.createIV();
            gcm.init(Cipher.ENCRYPT_MODE, aesKey, ivSpec);
            gcm.updateAAD(ivSpec.getIV());
            byte[] ciphertext = gcm.doFinal(""owlstead"".getBytes(StandardCharsets.UTF_8));
            System.out.println(Hex.toHexString(ciphertext));
            gcm.init(Cipher.DECRYPT_MODE, aesKey, ivSpec);
            gcm.updateAAD(ivSpec.getIV());
            byte[] plaintext = gcm.doFinal(ciphertext);
            System.out.println(new String(plaintext, StandardCharsets.UTF_8));
",2
24718746,0,"            IvParameterSpec ivSpec = ivCreator.createIV();
            gcm.init(Cipher.ENCRYPT_MODE, aesKey, ivSpec);
            gcm.updateAAD(ivSpec.getIV());
            byte[] ciphertext = gcm.doFinal(""owlstead"".getBytes(StandardCharsets.UTF_8));
            System.out.println(Hex.toHexString(ciphertext));
            gcm.init(Cipher.DECRYPT_MODE, aesKey, ivSpec);
            gcm.updateAAD(ivSpec.getIV());
            byte[] plaintext = gcm.doFinal(ciphertext);
            System.out.println(new String(plaintext, StandardCharsets.UTF_8));",2
24768356,2,"    public static class NamedOAuthPrincipal extends ConsumerCredentials implements Principal {
        public String name;
        public Collection<GrantedAuthority> authorities;

        public NamedOAuthPrincipal(String name, Collection<GrantedAuthority> authorities, String consumerKey, String signature, String signatureMethod, String signatureBaseString, String token) {
            super(consumerKey, signature, signatureMethod, signatureBaseString, token);
            this.name = name;
            this.authorities = authorities;
        }

        @Override
        public String getName() {
            return name;
        }

        public Collection<? extends GrantedAuthority> getAuthorities() {
            return authorities;
        }
    }",-1
24953325,0,"                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    Log.i(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                    }",4
24972102,0,"        byte[] saltBytes = salt.getBytes(""UTF-8"");

        // Derive the key
        SecretKeyFactory factory = SecretKeyFactory
                .getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), saltBytes,
                pswdIterations, keySize);

        SecretKey secretKey = factory.generateSecret(spec);
        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        // encrypt the message",2
24972102,0,"        SecretKeyFactory factory = SecretKeyFactory
                .getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), saltBytes,
                pswdIterations, keySize);

        SecretKey secretKey = factory.generateSecret(spec);
        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        // encrypt the message
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(ivBytes));",2
24972102,0,"        SecretKey secretKey = factory.generateSecret(spec);
        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        // encrypt the message
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(ivBytes));",2
24972102,0,"        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        // encrypt the message
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(ivBytes));",2
24972102,0,"        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        // encrypt the message
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(ivBytes));",2
24972102,0,"        SecretKeyFactory factory = SecretKeyFactory
                .getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(password.toCharArray(), saltBytes,
                pswdIterations, keySize);

        SecretKey secretKey = factory.generateSecret(spec);
        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        // Decrypt the message
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secret,
                new IvParameterSpec(ivBytes));
",2
24972102,0,"        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        // Decrypt the message
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secret,
                new IvParameterSpec(ivBytes));
",2
24972102,0,"        SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        // Decrypt the message
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secret,
                new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;
        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return new String(decryptedTextBytes);",2
24973265,3,"    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    AlgorithmParameters params = cipher.getParameters();
    byte[] ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();",2
24973818,1,"    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.e(""MY_KEY_HASH:"",
                Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }",4
24983617,0,"    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
25006553,9,"public static class NamedOAuthPrincipal extends ConsumerCredentials implements Principal {
    public String name;
    public Collection<GrantedAuthority> authorities;
    public NamedOAuthPrincipal(String name, Collection<GrantedAuthority> authorities, String consumerKey, String signature, String signatureMethod, String signatureBaseString, String token) {
        super(consumerKey, signature, signatureMethod, signatureBaseString, token);
        this.name = name;
        this.authorities = authorities;
    }
    @Override
    public String getName() {
        return name;
    }
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }
}",-1
25051085,1,"        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec keySpec = new PBEKeySpec(hash, salt, 65536, 128);
        SecretKey tmp = factory.generateSecret(keySpec);
        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        return secret;",2
25123606,1,"        MessageDigest digest = java.security.MessageDigest.getInstance(""SHA-512""); 
        digest.update(password.getBytes(""UTF-16LE"")); 
        byte messageDigest[] = digest.digest();

        StringBuilder sb = new StringBuilder();",4
25123606,1,"        byte messageDigest[] = digest.digest();

        StringBuilder sb = new StringBuilder();
        for(int iPos = 0; iPos < messageDigest.length; iPos++) {
            String h = Integer.toHexString(0xFF & messageDigest[iPos]);
            while (h.length() < 2) {
                h = ""0"" + h;
            }
            sb.append(h);
        }
",4
25185593,0," public PublicKey readPublicKeyFromFile(String fileName) throws IOException{  
  FileInputStream fis = null;  
  ObjectInputStream ois = null;  
  try {  
   fis = new FileInputStream(new File(fileName));  
   ois = new ObjectInputStream(fis);  

   BigInteger modulus = (BigInteger) ois.readObject();  
      BigInteger exponent = (BigInteger) ois.readObject();  

      //Get Public Key  
      RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(modulus, exponent);  
      KeyFactory fact = KeyFactory.getInstance(""RSA"");  
      PublicKey publicKey = fact.generatePublic(rsaPublicKeySpec);  

      return publicKey;  

  } catch (Exception e) {  
   e.printStackTrace();  
  }  
  finally{  
   if(ois != null){
    ois.close();  
    if(fis != null){
     fis.close();
    }
   }  
  }  
  return null;  
 }  

 /** 
  * read Public Key From File 
  * @param fileName 
  * @return 
  * @throws IOException 
  */  ",3
25185593,0," public PrivateKey readPrivateKeyFromFile(String fileName) throws IOException{  
  FileInputStream fis = null;  
  ObjectInputStream ois = null;  
  try {  
   fis = new FileInputStream(new File(fileName));  
   ois = new ObjectInputStream(fis);  

   BigInteger modulus = (BigInteger) ois.readObject();  
      BigInteger exponent = (BigInteger) ois.readObject();  

      //Get Private Key  
      RSAPrivateKeySpec rsaPrivateKeySpec = new RSAPrivateKeySpec(modulus, exponent);  
      KeyFactory fact = KeyFactory.getInstance(""RSA"");  
      PrivateKey privateKey = fact.generatePrivate(rsaPrivateKeySpec);  

      return privateKey;  

  } catch (Exception e) {  
   e.printStackTrace();  
  }  
  finally{  
   if(ois != null){  
    ois.close();  
    if(fis != null){  
     fis.close();  
    }  
   }  
  }  
  return null;  
 }  ",3
25218593,0,"class PEMConverter {

    public static String toPEM(PublicKey pubKey) {
        StringWriter sw = new StringWriter();
        JcaPEMWriter pemWriter = new JcaPEMWriter(sw);
        pemWriter.writeObject(pubKey);
        pemWriter.close();
        return sw.toString();
    }
}",1
25229051,1,"        byte k[] = password.getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        sha.update(salt);
        k = sha.digest(k);
        k = Arrays.copyOf(k, 16);
        for (int i = 0; i < k.length; i++)
            System.out.print(k[i]);
        System.out.println();

        SecretKeySpec key = new SecretKeySpec(k, algo);
        // creating and initialising cipher and cipher streams
        Cipher encrypt = Cipher.getInstance(algo);
        encrypt.init(Cipher.ENCRYPT_MODE, key);
        // opening streams",4
25229051,1,"        byte k[] = password.getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        sha.update(salt);
        k = sha.digest(k);
        k = Arrays.copyOf(k, 16);
        for (int i = 0; i < k.length; i++)
            System.out.print(k[i]);
        System.out.println();
        SecretKeySpec key = new SecretKeySpec(k, algo);
        // creating and initialising cipher and cipher streams
        Cipher decrypt = Cipher.getInstance(algo);
        decrypt.init(Cipher.DECRYPT_MODE, key);
        // opening streams",4
25249177,2,"        final Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

        // initialization
        c.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(keyData, ""AES""), new IvParameterSpec(ivData));

        // and encryption
        final byte[] ciphertext = c.doFinal(testData);

        // Bouncy Castle creation",2
25251120,0,"                    byte[] array = md.digest(txt.getBytes());
                    StringBuffer sb = new StringBuffer();
                    for (int i = 0; i < array.length; ++i) {
                        sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3));
                 }
                    return sb.toString();",4
25262681,0,"for (Signature signature : info.signatures){
       MessageDigest md = MessageDigest.getInstance(""SHA"");
       md.update(signature.toByteArray());
       Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
}",4
25263204,0,"for (Signature signature : info.signatures){
       MessageDigest md = MessageDigest.getInstance(""SHA"");
       md.update(signature.toByteArray());
       Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
}",4
25291957,0,"    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }",4
25326878,0,"public class sample{
private void printKeyHash() {
    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(""YOUR PACKAGE NAME"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {
        Log.e(""KeyHash:"", e.toString());
    } catch (NoSuchAlgorithmException e) {
        Log.e(""KeyHash:"", e.toString());
    }
}
",4
25326878,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
25326894,0,"public class sample{
private void printKeyHash() {
    // Add code to print out the key hash
    try {
        PackageInfo info = getPackageManager().getPackageInfo(""YOUR PACKAGE NAME"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }
    } catch (NameNotFoundException e) {
        Log.e(""KeyHash:"", e.toString());
    } catch (NoSuchAlgorithmException e) {
        Log.e(""KeyHash:"", e.toString());
    }
}
",4
25326894,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
25354940,0,"            final SecretKeyFactory factory = SecretKeyFactory
                    .getInstance(""PBKDF2WithHmacSHA1"");
            final KeySpec spec = new PBEKeySpec(password, salt, 65536, 256);
            final SecretKey keyWrapKey = factory.generateSecret(spec);
            final SecretKey secret = new SecretKeySpec(keyWrapKey.getEncoded(),
                    ""AES"");
            return secret;
",2
25354940,0,"            final byte[] iv = new byte[c.getBlockSize()];
            ivGen.nextBytes(iv);
            c.init(Cipher.WRAP_MODE, aesKey, new IvParameterSpec(iv));
            final byte[] wrappedKey = c.wrap(rsaPrivateKey);",5
25403311,0,"public class ExportPrivateKey {
        private File keystoreFile;
        private String keyStoreType;
        private char[] password;
        private String alias;
        private File exportedFile;

        public static KeyPair getPrivateKey(KeyStore keystore, String alias, char[] password) {
                try {
                        Key key=keystore.getKey(alias,password);
                        if(key instanceof PrivateKey) {
                                Certificate cert=keystore.getCertificate(alias);
                                PublicKey publicKey=cert.getPublicKey();
                                return new KeyPair(publicKey,(PrivateKey)key);
                        }
                } catch (UnrecoverableKeyException e) {
        } catch (NoSuchAlgorithmException e) {
        } catch (KeyStoreException e) {
        }
        return null;
        }

        public void export() throws Exception{
                KeyStore keystore=KeyStore.getInstance(keyStoreType);
                BASE64Encoder encoder=new BASE64Encoder();
                keystore.load(new FileInputStream(keystoreFile),password);
                KeyPair keyPair=getPrivateKey(keystore,alias,password);
                PrivateKey privateKey=keyPair.getPrivate();
                String encoded=encoder.encode(privateKey.getEncoded());
                FileWriter fw=new FileWriter(exportedFile);
                fw.write(“—–BEGIN PRIVATE KEY—–\n“);
                fw.write(encoded);
                fw.write(“\n“);
                fw.write(“—–END PRIVATE KEY—–”);
                fw.close();
        }


        public static void main(String args[]) throws Exception{
                ExportPrivateKey export=new ExportPrivateKey();
                export.keystoreFile=new File(args[0]);
                export.keyStoreType=args[1];
                export.password=args[2].toCharArray();
                export.alias=args[3];
                export.exportedFile=new File(args[4]);
                export.export();
        }
}",3
25493879,0,"        BigInteger x = new BigInteger(1, Arrays.copyOfRange(pubkey, offset,
                offset + keySizeBytes));
        offset += keySizeBytes;
        BigInteger y = new BigInteger(1, Arrays.copyOfRange(pubkey, offset,
                offset + keySizeBytes));
        ECPoint w = new ECPoint(x, y);

        ECPublicKeySpec otherKeySpec = new ECPublicKeySpec(w, params);
        KeyFactory keyFactory = KeyFactory.getInstance(""EC"");",3
25513442,0,"    public Server(SecretKey key,IvParameterSpec spec) {
        try {
            cipher=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, key,spec);
        } catch (Exception e) {
            e.printStackTrace();
        }

",2
25513442,0,"public Client(SecretKey key, IvParameterSpec spec){
        try {
            cipher=Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, key, spec);
        } catch (Exception e) {
             e.printStackTrace();
        }",2
25524657,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String hashKey = new String(Base64.encode(md.digest(), 0));
                Log.i(TAG, ""printHashKey() Hash Key: "" + hashKey);
            }",4
25546069,0,"private byte[] encrypt(String key, String plainText) throws GeneralSecurityException {

    SecretKey secret_key = new SecretKeySpec(key.getBytes(), ALGORITM);

    Cipher cipher = Cipher.getInstance(ALGORITM);
    cipher.init(Cipher.ENCRYPT_MODE, secret_key);

    return cipher.doFinal(plainText.getBytes());
}
",2
25546069,0,"    SecretKey secret_key = new SecretKeySpec(key.getBytes(), ALGORITM);

    Cipher cipher = Cipher.getInstance(ALGORITM);
    cipher.init(Cipher.DECRYPT_MODE, secret_key);

    byte[] decrypted = cipher.doFinal(encryptedText);
",2
25567377,0,"public class UseKeyTool {

    private static final int keysize = 1024;
    private static final String commonName = ""www.test.de"";
    private static final String organizationalUnit = ""IT"";
    private static final String organization = ""test"";
    private static final String city = ""test"";
    private static final String state = ""test"";
    private static final String country = ""DE"";
    private static final long validity = 1096; // 3 years
    private static final String alias = ""tomcat"";
    private static final char[] keyPass = ""changeit"".toCharArray();

    // copied most ideas from sun.security.tools.KeyTool.java

    @SuppressWarnings(""restriction"")
    public static void main(String[] args) throws Exception {

        KeyStore keyStore = KeyStore.getInstance(""JKS"");
        keyStore.load(null, null);

        CertAndKeyGen keypair = new CertAndKeyGen(""RSA"", ""SHA1WithRSA"", null);

        X500Name x500Name = new X500Name(commonName, organizationalUnit, organization, city, state, country);

        keypair.generate(keysize);
        PrivateKey privKey = keypair.getPrivateKey();

        X509Certificate[] chain = new X509Certificate[1];

        chain[0] = keypair.getSelfCertificate(x500Name, new Date(), (long) validity * 24 * 60 * 60);

        keyStore.setKeyEntry(alias, privKey, keyPass, chain);

        keyStore.store(new FileOutputStream("".keystore""), keyPass);



    }
}",3
25620345,0,"public class sample{
 public void foo(){
     HttpClientBuilder cb = HttpClientBuilder.create();
     SSLContextBuilder sslcb = new SSLContextBuilder();
     sslcb.loadTrustMaterial(KeyStore.getInstance(KeyStore.getDefaultType()), new TrustSelfSignedStrategy());
     cb.setSslcontext(sslcb.build());
     CloseableHttpClient httpclient = cb.build();

}",1
25620572,0,"public class sample{
 public void foo(){
     HttpClientBuilder cb = HttpClientBuilder.create();
     SSLContextBuilder sslcb = new SSLContextBuilder();
     sslcb.loadTrustMaterial(KeyStore.getInstance(KeyStore.getDefaultType()), new TrustSelfSignedStrategy());
     cb.setSslcontext(sslcb.build());
     CloseableHttpClient httpclient = cb.build();

}",1
25621171,5,"    KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
    FileInputStream io = new FileInputStream(""path/to/jks/file.jks"");
    try{
        keystore.load(io, ""pass"".toCharArray());
    } finally {
        io.close();
    }
",1
25621171,7,"    KeyStore trustStore= KeyStore.getInstance(KeyStore.getDefaultType());
    FileInputStream stream = new FileInputStream(""path/to/truststore/file.jks"");
    try{
        keystore.load(stream, ""trusted"".toCharArray());
    } finally {
        stream.close();
    }
",1
25650305,10,"public class sample{
 public void foo(){
String keypass = ""password"";  // this is a new password, you need to come up with to protect your java key store file
String defaultalias = ""importkey"";
KeyStore ks = KeyStore.getInstance(""JKS"", ""SUN"");

// this section does not make much sense to me, 
// but I will leave it intact as this is how it was in the original example I found on internet:   
ks.load( null, keypass.toCharArray());
ks.store( new FileOutputStream ( ""mykeystore""  ), keypass.toCharArray());
ks.load( new FileInputStream ( ""mykeystore"" ),    keypass.toCharArray());
// end of section..


// read the key file from disk and create a PrivateKey

FileInputStream fis = new FileInputStream(""pkey.der"");
DataInputStream dis = new DataInputStream(fis);
byte[] bytes = new byte[dis.available()];
dis.readFully(bytes);
ByteArrayInputStream bais = new ByteArrayInputStream(bytes);

byte[] key = new byte[bais.available()];
KeyFactory kf = KeyFactory.getInstance(""RSA"");
bais.read(key, 0, bais.available());
bais.close();

PKCS8EncodedKeySpec keysp = new PKCS8EncodedKeySpec ( key );
PrivateKey ff = kf.generatePrivate (keysp);


// read the certificates from the files and load them into the key store:

Collection  col_crt1 = CertificateFactory.getInstance(""X509"").generateCertificates(new FileInputStream(""cert1.pem""));
Collection  col_crt2 = CertificateFactory.getInstance(""X509"").generateCertificates(new FileInputStream(""cert2.pem""));

Certificate crt1 = (Certificate) col_crt1.iterator().next();
Certificate crt2 = (Certificate) col_crt2.iterator().next();
Certificate[] chain = new Certificate[] { crt1, crt2 };

String alias1 = ((X509Certificate) crt1).getSubjectX500Principal().getName();
String alias2 = ((X509Certificate) crt2).getSubjectX500Principal().getName();

ks.setCertificateEntry(alias1, crt1);
ks.setCertificateEntry(alias2, crt2);

// store the private key
ks.setKeyEntry(defaultalias, ff, keypass.toCharArray(), chain );

// save the key store to a file         
ks.store(new FileOutputStream ( ""mykeystore"" ),keypass.toCharArray());

}",3
25650305,13,"        HostnameVerifier hv = new HostnameVerifier()
        {
            public boolean verify(String urlHostName, SSLSession session)
            {
                if (!urlHostName.equalsIgnoreCase(session.getPeerHost()))
                {
                    System.out.println(""Warning: URL host '"" + urlHostName + ""' is different to SSLSession host '"" + session.getPeerHost() + ""'."");
                }
                return true;
            }
        };

        HttpsURLConnection.setDefaultSSLSocketFactory( sclx.getSocketFactory() );
        HttpsURLConnection.setDefaultHostnameVerifier(hv);
",1
25670408,2,"public class sample{
 public void foo(){
String keypass = ""password"";  // this is a new password, you need to come up with to protect your java key store file
String defaultalias = ""importkey"";
KeyStore ks = KeyStore.getInstance(""JKS"", ""SUN"");

// this section does not make much sense to me, 
// but I will leave it intact as this is how it was in the original example I found on internet:   
ks.load( null, keypass.toCharArray());
ks.store( new FileOutputStream ( ""mykeystore""  ), keypass.toCharArray());
ks.load( new FileInputStream ( ""mykeystore"" ),    keypass.toCharArray());
// end of section..


// read the key file from disk and create a PrivateKey

FileInputStream fis = new FileInputStream(""pkey.der"");
DataInputStream dis = new DataInputStream(fis);
byte[] bytes = new byte[dis.available()];
dis.readFully(bytes);
ByteArrayInputStream bais = new ByteArrayInputStream(bytes);

byte[] key = new byte[bais.available()];
KeyFactory kf = KeyFactory.getInstance(""RSA"");
bais.read(key, 0, bais.available());
bais.close();

PKCS8EncodedKeySpec keysp = new PKCS8EncodedKeySpec ( key );
PrivateKey ff = kf.generatePrivate (keysp);


// read the certificates from the files and load them into the key store:

Collection  col_crt1 = CertificateFactory.getInstance(""X509"").generateCertificates(new FileInputStream(""cert1.pem""));
Collection  col_crt2 = CertificateFactory.getInstance(""X509"").generateCertificates(new FileInputStream(""cert2.pem""));

Certificate crt1 = (Certificate) col_crt1.iterator().next();
Certificate crt2 = (Certificate) col_crt2.iterator().next();
Certificate[] chain = new Certificate[] { crt1, crt2 };

String alias1 = ((X509Certificate) crt1).getSubjectX500Principal().getName();
String alias2 = ((X509Certificate) crt2).getSubjectX500Principal().getName();

ks.setCertificateEntry(alias1, crt1);
ks.setCertificateEntry(alias2, crt2);

// store the private key
ks.setKeyEntry(defaultalias, ff, keypass.toCharArray(), chain );

// save the key store to a file         
ks.store(new FileOutputStream ( ""mykeystore"" ),keypass.toCharArray());

}",3
25670408,5,"        HostnameVerifier hv = new HostnameVerifier()
        {
            public boolean verify(String urlHostName, SSLSession session)
            {
                if (!urlHostName.equalsIgnoreCase(session.getPeerHost()))
                {
                    System.out.println(""Warning: URL host '"" + urlHostName + ""' is different to SSLSession host '"" + session.getPeerHost() + ""'."");
                }
                return true;
            }
        };

        HttpsURLConnection.setDefaultSSLSocketFactory( sclx.getSocketFactory() );
        HttpsURLConnection.setDefaultHostnameVerifier(hv);
",1
25715190,0,"    dcipher.init(Cipher.DECRYPT_MODE, key);
    byte[] dec = BASE64DecoderStream.decode(str.getBytes());
    byte[] utf8 = dcipher.doFinal(dec);
    return new String(utf8, ""UTF8"");",2
25851092,0,"KeyFactory keyFactory = KeyFactory.getInstance(""RSA"",""BS"");
PublicKey publicKey = keyFactory.generatePublic(rsaPublicKeySpec);
Cipher cipher = Cipher.getInstance(""RSA/None/PKCS1Padding"", ""BS"");
cipher.init(Cipher.ENCRYPT_MODE, publicKey);",3
25864445,0," public class Crypto {

        private static final String engine = ""AES"";
        private static final String crypto = ""AES/CBC/PKCS5Padding"";
        private static Context ctx;

        public Crypto(Context cntx) {
            ctx = cntx;
        }

        public byte[] cipher(byte[] data, int mode)
                throws NoSuchAlgorithmException, NoSuchPaddingException,
                InvalidKeyException, IllegalBlockSizeException,
                BadPaddingException, InvalidAlgorithmParameterException {
            KeyManager km = new KeyManager(ctx);
            SecretKeySpec sks = new SecretKeySpec(km.getId(), engine);
            IvParameterSpec iv = new IvParameterSpec(km.getIv());
            Cipher c = Cipher.getInstance(crypto);
            c.init(mode, sks, iv);
            return c.doFinal(data);
        }

        public byte[] encrypt(byte[] data) throws InvalidKeyException,
                NoSuchAlgorithmException, NoSuchPaddingException,
                IllegalBlockSizeException, BadPaddingException,
                InvalidAlgorithmParameterException {
            return cipher(data, Cipher.ENCRYPT_MODE);
        }

        public byte[] decrypt(byte[] data) throws InvalidKeyException,
                NoSuchAlgorithmException, NoSuchPaddingException,
                IllegalBlockSizeException, BadPaddingException,
                InvalidAlgorithmParameterException {
            return cipher(data, Cipher.DECRYPT_MODE);
        }

        public String armorEncrypt(byte[] data) throws InvalidKeyException,
                NoSuchAlgorithmException, NoSuchPaddingException,
                IllegalBlockSizeException, BadPaddingException,
                InvalidAlgorithmParameterException {
            return Base64.encodeToString(encrypt(data), Base64.DEFAULT);
        }

        public String armorDecrypt(String data) throws InvalidKeyException,
                NoSuchAlgorithmException, NoSuchPaddingException,
                IllegalBlockSizeException, BadPaddingException,
                InvalidAlgorithmParameterException {
            return new String(decrypt(Base64.decode(data, Base64.DEFAULT)));
        }
    }",2
25904507,0,"    byte[] trimbuf = new byte[nread];
    for(int i=0;i<nread;i++)
        trimbuf[i] = inbuf[i];

    byte[] newtmp = sCipher.update(trimbuf);
    if(newtmp != null)
        fout.write(newtmp);",-1
26008952,1,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"",
                    Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
26070138,10,"        IvParameterSpec ivSpec = new IvParameterSpec(cryptionIV);
        SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");
        Cipher cipherAES = Cipher.getInstance(""AES/CBC/ZeroBytePadding"");
        cipherAES.init(Cipher.DECRYPT_MODE, skeySpec, ivSpec);",2
26123875,0,"public class sample{
 public void foo(){
String pubKey = ""tihq/Gk3OUs5NzP+XTRKXBwSxHtB0TWn0RREcpXEtp316tyD9DzKaIbdKexb/mRr""; //64 caratteri
String exponent = ""AQAB"";

byte[] keyBytes = Base64.decode(pubKey,Base64.DEFAULT);
byte[] exponentByte = Base64.decode(exponent,Base64.DEFAULT);

KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");

RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(keyBytes), new BigInteger(exponentByte));
RSAPublicKey publicKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);

}",3
26123946,0,"public class sample{
 public void foo(){
String pubKey = ""your_modulus"";
String exponent = ""your_exponent"";

byte[] keyBytes = Base64.decode(pubKey,Base64.DEFAULT);
byte[] exponentByte = Base64.decode(exponent,Base64.DEFAULT);

KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");

RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(keyBytes), new BigInteger(exponentByte));
RSAPublicKey publicKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);

}",3
26195468,4,"    BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new AESFastEngine());

    cipher.init(true, key);
    byte[] result = new byte[cipher.getOutputSize(toEncrypt.length)];
    int len = cipher.processBytes(toEncrypt, 0, toEncrypt.length, result, 0);
    cipher.doFinal(result, len);",2
26195468,4,"    BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new AESFastEngine());

    cipher.init(true, key);
    byte[] result = new byte[cipher.getOutputSize(toEncrypt.length)];
    int len = cipher.processBytes(toEncrypt, 0, toEncrypt.length, result, 0);
    cipher.doFinal(result, len);
    return result;",2
26195468,4,"    cipher.init(true, key);
    byte[] result = new byte[cipher.getOutputSize(toEncrypt.length)];
    int len = cipher.processBytes(toEncrypt, 0, toEncrypt.length, result, 0);
    cipher.doFinal(result, len);
    return result;",2
26195468,4,"    byte[] result = new byte[cipher.getOutputSize(toEncrypt.length)];
    int len = cipher.processBytes(toEncrypt, 0, toEncrypt.length, result, 0);
    cipher.doFinal(result, len);",2
26195468,4,"    BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new AESFastEngine());

    cipher.init(false, key);
    byte[] result = new byte[cipher.getOutputSize(toDecrypt.length)];
    int len = cipher.processBytes(toDecrypt, 0, toDecrypt.length, result, 0);
    cipher.doFinal(result, len);",2
26195468,4,"    BufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new AESFastEngine());

    cipher.init(false, key);
    byte[] result = new byte[cipher.getOutputSize(toDecrypt.length)];
    int len = cipher.processBytes(toDecrypt, 0, toDecrypt.length, result, 0);
    cipher.doFinal(result, len);",2
26195468,4,"    cipher.init(false, key);
    byte[] result = new byte[cipher.getOutputSize(toDecrypt.length)];
    int len = cipher.processBytes(toDecrypt, 0, toDecrypt.length, result, 0);
    cipher.doFinal(result, len);",2
26195468,4,"    byte[] result = new byte[cipher.getOutputSize(toDecrypt.length)];
    int len = cipher.processBytes(toDecrypt, 0, toDecrypt.length, result, 0);
    cipher.doFinal(result, len);",2
26224052,7,"String pkcs11ConfigSettings = ""name = "" + pkcs11ID + ""\n"" + ""library = "" + libraryPath;
byte[] pkcs11ConfigBytes = pkcs11ConfigSettings.getBytes();
ByteArrayInputStream confStream = new ByteArrayInputStream(pkcs11ConfigBytes);

// instantiate the provider
SunPKCS11 pkcs11 = new SunPKCS11(confStream);
Security.addProvider(pkcs11);   ",3
26224052,16,"String pkcs11ConfigSettings = ""name = "" + pkcs11ID + ""\n"" + ""library = "" + libraryPath;
byte[] pkcs11ConfigBytes = pkcs11ConfigSettings.getBytes();
ByteArrayInputStream confStream = new ByteArrayInputStream(pkcs11ConfigBytes);

// instantiate the provider
SunPKCS11 pkcs11 = new SunPKCS11(confStream);
Security.addProvider(pkcs11);   ",3
26239980,0,"        PEMParser pemParser = new PEMParser(new StringReader(privateKey));
        Object object = pemParser.readObject();
        PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(pwd.toCharArray());
        JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(""BC"");
        KeyPair kp;
        if (object instanceof PEMEncryptedKeyPair) {
            kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));",3
26258075,1,"public class sample{
public static void printHashKey(Context pContext) {
        try {
            PackageInfo info = getPackageInfo(pContext, PackageManager.GET_SIGNATURES);
            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String hashKey = new String(Base64.encode(md.digest(), 0));
                Log.i(TAG, ""printHashKey() Hash Key: "" + hashKey);
            }
        } catch (NoSuchAlgorithmException e) {
            Log.e(TAG, ""printHashKey()"", e);
        } catch (Exception e) {
            Log.e(TAG, ""printHashKey()"", e);
        }
    }
",4
26258075,1,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String hashKey = new String(Base64.encode(md.digest(), 0));
                Log.i(TAG, ""printHashKey() Hash Key: "" + hashKey);
            }",4
26296883,0,"        String key = ""myKey"";
        // Get an hmac_sha1 key from the raw key bytes
        byte[] keyBytes = key.getBytes();
        SecretKeySpec signingKey = new SecretKeySpec(keyBytes, ""HmacSHA1"");

        // Get an hmac_sha1 Mac instance and initialize with the signing key
        Mac mac = Mac.getInstance(""HmacSHA1"");
        mac.init(signingKey);

        // Compute the hmac on input data bytes",4
26296883,0,"        byte[] keyBytes = key.getBytes();
        SecretKeySpec signingKey = new SecretKeySpec(keyBytes, ""HmacSHA1"");

        // Get an hmac_sha1 Mac instance and initialize with the signing key
        Mac mac = Mac.getInstance(""HmacSHA1"");
        mac.init(signingKey);

        // Compute the hmac on input data bytes
        byte[] rawHmac = mac.doFinal(data.getBytes());

        // Convert raw bytes to Hex",4
26296883,0,"        Mac mac = Mac.getInstance(""HmacSHA1"");
        mac.init(signingKey);

        // Compute the hmac on input data bytes
        byte[] rawHmac = mac.doFinal(data.getBytes());

        // Convert raw bytes to Hex
        byte[] hexBytes = new Hex().encode(rawHmac);

        //  Covert array of Hex bytes to a String
        result = new String(hexBytes, ""ISO-8859-1"");",4
26360289,0,"    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keystore);
    TrustManager[] trustmanagers = factory.getTrustManagers();
    if (trustmanagers.length == 0) {
        throw new NoSuchAlgorithmException(""no trust manager found"");
    }
    this.standardTrustManager = (X509TrustManager) trustmanagers[0];",1
26360289,1,"    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

    if ((localAddress != null) || (localPort > 0)) {
        // we need to bind explicitly
        if (localPort < 0) {
            localPort = 0; // indicates ""any""
        }
        InetSocketAddress isa = new InetSocketAddress(localAddress, localPort);
        sslsock.bind(isa);
    }
",1
26360289,1,"public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
}

// -------------------------------------------------------------------
// javadoc in org.apache.http.conn.scheme.SocketFactory says :
// Both Object.equals() and Object.hashCode() must be overridden
// for the correct operation of some connection managers
// -------------------------------------------------------------------

public boolean equals(Object obj) {
    return ((obj != null) && obj.getClass().equals(SSLSocketFactory.class));
}

public int hashCode() {
    return SSLSocketFactory.class.hashCode();
}",1
26380548,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
26402029,0,"    String privKeyStr = DatatypeConverter.printBase64Binary(privKeyBytes);

    /* Decode private key as PKCS#8 base64 string */
    byte[] privKeyBytes2 = DatatypeConverter.parseBase64Binary(privKeyStr);
    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
    PKCS8EncodedKeySpec privSpec = new PKCS8EncodedKeySpec(privKeyBytes2);
    PrivateKey privateKey = keyFactory.generatePrivate(privSpec);

    /* Ensure key is the same */",3
26450047,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String sign = Base64
                        .encodeToString(md.digest(), Base64.DEFAULT);

                    Log.e(""MY KEY HASH:"", sign);

            }",4
26499496,1,"    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    SecretKeySpec secretKeySpecy = new SecretKeySpec(key, ""AES"");
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpecy, ivParameterSpec);",2
26499496,1,"    SecretKeySpec secretKeySpecy = new SecretKeySpec(key, ""AES"");
    IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpecy, ivParameterSpec);
    byte[] encrypted = cipher.doFinal(clearText.getBytes());",2
26525796,0,"    KeyStore trusted = KeyStore.getInstance(""BKS"");

    InputStream in = context.getResources().openRawResource(R.raw.myfile);

    try {
        // Initialisation de notre keystore. On entre le mot de passe (storepass)
        trusted.load(in, ""mypassword"".toCharArray());
    } finally {
        in.close();
    }

",1
26613159,0,"BigInteger modulus = new BigInteger(1, modulusBytes );               
BigInteger exponent = new BigInteger(1, exponentBytes);

RSAPublicKeySpec rsaPubKey = new RSAPublicKeySpec(modulus, exponent);

KeyFactory fact = KeyFactory.getInstance(""RSA"");

PublicKey pubKey = fact.generatePublic(rsaPubKey);

Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");

cipher.init(Cipher.ENCRYPT_MODE, pubKey);
",3
26678732,0,"        X509CertificateHolder certHolder = (X509CertificateHolder) pem.readObject();
        java.security.cert.Certificate X509Certificate =
            new JcaX509CertificateConverter().setProvider(""SC"")
                .getCertificate(certHolder);

        pem.close();
        reader.close();

        // Put them into a PKCS12 keystore and write it to a byte[]
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        KeyStore ks = KeyStore.getInstance(""PKCS12"");
        ks.load(null);
        ks.setKeyEntry(""alias"", (Key) key, password.toCharArray(),
            new java.security.cert.Certificate[]{X509Certificate});
        ks.store(bos, password.toCharArray());
        bos.close();
        return bos.toByteArray();",1
26678732,0,"        pem.close();
        reader.close();

        // Put them into a PKCS12 keystore and write it to a byte[]
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        KeyStore ks = KeyStore.getInstance(""PKCS12"");
        ks.load(null);
        ks.setKeyEntry(""alias"", (Key) key, password.toCharArray(),
            new java.security.cert.Certificate[]{X509Certificate});
        ks.store(bos, password.toCharArray());
        bos.close();
        return bos.toByteArray();",1
26678732,0,"        ks.load(null);
        ks.setKeyEntry(""alias"", (Key) key, password.toCharArray(),
            new java.security.cert.Certificate[]{X509Certificate});
        ks.store(bos, password.toCharArray());
        bos.close();",1
26702631,0,"        Store store = signedData.getCertificates(); 
        SignerInformationStore signers = signedData.getSignerInfos(); 
        Collection c = signers.getSigners(); 
        Iterator it = c.iterator();
        while (it.hasNext()) { 
            SignerInformation signer = (SignerInformation) it.next(); 
            Collection certCollection = store.getMatches(signer.getSID()); 
            Iterator certIt = certCollection.iterator();
            X509CertificateHolder certHolder = (X509CertificateHolder) certIt.next();",3
26702631,0,"        Store store = signedData.getCertificates(); 
        SignerInformationStore signers = signedData.getSignerInfos(); 
        Collection c = signers.getSigners(); 
        Iterator it = c.iterator();
        while (it.hasNext()) { 
            SignerInformation signer = (SignerInformation) it.next(); 
            Collection certCollection = store.getMatches(signer.getSID()); 
            Iterator certIt = certCollection.iterator();
            X509CertificateHolder certHolder = (X509CertificateHolder) certIt.next();
            X509Certificate certFromSignedData = new JcaX509CertificateConverter().setProvider(BC_PROVIDER).getCertificate(certHolder);
            if (signer.verify(new JcaSimpleSignerInfoVerifierBuilder().setProvider(BC_PROVIDER).build(certFromSignedData))) {
                System.out.println(""Signature verified"");
            } else {
                System.out.println(""Signature verification failed"");
            }
        }",3
26711907,0,"  public static void main(String[] argv) throws Exception {
    FileInputStream is = new FileInputStream(""your.keystore"");

    KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
    keystore.load(is, ""my-keystore-password"".toCharArray());

    String alias = ""myalias"";

    Key key = keystore.getKey(alias, ""password"".toCharArray());
    if (key instanceof PrivateKey) {
      // Get certificate of public key
      Certificate cert = keystore.getCertificate(alias);

      // Get public key
      PublicKey publicKey = cert.getPublicKey();

      // Return a key pair
      new KeyPair(publicKey, (PrivateKey) key);
    }",3
26711910,1," public void foo(){
   FileInputStream is = new FileInputStream(""publickey.cert"");
    KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());
    keystore.load(is, ""my-keystore-password"".toCharArray());
    String alias = ""myalias"";
    Key key = keystore.getKey(alias, ""password"".toCharArray());
    if (key instanceof PrivateKey) {
      // Get certificate of public key
      Certificate cert = keystore.getCertificate(alias);
      // Get public key
      PublicKey publicKey = cert.getPublicKey();

      // Return a key pair
      new KeyPair(publicKey, (PrivateKey) key);
    }",3
26712084,4,"public class sample{
 public void foo(){
    PEMParser pemParser = new PEMParser(new StringReader(certPEMData));
    Object parsedObj = pemParser.readObject();
    System.out.println(""PemParser returned: "" + parsedObj);
    if (parsedObj instanceof X509CertificateHolder)
    {
        X509CertificateHolder x509CertificateHolder = (X509CertificateHolder) parsedObj;
        return x509CertificateHolder.getSubjectPublicKeyInfo().getPublicKeyData().getString();
    }
    else
    {
        throw new RuntimeException(""The parsed object was not an X509CertificateHolder."");
    }

}",1
26735988,2,"    final Cipher cipher = Cipher.getInstance(TRANSFORMATION);
    final IvParameterSpec iv = new IvParameterSpec(initVectorBytes);
    cipher.init(Cipher.DECRYPT_MODE, secretKey, iv);
    final byte[] decryptedVal = cipher.doFinal(cipherTextBytes);",2
26779528,0,"    FileInputStream instream = new FileInputStream(new File(""client-p12-keystore.p12""));
    try {
        keyStore.load(instream, ""helloworld"".toCharArray());
    } finally {
        instream.close();
    }

    // Trust own CA and all self-signed certs
    SSLContext sslcontext = SSLContexts.custom()",1
26779528,1,"    ks.load(null);
    ks.setKeyEntry(""key-alias"", (Key) key, password.toCharArray(),
        new java.security.cert.Certificate[]{x509Certificate});
    ks.store(bos, password.toCharArray());
    bos.close();",1
26780120,0,"    FileInputStream instream = new FileInputStream(new File(""client-p12-keystore.p12""));
    try {
        keyStore.load(instream, ""password"".toCharArray());
    } finally {
        instream.close();
    }

    // Trust own CA and all self-signed certs
    SSLContext sslcontext = SSLContexts.custom()",1
26781271,0," private org.spongycastle.asn1.x509.Certificate signCertificateSigningRequest(
    JcaPKCS10CertificationRequest jcaPKCS10CertificationRequest,
    KeyPair keyPair, X509Certificate serverCertificate)
      throws IOException, OperatorCreationException, NoSuchAlgorithmException, InvalidKeyException
  {
    // Signing CSR
    AlgorithmIdentifier sigAlgId = new DefaultSignatureAlgorithmIdentifierFinder()
      .find(""SHA1withRSA"");

    X509v3CertificateBuilder certificateBuilder = new JcaX509v3CertificateBuilder(
        serverCertificate, 
        new BigInteger(""1""), //serial
        new Date(System.currentTimeMillis()),
        new Date(System.currentTimeMillis() + 30L * 365L * 24L * 60L * 60L * 1000L),
        jcaPKCS10CertificationRequest.getSubject(),
        jcaPKCS10CertificationRequest.getPublicKey()
    /*).addExtension(
        new ASN1ObjectIdentifier(""2.5.29.35""),
        false,
        new AuthorityKeyIdentifier(...)*/
    ).addExtension(
            new ASN1ObjectIdentifier(""2.5.29.19""),
            false,
            new BasicConstraints(false) // true if it is allowed to sign other certs
    ).addExtension(
            new ASN1ObjectIdentifier(""2.5.29.15""),
            true,
            new X509KeyUsage(
                X509KeyUsage.digitalSignature |
                    X509KeyUsage.nonRepudiation   |
                    X509KeyUsage.keyEncipherment  |
                    X509KeyUsage.dataEncipherment));

    AsymmetricKeyParameter asymmetricKeyParameter =
          PrivateKeyFactory.createKey(keyPair.getPrivate().getEncoded());
    //ContentSigner sigGen = new BcRSAContentSignerBuilder(sigAlgId, digAlgId).build(asymmetricKeyParameter);
    ContentSigner sigGen = new JcaContentSignerBuilder(""SHA1withRSA"").build(keyPair.getPrivate());


    X509CertificateHolder x509CertificateHolder = certificateBuilder.build(sigGen);
    org.spongycastle.asn1.x509.Certificate eeX509CertificateStructure =
      x509CertificateHolder.toASN1Structure();
    return eeX509CertificateStructure;",3
26781271,0,"  private String convertCertificateToPEM(X509Certificate signedCertificate) throws IOException {
    StringWriter signedCertificatePEMDataStringWriter = new StringWriter();
    JcaPEMWriter pemWriter = new JcaPEMWriter(signedCertificatePEMDataStringWriter);
    pemWriter.writeObject(signedCertificate);
    pemWriter.close();
    log.info(""PEM data:"");
    log.info("""" + signedCertificatePEMDataStringWriter.toString());
    return signedCertificatePEMDataStringWriter.toString();
  }
",3
26781321,0,"  public X500VgaNameBuilder setBUSINESS_CATEGORY(String businessCategory) {
    this.BUSINESS_CATEGORY = businessCategory;
    x500NameBuilder.addRDN(BCStyle.BUSINESS_CATEGORY, businessCategory);
    return this;
  }

  public String getC() {
    return C;
  }

  public X500VgaNameBuilder setC(String countryCode) {
    C = countryCode;
    x500NameBuilder.addRDN(BCStyle.C, countryCode);
    return this;
  }

  public String getCN() {
    return CN;
  }

  public X500VgaNameBuilder setCN(String commonName) {
    this.CN = commonName;
    x500NameBuilder.addRDN(BCStyle.CN, commonName);
    return this;
  }

  public String getCOUNTRY_OF_CITIZENSHIP() {
    return COUNTRY_OF_CITIZENSHIP;
  }
",-7
26781321,0,"  public X500VgaNameBuilder setBUSINESS_CATEGORY(String businessCategory) {
    this.BUSINESS_CATEGORY = businessCategory;
    x500NameBuilder.addRDN(BCStyle.BUSINESS_CATEGORY, businessCategory);
    return this;
  }

  public String getC() {
    return C;
  }

  public X500VgaNameBuilder setC(String countryCode) {
    C = countryCode;
    x500NameBuilder.addRDN(BCStyle.C, countryCode);
    return this;
  }

  public String getCN() {
    return CN;
  }

  public X500VgaNameBuilder setCN(String commonName) {
    this.CN = commonName;
    x500NameBuilder.addRDN(BCStyle.CN, commonName);
    return this;
  }

  public String getCOUNTRY_OF_CITIZENSHIP() {
    return COUNTRY_OF_CITIZENSHIP;
  }

  public X500VgaNameBuilder setCOUNTRY_OF_CITIZENSHIP(String countryOfCitizenship) {
    this.COUNTRY_OF_CITIZENSHIP = countryOfCitizenship;
    x500NameBuilder.addRDN(BCStyle.COUNTRY_OF_CITIZENSHIP, countryOfCitizenship);
    return this;
  }

  public String getCOUNTRY_OF_RESIDENCE() {
    return COUNTRY_OF_RESIDENCE;
  }
",-7
26781321,0,"  public X500VgaNameBuilder setBUSINESS_CATEGORY(String businessCategory) {
    this.BUSINESS_CATEGORY = businessCategory;
    x500NameBuilder.addRDN(BCStyle.BUSINESS_CATEGORY, businessCategory);
    return this;
  }

  public String getC() {
    return C;
  }

  public X500VgaNameBuilder setC(String countryCode) {
    C = countryCode;
    x500NameBuilder.addRDN(BCStyle.C, countryCode);
    return this;
  }

  public String getCN() {
    return CN;
  }

  public X500VgaNameBuilder setCN(String commonName) {
    this.CN = commonName;
    x500NameBuilder.addRDN(BCStyle.CN, commonName);
    return this;
  }

  public String getCOUNTRY_OF_CITIZENSHIP() {
    return COUNTRY_OF_CITIZENSHIP;
  }

  public X500VgaNameBuilder setCOUNTRY_OF_CITIZENSHIP(String countryOfCitizenship) {
    this.COUNTRY_OF_CITIZENSHIP = countryOfCitizenship;
    x500NameBuilder.addRDN(BCStyle.COUNTRY_OF_CITIZENSHIP, countryOfCitizenship);
    return this;
  }

  public String getCOUNTRY_OF_RESIDENCE() {
    return COUNTRY_OF_RESIDENCE;
  }

  public X500VgaNameBuilder setCOUNTRY_OF_RESIDENCE(String countryOfResidence) {
    this.COUNTRY_OF_RESIDENCE = countryOfResidence;
    x500NameBuilder.addRDN(BCStyle.COUNTRY_OF_RESIDENCE, countryOfResidence);
    return this;
  }

  public String getDATE_OF_BIRTH() {
    return DATE_OF_BIRTH;
  }
",-8
26781321,0,"  public X500VgaNameBuilder setC(String countryCode) {
    C = countryCode;
    x500NameBuilder.addRDN(BCStyle.C, countryCode);
    return this;
  }

  public String getCN() {
    return CN;
  }

  public X500VgaNameBuilder setCN(String commonName) {
    this.CN = commonName;
    x500NameBuilder.addRDN(BCStyle.CN, commonName);
    return this;
  }

  public String getCOUNTRY_OF_CITIZENSHIP() {
    return COUNTRY_OF_CITIZENSHIP;
  }

  public X500VgaNameBuilder setCOUNTRY_OF_CITIZENSHIP(String countryOfCitizenship) {
    this.COUNTRY_OF_CITIZENSHIP = countryOfCitizenship;
    x500NameBuilder.addRDN(BCStyle.COUNTRY_OF_CITIZENSHIP, countryOfCitizenship);
    return this;
  }

  public String getCOUNTRY_OF_RESIDENCE() {
    return COUNTRY_OF_RESIDENCE;
  }

  public X500VgaNameBuilder setCOUNTRY_OF_RESIDENCE(String countryOfResidence) {
    this.COUNTRY_OF_RESIDENCE = countryOfResidence;
    x500NameBuilder.addRDN(BCStyle.COUNTRY_OF_RESIDENCE, countryOfResidence);
    return this;
  }

  public String getDATE_OF_BIRTH() {
    return DATE_OF_BIRTH;
  }

  public X500VgaNameBuilder setDATE_OF_BIRTH(String dateOfBirth) {
    this.DATE_OF_BIRTH = dateOfBirth;
    x500NameBuilder.addRDN(BCStyle.DATE_OF_BIRTH, dateOfBirth);
    return this;
  }

  public String getDC() {
    return DC;
  }
",-8
26781321,0,"  public X500VgaNameBuilder setCN(String commonName) {
    this.CN = commonName;
    x500NameBuilder.addRDN(BCStyle.CN, commonName);
    return this;
  }

  public String getCOUNTRY_OF_CITIZENSHIP() {
    return COUNTRY_OF_CITIZENSHIP;
  }

  public X500VgaNameBuilder setCOUNTRY_OF_CITIZENSHIP(String countryOfCitizenship) {
    this.COUNTRY_OF_CITIZENSHIP = countryOfCitizenship;
    x500NameBuilder.addRDN(BCStyle.COUNTRY_OF_CITIZENSHIP, countryOfCitizenship);
    return this;
  }

  public String getCOUNTRY_OF_RESIDENCE() {
    return COUNTRY_OF_RESIDENCE;
  }

  public X500VgaNameBuilder setCOUNTRY_OF_RESIDENCE(String countryOfResidence) {
    this.COUNTRY_OF_RESIDENCE = countryOfResidence;
    x500NameBuilder.addRDN(BCStyle.COUNTRY_OF_RESIDENCE, countryOfResidence);
    return this;
  }

  public String getDATE_OF_BIRTH() {
    return DATE_OF_BIRTH;
  }

  public X500VgaNameBuilder setDATE_OF_BIRTH(String dateOfBirth) {
    this.DATE_OF_BIRTH = dateOfBirth;
    x500NameBuilder.addRDN(BCStyle.DATE_OF_BIRTH, dateOfBirth);
    return this;
  }

  public String getDC() {
    return DC;
  }
",-7
26781321,0,"  public X500VgaNameBuilder setCOUNTRY_OF_CITIZENSHIP(String countryOfCitizenship) {
    this.COUNTRY_OF_CITIZENSHIP = countryOfCitizenship;
    x500NameBuilder.addRDN(BCStyle.COUNTRY_OF_CITIZENSHIP, countryOfCitizenship);
    return this;
  }

  public String getCOUNTRY_OF_RESIDENCE() {
    return COUNTRY_OF_RESIDENCE;
  }

  public X500VgaNameBuilder setCOUNTRY_OF_RESIDENCE(String countryOfResidence) {
    this.COUNTRY_OF_RESIDENCE = countryOfResidence;
    x500NameBuilder.addRDN(BCStyle.COUNTRY_OF_RESIDENCE, countryOfResidence);
    return this;
  }

  public String getDATE_OF_BIRTH() {
    return DATE_OF_BIRTH;
  }

  public X500VgaNameBuilder setDATE_OF_BIRTH(String dateOfBirth) {
    this.DATE_OF_BIRTH = dateOfBirth;
    x500NameBuilder.addRDN(BCStyle.DATE_OF_BIRTH, dateOfBirth);
    return this;
  }

  public String getDC() {
    return DC;
  }
",-7
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }
",-7
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }
",-7
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }
",-8
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDMD_NAME(String dmdName) {
    this.DMD_NAME = dmdName;
    x500NameBuilder.addRDN(BCStyle.DMD_NAME, dmdName);
    return this;
  }

  public String getDN_QUALIFIER() {
    return DN_QUALIFIER;
  }

  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }
",3
26781321,0,"  public X500VgaNameBuilder setDN_QUALIFIER(String dnQualifier) {
    this.DN_QUALIFIER = dnQualifier;
    x500NameBuilder.addRDN(BCStyle.DN_QUALIFIER, dnQualifier);
    return this;
  }

  public String getE() {
    return E;
  }

  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",3
26781321,0,"  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }
",3
26781321,0,"  public X500VgaNameBuilder setE(String emailVerisign) {
    E = emailVerisign;
    x500NameBuilder.addRDN(BCStyle.E, emailVerisign);
    return this;
  }

  public String getEmailAddress() {
    return EmailAddress;
  }

  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",3
26781321,0,"  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }
",3
26781321,0,"  public X500VgaNameBuilder setEmailAddress(String emailAddressPkcs9) {
    EmailAddress = emailAddressPkcs9;
    x500NameBuilder.addRDN(BCStyle.EmailAddress, emailAddressPkcs9);
    return this;
  }

  public String getGENDER() {
    return GENDER;
  }

  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",3
26781321,0,"  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }
",3
26781321,0,"  public X500VgaNameBuilder setGENDER(String gender_size1) {
    this.GENDER = gender_size1;
    x500NameBuilder.addRDN(BCStyle.GENDER, gender_size1);
    return this;
  }

  public String getGENERATION() {
    return GENERATION;
  }

  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",3
26781321,0,"  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }
",3
26781321,0,"  public X500VgaNameBuilder setGENERATION(String generation) {
    this.GENERATION = generation;
    x500NameBuilder.addRDN(BCStyle.GENERATION, generation);
    return this;
  }

  public String getGIVENNAME() {
    return GIVENNAME;
  }

  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",3
26781321,0,"  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }
",3
26781321,0,"  public X500VgaNameBuilder setGIVENNAME(String givenname) {
    this.GIVENNAME = givenname;
    x500NameBuilder.addRDN(BCStyle.GIVENNAME, givenname);
    return this;
  }

  public String getINITIALS() {
    return INITIALS;
  }

  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",3
26781321,0,"  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }
",3
26781321,0,"  public X500VgaNameBuilder setINITIALS(String initials) {
    this.INITIALS = initials;
    x500NameBuilder.addRDN(BCStyle.INITIALS, initials);
    return this;
  }

  public String getL() {
    return L;
  }

  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",3
26781321,0,"  public X500VgaNameBuilder setL(String localityName) {
    L = localityName;
    x500NameBuilder.addRDN(BCStyle.L, localityName);
    return this;
  }

  public String getNAME() {
    return NAME;
  }

  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",3
26781321,0,"  public X500VgaNameBuilder setNAME(String name_idatname) {
    this.NAME = name_idatname;
    x500NameBuilder.addRDN(BCStyle.NAME, name_idatname);
    return this;
  }

  public String getNAME_AT_BIRTH() {
    return NAME_AT_BIRTH;
  }

  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",3
26781321,0,"  public X500VgaNameBuilder setNAME_AT_BIRTH(String nameAtBirth) {
    this.NAME_AT_BIRTH = nameAtBirth;
    x500NameBuilder.addRDN(BCStyle.NAME_AT_BIRTH, nameAtBirth);
    return this;
  }

  public String getO() {
    return O;
  }

  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",3
26781321,0,"  public X500VgaNameBuilder setO(String organization) {
    O = organization;
    x500NameBuilder.addRDN(BCStyle.O, organization);
    return this;
  }

  public String getOU() {
    return OU;
  }

  public X500VgaNameBuilder setOU(String organizationUnit) {
    this.OU = organizationUnit;
    x500NameBuilder.addRDN(BCStyle.OU, organizationUnit);
    return this;
  }

  public String getPLACE_OF_BIRTH() {
    return PLACE_OF_BIRTH;
  }

  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",3
26781321,0,"  public X500VgaNameBuilder setPLACE_OF_BIRTH(String placeOfBirth) {
    this.PLACE_OF_BIRTH = placeOfBirth;
    x500NameBuilder.addRDN(BCStyle.PLACE_OF_BIRTH, placeOfBirth);
    return this;
  }

  public String getPOSTAL_ADDRESS() {
    return POSTAL_ADDRESS;
  }

  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",-8
26781321,0,"  public X500VgaNameBuilder setPOSTAL_ADDRESS(String postalAddress) {
    this.POSTAL_ADDRESS = postalAddress;
    x500NameBuilder.addRDN(BCStyle.POSTAL_ADDRESS, postalAddress);
    return this;
  }

  public String getPOSTAL_CODE() {
    return POSTAL_CODE;
  }

  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",-7
26781321,0,"  public X500VgaNameBuilder setPOSTAL_CODE(String postalCode) {
    this.POSTAL_CODE = postalCode;
    x500NameBuilder.addRDN(BCStyle.POSTAL_CODE, postalCode);
    return this;
  }

  public String getPSEUDONYM() {
    return PSEUDONYM;
  }

  public X500VgaNameBuilder setPSEUDONYM(String pseudonym) {
    this.PSEUDONYM = pseudonym;
    x500NameBuilder.addRDN(BCStyle.PSEUDONYM, pseudonym);
    return this;
  }

  public String getSERIALNUMBER() {
    return SERIALNUMBER;
  }

  public X500VgaNameBuilder setSERIALNUMBER(String serialNumber) {
    this.SERIALNUMBER = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SERIALNUMBER, serialNumber);
    return this;
  }

  public String getSN() {
    return SN;
  }
",-7
26781321,0,"  public X500VgaNameBuilder setSN(String serialNumber) {
    this.SN = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SN, serialNumber);
    return this;
  }

  public String getST() {
    return ST;
  }

  public X500VgaNameBuilder setST(String stateOrProvince) {
    this.ST = stateOrProvince;
    x500NameBuilder.addRDN(BCStyle.ST, stateOrProvince);
    return this;
  }

  public String getSTREET() {
    return STREET;
  }

  public X500VgaNameBuilder setSTREET(String street) {
    this.STREET = street;
    x500NameBuilder.addRDN(BCStyle.STREET, street);
    return this;
  }

  public String getSURNAME() {
    return SURNAME;
  }
",-7
26781321,0,"  public X500VgaNameBuilder setSN(String serialNumber) {
    this.SN = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SN, serialNumber);
    return this;
  }

  public String getST() {
    return ST;
  }

  public X500VgaNameBuilder setST(String stateOrProvince) {
    this.ST = stateOrProvince;
    x500NameBuilder.addRDN(BCStyle.ST, stateOrProvince);
    return this;
  }

  public String getSTREET() {
    return STREET;
  }

  public X500VgaNameBuilder setSTREET(String street) {
    this.STREET = street;
    x500NameBuilder.addRDN(BCStyle.STREET, street);
    return this;
  }

  public String getSURNAME() {
    return SURNAME;
  }

  public X500VgaNameBuilder setSURNAME(String surname) {
    this.SURNAME = surname;
    x500NameBuilder.addRDN(BCStyle.SURNAME, surname);
    return this;
  }

  public String getT() {
    return T;
  }
",-7
26781321,0,"  public X500VgaNameBuilder setSN(String serialNumber) {
    this.SN = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SN, serialNumber);
    return this;
  }

  public String getST() {
    return ST;
  }

  public X500VgaNameBuilder setST(String stateOrProvince) {
    this.ST = stateOrProvince;
    x500NameBuilder.addRDN(BCStyle.ST, stateOrProvince);
    return this;
  }

  public String getSTREET() {
    return STREET;
  }

  public X500VgaNameBuilder setSTREET(String street) {
    this.STREET = street;
    x500NameBuilder.addRDN(BCStyle.STREET, street);
    return this;
  }

  public String getSURNAME() {
    return SURNAME;
  }

  public X500VgaNameBuilder setSURNAME(String surname) {
    this.SURNAME = surname;
    x500NameBuilder.addRDN(BCStyle.SURNAME, surname);
    return this;
  }

  public String getT() {
    return T;
  }

  public X500VgaNameBuilder setT(String title) {
    T = title;
    x500NameBuilder.addRDN(BCStyle.T, title);
    return this;
  }

  public String getTELEPHONE_NUMBER() {
    return TELEPHONE_NUMBER;
  }
",-8
26781321,0,"  public X500VgaNameBuilder setSN(String serialNumber) {
    this.SN = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SN, serialNumber);
    return this;
  }

  public String getST() {
    return ST;
  }

  public X500VgaNameBuilder setST(String stateOrProvince) {
    this.ST = stateOrProvince;
    x500NameBuilder.addRDN(BCStyle.ST, stateOrProvince);
    return this;
  }

  public String getSTREET() {
    return STREET;
  }

  public X500VgaNameBuilder setSTREET(String street) {
    this.STREET = street;
    x500NameBuilder.addRDN(BCStyle.STREET, street);
    return this;
  }

  public String getSURNAME() {
    return SURNAME;
  }

  public X500VgaNameBuilder setSURNAME(String surname) {
    this.SURNAME = surname;
    x500NameBuilder.addRDN(BCStyle.SURNAME, surname);
    return this;
  }

  public String getT() {
    return T;
  }

  public X500VgaNameBuilder setT(String title) {
    T = title;
    x500NameBuilder.addRDN(BCStyle.T, title);
    return this;
  }

  public String getTELEPHONE_NUMBER() {
    return TELEPHONE_NUMBER;
  }

  public X500VgaNameBuilder setTELEPHONE_NUMBER(String telephoneNumber_idattn) {
    this.TELEPHONE_NUMBER = telephoneNumber_idattn;
    x500NameBuilder.addRDN(BCStyle.TELEPHONE_NUMBER, telephoneNumber_idattn);
    return this;
  }

  public String getUID() {
    return UID;
  }

  public X500VgaNameBuilder setUID(String userId_LDAP) {
    this.UID = userId_LDAP;
    x500NameBuilder.addRDN(BCStyle.UID, userId_LDAP);
    return this;
  }

  public String getUNIQUE_IDENTIFIER() {
    return UNIQUE_IDENTIFIER;
  }
",3
26781321,0,"  public X500VgaNameBuilder setSN(String serialNumber) {
    this.SN = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SN, serialNumber);
    return this;
  }

  public String getST() {
    return ST;
  }

  public X500VgaNameBuilder setST(String stateOrProvince) {
    this.ST = stateOrProvince;
    x500NameBuilder.addRDN(BCStyle.ST, stateOrProvince);
    return this;
  }

  public String getSTREET() {
    return STREET;
  }

  public X500VgaNameBuilder setSTREET(String street) {
    this.STREET = street;
    x500NameBuilder.addRDN(BCStyle.STREET, street);
    return this;
  }

  public String getSURNAME() {
    return SURNAME;
  }

  public X500VgaNameBuilder setSURNAME(String surname) {
    this.SURNAME = surname;
    x500NameBuilder.addRDN(BCStyle.SURNAME, surname);
    return this;
  }

  public String getT() {
    return T;
  }

  public X500VgaNameBuilder setT(String title) {
    T = title;
    x500NameBuilder.addRDN(BCStyle.T, title);
    return this;
  }

  public String getTELEPHONE_NUMBER() {
    return TELEPHONE_NUMBER;
  }

  public X500VgaNameBuilder setTELEPHONE_NUMBER(String telephoneNumber_idattn) {
    this.TELEPHONE_NUMBER = telephoneNumber_idattn;
    x500NameBuilder.addRDN(BCStyle.TELEPHONE_NUMBER, telephoneNumber_idattn);
    return this;
  }

  public String getUID() {
    return UID;
  }

  public X500VgaNameBuilder setUID(String userId_LDAP) {
    this.UID = userId_LDAP;
    x500NameBuilder.addRDN(BCStyle.UID, userId_LDAP);
    return this;
  }

  public String getUNIQUE_IDENTIFIER() {
    return UNIQUE_IDENTIFIER;
  }

  public X500VgaNameBuilder setUNIQUE_IDENTIFIER(String uniqueIdentifier) {
    this.UNIQUE_IDENTIFIER = uniqueIdentifier;
    x500NameBuilder.addRDN(BCStyle.UNIQUE_IDENTIFIER, uniqueIdentifier);
    return this;
  }

  public String getUnstructuredAddress() {
    return UnstructuredAddress;
  }
",3
26781321,0,"  public X500VgaNameBuilder setSN(String serialNumber) {
    this.SN = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SN, serialNumber);
    return this;
  }

  public String getST() {
    return ST;
  }

  public X500VgaNameBuilder setST(String stateOrProvince) {
    this.ST = stateOrProvince;
    x500NameBuilder.addRDN(BCStyle.ST, stateOrProvince);
    return this;
  }

  public String getSTREET() {
    return STREET;
  }

  public X500VgaNameBuilder setSTREET(String street) {
    this.STREET = street;
    x500NameBuilder.addRDN(BCStyle.STREET, street);
    return this;
  }

  public String getSURNAME() {
    return SURNAME;
  }

  public X500VgaNameBuilder setSURNAME(String surname) {
    this.SURNAME = surname;
    x500NameBuilder.addRDN(BCStyle.SURNAME, surname);
    return this;
  }

  public String getT() {
    return T;
  }

  public X500VgaNameBuilder setT(String title) {
    T = title;
    x500NameBuilder.addRDN(BCStyle.T, title);
    return this;
  }

  public String getTELEPHONE_NUMBER() {
    return TELEPHONE_NUMBER;
  }

  public X500VgaNameBuilder setTELEPHONE_NUMBER(String telephoneNumber_idattn) {
    this.TELEPHONE_NUMBER = telephoneNumber_idattn;
    x500NameBuilder.addRDN(BCStyle.TELEPHONE_NUMBER, telephoneNumber_idattn);
    return this;
  }

  public String getUID() {
    return UID;
  }

  public X500VgaNameBuilder setUID(String userId_LDAP) {
    this.UID = userId_LDAP;
    x500NameBuilder.addRDN(BCStyle.UID, userId_LDAP);
    return this;
  }

  public String getUNIQUE_IDENTIFIER() {
    return UNIQUE_IDENTIFIER;
  }

  public X500VgaNameBuilder setUNIQUE_IDENTIFIER(String uniqueIdentifier) {
    this.UNIQUE_IDENTIFIER = uniqueIdentifier;
    x500NameBuilder.addRDN(BCStyle.UNIQUE_IDENTIFIER, uniqueIdentifier);
    return this;
  }

  public String getUnstructuredAddress() {
    return UnstructuredAddress;
  }

  public X500VgaNameBuilder setUnstructuredAddress(String unstructuredAddress) {
    UnstructuredAddress = unstructuredAddress;
    x500NameBuilder.addRDN(BCStyle.UnstructuredAddress, unstructuredAddress);
    return this;
  }

  public String getUnstructuredName() {
    return UnstructuredName;
  }
",3
26781321,0,"  public X500VgaNameBuilder setSN(String serialNumber) {
    this.SN = serialNumber;
    x500NameBuilder.addRDN(BCStyle.SN, serialNumber);
    return this;
  }

  public String getST() {
    return ST;
  }

  public X500VgaNameBuilder setST(String stateOrProvince) {
    this.ST = stateOrProvince;
    x500NameBuilder.addRDN(BCStyle.ST, stateOrProvince);
    return this;
  }

  public String getSTREET() {
    return STREET;
  }

  public X500VgaNameBuilder setSTREET(String street) {
    this.STREET = street;
    x500NameBuilder.addRDN(BCStyle.STREET, street);
    return this;
  }

  public String getSURNAME() {
    return SURNAME;
  }

  public X500VgaNameBuilder setSURNAME(String surname) {
    this.SURNAME = surname;
    x500NameBuilder.addRDN(BCStyle.SURNAME, surname);
    return this;
  }

  public String getT() {
    return T;
  }

  public X500VgaNameBuilder setT(String title) {
    T = title;
    x500NameBuilder.addRDN(BCStyle.T, title);
    return this;
  }

  public String getTELEPHONE_NUMBER() {
    return TELEPHONE_NUMBER;
  }

  public X500VgaNameBuilder setTELEPHONE_NUMBER(String telephoneNumber_idattn) {
    this.TELEPHONE_NUMBER = telephoneNumber_idattn;
    x500NameBuilder.addRDN(BCStyle.TELEPHONE_NUMBER, telephoneNumber_idattn);
    return this;
  }

  public String getUID() {
    return UID;
  }

  public X500VgaNameBuilder setUID(String userId_LDAP) {
    this.UID = userId_LDAP;
    x500NameBuilder.addRDN(BCStyle.UID, userId_LDAP);
    return this;
  }

  public String getUNIQUE_IDENTIFIER() {
    return UNIQUE_IDENTIFIER;
  }

  public X500VgaNameBuilder setUNIQUE_IDENTIFIER(String uniqueIdentifier) {
    this.UNIQUE_IDENTIFIER = uniqueIdentifier;
    x500NameBuilder.addRDN(BCStyle.UNIQUE_IDENTIFIER, uniqueIdentifier);
    return this;
  }

  public String getUnstructuredAddress() {
    return UnstructuredAddress;
  }

  public X500VgaNameBuilder setUnstructuredAddress(String unstructuredAddress) {
    UnstructuredAddress = unstructuredAddress;
    x500NameBuilder.addRDN(BCStyle.UnstructuredAddress, unstructuredAddress);
    return this;
  }

  public String getUnstructuredName() {
    return UnstructuredName;
  }

  public X500VgaNameBuilder setUnstructuredName(String unstructuredName) {
    UnstructuredName = unstructuredName;
    x500NameBuilder.addRDN(BCStyle.UnstructuredName, unstructuredName);
    return this;
  }

  public X500Name build()
  {
    return x500NameBuilder.build();
  }",3
26781321,0,"  public X500VgaNameBuilder setST(String stateOrProvince) {
    this.ST = stateOrProvince;
    x500NameBuilder.addRDN(BCStyle.ST, stateOrProvince);
    return this;
  }

  public String getSTREET() {
    return STREET;
  }

  public X500VgaNameBuilder setSTREET(String street) {
    this.STREET = street;
    x500NameBuilder.addRDN(BCStyle.STREET, street);
    return this;
  }

  public String getSURNAME() {
    return SURNAME;
  }

  public X500VgaNameBuilder setSURNAME(String surname) {
    this.SURNAME = surname;
    x500NameBuilder.addRDN(BCStyle.SURNAME, surname);
    return this;
  }

  public String getT() {
    return T;
  }

  public X500VgaNameBuilder setT(String title) {
    T = title;
    x500NameBuilder.addRDN(BCStyle.T, title);
    return this;
  }

  public String getTELEPHONE_NUMBER() {
    return TELEPHONE_NUMBER;
  }

  public X500VgaNameBuilder setTELEPHONE_NUMBER(String telephoneNumber_idattn) {
    this.TELEPHONE_NUMBER = telephoneNumber_idattn;
    x500NameBuilder.addRDN(BCStyle.TELEPHONE_NUMBER, telephoneNumber_idattn);
    return this;
  }

  public String getUID() {
    return UID;
  }

  public X500VgaNameBuilder setUID(String userId_LDAP) {
    this.UID = userId_LDAP;
    x500NameBuilder.addRDN(BCStyle.UID, userId_LDAP);
    return this;
  }

  public String getUNIQUE_IDENTIFIER() {
    return UNIQUE_IDENTIFIER;
  }

  public X500VgaNameBuilder setUNIQUE_IDENTIFIER(String uniqueIdentifier) {
    this.UNIQUE_IDENTIFIER = uniqueIdentifier;
    x500NameBuilder.addRDN(BCStyle.UNIQUE_IDENTIFIER, uniqueIdentifier);
    return this;
  }

  public String getUnstructuredAddress() {
    return UnstructuredAddress;
  }

  public X500VgaNameBuilder setUnstructuredAddress(String unstructuredAddress) {
    UnstructuredAddress = unstructuredAddress;
    x500NameBuilder.addRDN(BCStyle.UnstructuredAddress, unstructuredAddress);
    return this;
  }

  public String getUnstructuredName() {
    return UnstructuredName;
  }

  public X500VgaNameBuilder setUnstructuredName(String unstructuredName) {
    UnstructuredName = unstructuredName;
    x500NameBuilder.addRDN(BCStyle.UnstructuredName, unstructuredName);
    return this;
  }

  public X500Name build()
  {
    return x500NameBuilder.build();
  }",3
26781321,0,"  public X500VgaNameBuilder setSTREET(String street) {
    this.STREET = street;
    x500NameBuilder.addRDN(BCStyle.STREET, street);
    return this;
  }

  public String getSURNAME() {
    return SURNAME;
  }

  public X500VgaNameBuilder setSURNAME(String surname) {
    this.SURNAME = surname;
    x500NameBuilder.addRDN(BCStyle.SURNAME, surname);
    return this;
  }

  public String getT() {
    return T;
  }

  public X500VgaNameBuilder setT(String title) {
    T = title;
    x500NameBuilder.addRDN(BCStyle.T, title);
    return this;
  }

  public String getTELEPHONE_NUMBER() {
    return TELEPHONE_NUMBER;
  }

  public X500VgaNameBuilder setTELEPHONE_NUMBER(String telephoneNumber_idattn) {
    this.TELEPHONE_NUMBER = telephoneNumber_idattn;
    x500NameBuilder.addRDN(BCStyle.TELEPHONE_NUMBER, telephoneNumber_idattn);
    return this;
  }

  public String getUID() {
    return UID;
  }

  public X500VgaNameBuilder setUID(String userId_LDAP) {
    this.UID = userId_LDAP;
    x500NameBuilder.addRDN(BCStyle.UID, userId_LDAP);
    return this;
  }

  public String getUNIQUE_IDENTIFIER() {
    return UNIQUE_IDENTIFIER;
  }

  public X500VgaNameBuilder setUNIQUE_IDENTIFIER(String uniqueIdentifier) {
    this.UNIQUE_IDENTIFIER = uniqueIdentifier;
    x500NameBuilder.addRDN(BCStyle.UNIQUE_IDENTIFIER, uniqueIdentifier);
    return this;
  }

  public String getUnstructuredAddress() {
    return UnstructuredAddress;
  }

  public X500VgaNameBuilder setUnstructuredAddress(String unstructuredAddress) {
    UnstructuredAddress = unstructuredAddress;
    x500NameBuilder.addRDN(BCStyle.UnstructuredAddress, unstructuredAddress);
    return this;
  }

  public String getUnstructuredName() {
    return UnstructuredName;
  }

  public X500VgaNameBuilder setUnstructuredName(String unstructuredName) {
    UnstructuredName = unstructuredName;
    x500NameBuilder.addRDN(BCStyle.UnstructuredName, unstructuredName);
    return this;
  }

  public X500Name build()
  {
    return x500NameBuilder.build();
  }",3
26781321,0,"  public X500VgaNameBuilder setSURNAME(String surname) {
    this.SURNAME = surname;
    x500NameBuilder.addRDN(BCStyle.SURNAME, surname);
    return this;
  }

  public String getT() {
    return T;
  }

  public X500VgaNameBuilder setT(String title) {
    T = title;
    x500NameBuilder.addRDN(BCStyle.T, title);
    return this;
  }

  public String getTELEPHONE_NUMBER() {
    return TELEPHONE_NUMBER;
  }

  public X500VgaNameBuilder setTELEPHONE_NUMBER(String telephoneNumber_idattn) {
    this.TELEPHONE_NUMBER = telephoneNumber_idattn;
    x500NameBuilder.addRDN(BCStyle.TELEPHONE_NUMBER, telephoneNumber_idattn);
    return this;
  }

  public String getUID() {
    return UID;
  }

  public X500VgaNameBuilder setUID(String userId_LDAP) {
    this.UID = userId_LDAP;
    x500NameBuilder.addRDN(BCStyle.UID, userId_LDAP);
    return this;
  }

  public String getUNIQUE_IDENTIFIER() {
    return UNIQUE_IDENTIFIER;
  }

  public X500VgaNameBuilder setUNIQUE_IDENTIFIER(String uniqueIdentifier) {
    this.UNIQUE_IDENTIFIER = uniqueIdentifier;
    x500NameBuilder.addRDN(BCStyle.UNIQUE_IDENTIFIER, uniqueIdentifier);
    return this;
  }

  public String getUnstructuredAddress() {
    return UnstructuredAddress;
  }

  public X500VgaNameBuilder setUnstructuredAddress(String unstructuredAddress) {
    UnstructuredAddress = unstructuredAddress;
    x500NameBuilder.addRDN(BCStyle.UnstructuredAddress, unstructuredAddress);
    return this;
  }

  public String getUnstructuredName() {
    return UnstructuredName;
  }

  public X500VgaNameBuilder setUnstructuredName(String unstructuredName) {
    UnstructuredName = unstructuredName;
    x500NameBuilder.addRDN(BCStyle.UnstructuredName, unstructuredName);
    return this;
  }

  public X500Name build()
  {
    return x500NameBuilder.build();
  }",3
26781321,0,"  public X500VgaNameBuilder setTELEPHONE_NUMBER(String telephoneNumber_idattn) {
    this.TELEPHONE_NUMBER = telephoneNumber_idattn;
    x500NameBuilder.addRDN(BCStyle.TELEPHONE_NUMBER, telephoneNumber_idattn);
    return this;
  }

  public String getUID() {
    return UID;
  }

  public X500VgaNameBuilder setUID(String userId_LDAP) {
    this.UID = userId_LDAP;
    x500NameBuilder.addRDN(BCStyle.UID, userId_LDAP);
    return this;
  }

  public String getUNIQUE_IDENTIFIER() {
    return UNIQUE_IDENTIFIER;
  }

  public X500VgaNameBuilder setUNIQUE_IDENTIFIER(String uniqueIdentifier) {
    this.UNIQUE_IDENTIFIER = uniqueIdentifier;
    x500NameBuilder.addRDN(BCStyle.UNIQUE_IDENTIFIER, uniqueIdentifier);
    return this;
  }

  public String getUnstructuredAddress() {
    return UnstructuredAddress;
  }

  public X500VgaNameBuilder setUnstructuredAddress(String unstructuredAddress) {
    UnstructuredAddress = unstructuredAddress;
    x500NameBuilder.addRDN(BCStyle.UnstructuredAddress, unstructuredAddress);
    return this;
  }

  public String getUnstructuredName() {
    return UnstructuredName;
  }

  public X500VgaNameBuilder setUnstructuredName(String unstructuredName) {
    UnstructuredName = unstructuredName;
    x500NameBuilder.addRDN(BCStyle.UnstructuredName, unstructuredName);
    return this;
  }

  public X500Name build()
  {
    return x500NameBuilder.build();
  }",-8
26781321,0,"  public X500VgaNameBuilder setUID(String userId_LDAP) {
    this.UID = userId_LDAP;
    x500NameBuilder.addRDN(BCStyle.UID, userId_LDAP);
    return this;
  }

  public String getUNIQUE_IDENTIFIER() {
    return UNIQUE_IDENTIFIER;
  }

  public X500VgaNameBuilder setUNIQUE_IDENTIFIER(String uniqueIdentifier) {
    this.UNIQUE_IDENTIFIER = uniqueIdentifier;
    x500NameBuilder.addRDN(BCStyle.UNIQUE_IDENTIFIER, uniqueIdentifier);
    return this;
  }

  public String getUnstructuredAddress() {
    return UnstructuredAddress;
  }

  public X500VgaNameBuilder setUnstructuredAddress(String unstructuredAddress) {
    UnstructuredAddress = unstructuredAddress;
    x500NameBuilder.addRDN(BCStyle.UnstructuredAddress, unstructuredAddress);
    return this;
  }

  public String getUnstructuredName() {
    return UnstructuredName;
  }

  public X500VgaNameBuilder setUnstructuredName(String unstructuredName) {
    UnstructuredName = unstructuredName;
    x500NameBuilder.addRDN(BCStyle.UnstructuredName, unstructuredName);
    return this;
  }

  public X500Name build()
  {
    return x500NameBuilder.build();
  }",-7
26781321,0,"  public X500VgaNameBuilder setUNIQUE_IDENTIFIER(String uniqueIdentifier) {
    this.UNIQUE_IDENTIFIER = uniqueIdentifier;
    x500NameBuilder.addRDN(BCStyle.UNIQUE_IDENTIFIER, uniqueIdentifier);
    return this;
  }

  public String getUnstructuredAddress() {
    return UnstructuredAddress;
  }

  public X500VgaNameBuilder setUnstructuredAddress(String unstructuredAddress) {
    UnstructuredAddress = unstructuredAddress;
    x500NameBuilder.addRDN(BCStyle.UnstructuredAddress, unstructuredAddress);
    return this;
  }

  public String getUnstructuredName() {
    return UnstructuredName;
  }

  public X500VgaNameBuilder setUnstructuredName(String unstructuredName) {
    UnstructuredName = unstructuredName;
    x500NameBuilder.addRDN(BCStyle.UnstructuredName, unstructuredName);
    return this;
  }

  public X500Name build()
  {
    return x500NameBuilder.build();
  }",-7
26781595,0,"    FileInputStream instream = new FileInputStream(new File(""client-p12-keystore.p12""));
    try {
        keyStore.load(instream, ""password"".toCharArray());
    } finally {
        instream.close();
    }

    // Trust own CA and all self-signed certs
    SSLContext sslcontext = SSLContexts.custom()",1
26781812,1,"  private org.spongycastle.asn1.x509.Certificate signCertificateSigningRequest(
    JcaPKCS10CertificationRequest jcaPKCS10CertificationRequest,
    KeyPair keyPair, X509Certificate serverCertificate)
      throws IOException, OperatorCreationException, NoSuchAlgorithmException, InvalidKeyException
  {
    // Signing CSR
    AlgorithmIdentifier sigAlgId = new DefaultSignatureAlgorithmIdentifierFinder()
      .find(""SHA1withRSA"");

    X509v3CertificateBuilder certificateBuilder = new JcaX509v3CertificateBuilder(
        serverCertificate, 
        new BigInteger(""1""), //serial
        new Date(System.currentTimeMillis()),
        new Date(System.currentTimeMillis() + 30L * 365L * 24L * 60L * 60L * 1000L),
        jcaPKCS10CertificationRequest.getSubject(),
        jcaPKCS10CertificationRequest.getPublicKey()
    /*).addExtension(
        new ASN1ObjectIdentifier(""2.5.29.35""),
        false,
        new AuthorityKeyIdentifier(keyPair.getPublic().getEncoded())*/
    ).addExtension(
            new ASN1ObjectIdentifier(""2.5.29.19""),
            false,
            new BasicConstraints(false) // true if it is allowed to sign other certs
    ).addExtension(
            new ASN1ObjectIdentifier(""2.5.29.15""),
            true,
            new X509KeyUsage(
                X509KeyUsage.digitalSignature |
                    X509KeyUsage.nonRepudiation   |
                    X509KeyUsage.keyEncipherment  |
                    X509KeyUsage.dataEncipherment));

    AsymmetricKeyParameter asymmetricKeyParameter =
          PrivateKeyFactory.createKey(keyPair.getPrivate().getEncoded());
    //ContentSigner sigGen = new BcRSAContentSignerBuilder(sigAlgId, digAlgId).build(asymmetricKeyParameter);
    ContentSigner sigGen = new JcaContentSignerBuilder(""SHA1withRSA"").build(keyPair.getPrivate());


    X509CertificateHolder x509CertificateHolder = certificateBuilder.build(sigGen);
    org.spongycastle.asn1.x509.Certificate eeX509CertificateStructure =
      x509CertificateHolder.toASN1Structure();
    return eeX509CertificateStructure;",3
26781812,2,"  private String convertCertificateToPEM(X509Certificate signedCertificate) throws IOException {
    StringWriter signedCertificatePEMDataStringWriter = new StringWriter();
    JcaPEMWriter pemWriter = new JcaPEMWriter(signedCertificatePEMDataStringWriter);
    pemWriter.writeObject(signedCertificate);
    pemWriter.close();
    log.info(""PEM data:"");
    log.info("""" + signedCertificatePEMDataStringWriter.toString());
    return signedCertificatePEMDataStringWriter.toString();
  }
",3
26782357,2,"public class sample{
  private String convertCertificateToPEM(X509Certificate signedCertificate) throws IOException {
    StringWriter signedCertificatePEMDataStringWriter = new StringWriter();
    JcaPEMWriter pemWriter = new JcaPEMWriter(signedCertificatePEMDataStringWriter);
    pemWriter.writeObject(signedCertificate);
    pemWriter.close();
    return signedCertificatePEMDataStringWriter.toString();
  }
",1
26804009,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
26844932,0,"    FileInputStream instream = new FileInputStream(new File(
            ""client-p12-keystore.p12""));
    try {
        trustStore.load(instream, ""password"".toCharArray());
    } finally {
        instream.close();
    }

    // Trust own CA and all self-signed certs
    SSLContext sslcontext = SSLContexts.custom()",1
26851569,5,"            cipher.init(Cipher.ENCRYPT_MODE, key);

            AlgorithmParameters params = cipher.getParameters();
            byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();

            byte[] ciphertext = new byte[iv.length
                    + cipher.getOutputSize(plaintext.length)];
            System.arraycopy(iv, 0, ciphertext, 0, iv.length);
            cipher.doFinal(plaintext, 0, plaintext.length, ciphertext,
                    iv.length);
            return ciphertext;",2
26851569,5,"            if (ciphertext.length < cipher.getBlockSize()) {
                throw new IllegalArgumentException(
                        ""Ciphertext too small to contain IV"");
            }

            IvParameterSpec ivSpec = new IvParameterSpec(ciphertext, 0,
                    cipher.getBlockSize());
            cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);

            byte[] plaintext = new byte[cipher.getOutputSize(ciphertext.length
                    - cipher.getBlockSize())];
            cipher.doFinal(ciphertext, cipher.getBlockSize(), ciphertext.length
                    - cipher.getBlockSize(), plaintext, 0);
            return plaintext;",2
26851569,6,"            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            SecretKey key;
            try {
                key = ((SecretKeyEntry) store.getEntry(KEY_ALIAS, PASSWORD))
                        .getSecretKey();
            } catch (UnrecoverableEntryException | KeyStoreException e) {
                throw new IllegalStateException(""What key?"", e);
            }",2
26851569,6,"            cipher.init(Cipher.ENCRYPT_MODE, key);

            AlgorithmParameters params = cipher.getParameters();
            byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();

            byte[] ciphertext = new byte[iv.length
                    + cipher.getOutputSize(plaintext.length)];
            System.arraycopy(iv, 0, ciphertext, 0, iv.length);
            cipher.doFinal(plaintext, 0, plaintext.length, ciphertext,
                    iv.length);
            return ciphertext;",2
26851569,6,"            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            SecretKey key;
            try {
                key = ((SecretKeyEntry) store.getEntry(KEY_ALIAS, PASSWORD))
                        .getSecretKey();
            } catch (UnrecoverableEntryException | KeyStoreException e) {
                throw new IllegalStateException(""What key?"", e);
            }
",2
26851569,6,"            if (ciphertext.length < cipher.getBlockSize()) {
                throw new IllegalArgumentException(
                        ""Ciphertext too small to contain IV"");
            }

            IvParameterSpec ivSpec = new IvParameterSpec(ciphertext, 0,
                    cipher.getBlockSize());
            cipher.init(Cipher.DECRYPT_MODE, key, ivSpec);

            byte[] plaintext = new byte[cipher.getOutputSize(ciphertext.length
                    - cipher.getBlockSize())];
            cipher.doFinal(ciphertext, cipher.getBlockSize(), ciphertext.length
                    - cipher.getBlockSize(), plaintext, 0);
            return plaintext;",2
27131547,3,"        ks.load(null);
        ks.setKeyEntry(""key-alias"", (Key) privateKey, password.toCharArray(),
                       new java.security.cert.Certificate[] { certificate });
        ks.store(bos, password.toCharArray());
        bos.close();",1
27185153,0,"public static byte[] encrypt(byte[] plaintext, String key) throws Exception {
  SecretKey secret = makeKey(key);
  Cipher cipher = Cipher.getInstance(""AES/OFB8/NoPadding"");
  cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(new byte[16]));
  return cipher.doFinal(plaintext);
}
",2
27185153,0,"public static byte[] decrypt(byte[] ciphertext, String key) throws Exception {
  SecretKey secret = makeKey(key);
  Cipher cipher = Cipher.getInstance(""AES/OFB8/NoPadding"");
  cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(new byte[16]));
  return cipher.doFinal(ciphertext);
}
",2
27198969,0,"    KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, 1000, 256);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();",2
27250883,2,"public static byte[] evpKDF(byte[] password, int keySize, int ivSize, byte[] salt, int iterations, String hashAlgorithm, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {
    int targetKeySize = keySize + ivSize;
    byte[] derivedBytes = new byte[targetKeySize * 4];
    int numberOfDerivedWords = 0;
    byte[] block = null;
    MessageDigest hasher = MessageDigest.getInstance(hashAlgorithm);
    while (numberOfDerivedWords < targetKeySize) {
        if (block != null) {
            hasher.update(block);
        }
        hasher.update(password);
        block = hasher.digest(salt);
        hasher.reset();

        // Iterations
        for (int i = 1; i < iterations; i++) {
            block = hasher.digest(block);
            hasher.reset();
        }

        System.arraycopy(block, 0, derivedBytes, numberOfDerivedWords * 4,
                Math.min(block.length, (targetKeySize - numberOfDerivedWords) * 4));

        numberOfDerivedWords += block.length/4;
    }

    System.arraycopy(derivedBytes, 0, resultKey, 0, keySize * 4);
    System.arraycopy(derivedBytes, keySize * 4, resultIv, 0, ivSize * 4);

    return derivedBytes; // key + iv
}
",4
27250883,2,"    int targetKeySize = keySize + ivSize;
    byte[] derivedBytes = new byte[targetKeySize * 4];
    int numberOfDerivedWords = 0;
    byte[] block = null;
    MessageDigest hasher = MessageDigest.getInstance(hashAlgorithm);
    while (numberOfDerivedWords < targetKeySize) {
        if (block != null) {
            hasher.update(block);
        }
        hasher.update(password);
        block = hasher.digest(salt);
        hasher.reset();

        // Iterations
        for (int i = 1; i < iterations; i++) {
            block = hasher.digest(block);
            hasher.reset();
        }

        System.arraycopy(block, 0, derivedBytes, numberOfDerivedWords * 4,
                Math.min(block.length, (targetKeySize - numberOfDerivedWords) * 4));

        numberOfDerivedWords += block.length/4;
    }

    System.arraycopy(derivedBytes, 0, resultKey, 0, keySize * 4);
    System.arraycopy(derivedBytes, keySize * 4, resultIv, 0, ivSize * 4);

    return derivedBytes; // key + iv",24
27250883,3,"        Cipher aesCipherForEncryption = Cipher.getInstance(""AES/CBC/PKCS5Padding""); // Must specify the mode explicitly as most JCE providers default to ECB mode!!

        IvParameterSpec ivSpec = new IvParameterSpec(javaIv);
        aesCipherForEncryption.init(Cipher.DECRYPT_MODE, new SecretKeySpec(javaKey, ""AES""), ivSpec);

        byte[] byteMsg = aesCipherForEncryption.doFinal(cipherText);",2
27250883,3,"    public static byte[] evpKDF(byte[] password, int keySize, int ivSize, byte[] salt, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {
        return evpKDF(password, keySize, ivSize, salt, 1, ""MD5"", resultKey, resultIv);
    }
",2
27250883,3,"    public static byte[] evpKDF(byte[] password, int keySize, int ivSize, byte[] salt, int iterations, String hashAlgorithm, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {
        int targetKeySize = keySize + ivSize;
        byte[] derivedBytes = new byte[targetKeySize * 4];
        int numberOfDerivedWords = 0;
        byte[] block = null;
        MessageDigest hasher = MessageDigest.getInstance(hashAlgorithm);
        while (numberOfDerivedWords < targetKeySize) {
            if (block != null) {
                hasher.update(block);
            }
            hasher.update(password);
            block = hasher.digest(salt);
            hasher.reset();

            // Iterations
            for (int i = 1; i < iterations; i++) {
                block = hasher.digest(block);
                hasher.reset();
            }

            System.arraycopy(block, 0, derivedBytes, numberOfDerivedWords * 4,
                    Math.min(block.length, (targetKeySize - numberOfDerivedWords) * 4));

            numberOfDerivedWords += block.length/4;
        }

        System.arraycopy(derivedBytes, 0, resultKey, 0, keySize * 4);
        System.arraycopy(derivedBytes, keySize * 4, resultIv, 0, ivSize * 4);

        return derivedBytes; // key + iv
    }

    /**
     * Copied from http://stackoverflow.com/a/140861
     * */",4
27250883,3,"        int targetKeySize = keySize + ivSize;
        byte[] derivedBytes = new byte[targetKeySize * 4];
        int numberOfDerivedWords = 0;
        byte[] block = null;
        MessageDigest hasher = MessageDigest.getInstance(hashAlgorithm);
        while (numberOfDerivedWords < targetKeySize) {
            if (block != null) {
                hasher.update(block);
            }
            hasher.update(password);
            block = hasher.digest(salt);
            hasher.reset();

            // Iterations
            for (int i = 1; i < iterations; i++) {
                block = hasher.digest(block);
                hasher.reset();
            }

            System.arraycopy(block, 0, derivedBytes, numberOfDerivedWords * 4,
                    Math.min(block.length, (targetKeySize - numberOfDerivedWords) * 4));

            numberOfDerivedWords += block.length/4;
        }

        System.arraycopy(derivedBytes, 0, resultKey, 0, keySize * 4);
        System.arraycopy(derivedBytes, keySize * 4, resultIv, 0, ivSize * 4);

        return derivedBytes; // key + iv
    }

    /**
     * Copied from http://stackoverflow.com/a/140861
     * */
    public static byte[] hexStringToByteArray(String s) {
        int len = s.length();
        byte[] data = new byte[len / 2];
        for (int i = 0; i < len; i += 2) {
            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
                    + Character.digit(s.charAt(i+1), 16));
        }
        return data;
    }",4
27523616,0,"private NoSSLv3SSLSocket(SSLSocket delegate) {
    super(delegate);

    String canonicalName = delegate.getClass().getCanonicalName();
    if (!canonicalName.equals(""org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl"")){
        // try replicate the code from HttpConnection.setupSecureSocket()
        try {
            Method msetUseSessionTickets = delegate.getClass().getMethod(""setUseSessionTickets"", boolean.class);
            if (null != msetUseSessionTickets) {
                msetUseSessionTickets.invoke(delegate, true);
            }
        } catch (NoSuchMethodException ignored) {
        } catch (InvocationTargetException ignored) {
        } catch (IllegalAccessException ignored) {
        }
    }",1
27523616,0,"private static Socket makeSocketSafe(Socket socket) {
    if (socket instanceof SSLSocket) {
        socket = new NoSSLv3SSLSocket((SSLSocket) socket);
    }
    return socket;
}

@Override
public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}",1
27523616,0,"public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}",1
27523616,0,"public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override",1
27558509,7,"SubjectPublicKeyInfo subjectPublicKeyInfo = (SubjectPublicKeyInfo) reader.readObject();
RSAKeyParameters rsaKeyParameters = (RSAKeyParameters)          
PublicKeyFactory.createKey(subjectPublicKeyInfo);
PKCS1Encoding engine = new PKCS1Encoding(new RSAEngine());
engine.init(true, rsaKeyParameters);
return engine.processBlock(data, 0, data.length);
",3
27558509,8,"    PrivateKeyInfo privateKeyInfo = pemKeyPair.getPrivateKeyInfo();
    RSAKeyParameters rsaKeyParameters = (RSAKeyParameters)     
    PrivateKeyFactory.createKey(privateKeyInfo);
    PKCS1Encoding engine = new PKCS1Encoding(new RSAEngine());
    engine.init(false, rsaKeyParameters);
    return engine.processBlock(rawData, 0, rawData.length);",3
27578877,1,"public class sample{
/**
 * This method is used to encrypt a string value.
 * 
 * @param text
 *          - string value to be encrypted.
 *          
 * @return result(encrypted string) as String
 * 
 * @throws Exception
 * 
 */
@TargetApi(8)
public static String encrytData(String text) throws Exception {

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

    byte[] results = cipher.doFinal(text.getBytes());

    String result = Base64.encodeToString(results, Base64.NO_WRAP|Base64.DEFAULT);
    return result;

}

/**
 * This method is used to decrypt a string value.
 * 
 * @param text
 *          - string value to be decrypted.
 * @return result(decrypted string) as String
 * 
 * @throws Exception
 */
@SuppressLint(""NewApi"")
public static String decryptData(String text)throws Exception{

    byte[] encryted_bytes = Base64.decode(text, Base64.DEFAULT);

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

    byte[] decrypted = cipher.doFinal(encryted_bytes);
    String result = new String(decrypted);

    return result;
}
",2
27578877,1,"    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
",2
27578877,1,"    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

    byte[] results = cipher.doFinal(text.getBytes());
",2
27578877,1,"    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
",2
27581564,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();",4
27581564,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < mdbytes.length; i++) {
          sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
        }

        System.out.println(""Digest(in hex format):: "" + sb.toString());

        //convert the byte to hex format method 2",4
27581564,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < mdbytes.length; i++) {
          sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
        }

        System.out.println(""Digest(in hex format):: "" + sb.toString());

        //convert the byte to hex format method 2
        StringBuffer hexString = new StringBuffer();",4
27581564,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0; 
        while ((nread = fis.read(dataBytes)) != -1) {
          md.update(dataBytes, 0, nread);
        };
        byte[] mdbytes = md.digest();

        //convert the byte to hex format method 1
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < mdbytes.length; i++) {
          sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
        }

        System.out.println(""Digest(in hex format):: "" + sb.toString());

        //convert the byte to hex format method 2
        StringBuffer hexString = new StringBuffer();
        for (int i=0;i<mdbytes.length;i++) {
            String hex=Integer.toHexString(0xff & mdbytes[i]);
            if(hex.length()==1) hexString.append('0');
            hexString.append(hex);
        }
        System.out.println(""Digest(in hex format):: "" + hexString.toString());
",4
27614557,1,"    byte[] array = md.digest(str1.getBytes(""UTF-8""));
    StringBuilder sb = new StringBuilder();
    for (byte b : array) {
        sb.append(String.format(""%02X"", b));
    }",4
27621392,0,"public class sample{
/**
 * Creates a cipher for encryption or decryption.
 * 
 * @param algorithm  PBE algorithm like ""PBEWithMD5AndDES"" or ""PBEWithMD5AndTripleDES"".
 * @param mode Encyrption or decyrption.
 * @param password Password
 * @param salt Salt usable with algorithm.
 * @param count Iterations.
 * @return Ready initialized cipher.
 * @throws GeneralSecurityException Error creating the cipher.
 */
private static Cipher createCipher(final String algorithm, final int mode, final char[] password, final byte[] salt, final int count) throws GeneralSecurityException {
    final SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algorithm);
    final PBEKeySpec keySpec = new PBEKeySpec(password);
    final SecretKey key = keyFactory.generateSecret(keySpec);
    final Cipher cipher = Cipher.getInstance(algorithm);
    final PBEParameterSpec params = new PBEParameterSpec(salt, count);
    cipher.init(mode, key, params);
    return cipher;
}

/**
 * Encrypts some data based on a password.
 * @param algorithm PBE algorithm like ""PBEWithMD5AndDES"" or ""PBEWithMD5AndTripleDES""
 * @param data Data to encrypt
 * @param password Password
 * @param salt Salt usable with algorithm
 * @param count Iterations.
 * @return Encrypted data.
 */
public static byte[] encryptPasswordBased(final String algorithm, final byte[] data, final char[] password, final byte[] salt, final int count) {
    Validate.notNull(algorithm);
    Validate.notNull(data);
    Validate.notNull(password);
    Validate.notNull(salt);
    try {
        final Cipher cipher = createCipher(algorithm, Cipher.ENCRYPT_MODE, password, salt, count);
        return cipher.doFinal(data);
    } catch (final Exception ex) {
        throw new RuntimeException(""Error encrypting the password!"", ex);
    }
}

/**
 * Decrypts some data based on a password.
 * @param algorithm PBE algorithm like ""PBEWithMD5AndDES"" or ""PBEWithMD5AndTripleDES""
 * @param encryptedData Data to decrypt
 * @param password Password
 * @param salt Salt usable with algorithm
 * @param count Iterations.
 * @return Encrypted data.
 */
public static byte[] decryptPasswordBased(final String algorithm, final byte[] encryptedData, final char[] password, final byte[] salt, final int count) {
    Validate.notNull(algorithm);
    Validate.notNull(encryptedData);
    Validate.notNull(password);
    Validate.notNull(salt);
    try {
        final Cipher cipher = createCipher(algorithm, Cipher.DECRYPT_MODE, password, salt, count);
        return cipher.doFinal(encryptedData);
    } catch (final Exception ex) {
        throw new RuntimeException(""Error decrypting the password!"", ex);
    }
}
",2
27621392,0,"public static byte[] encryptPasswordBased(final String algorithm, final byte[] data, final char[] password, final byte[] salt, final int count) {
    Validate.notNull(algorithm);
    Validate.notNull(data);
    Validate.notNull(password);
    Validate.notNull(salt);
    try {
        final Cipher cipher = createCipher(algorithm, Cipher.ENCRYPT_MODE, password, salt, count);
        return cipher.doFinal(data);
    } catch (final Exception ex) {
        throw new RuntimeException(""Error encrypting the password!"", ex);
    }
}

/**
 * Decrypts some data based on a password.
 * @param algorithm PBE algorithm like ""PBEWithMD5AndDES"" or ""PBEWithMD5AndTripleDES""
 * @param encryptedData Data to decrypt
 * @param password Password
 * @param salt Salt usable with algorithm
 * @param count Iterations.
 * @return Encrypted data.
 */",2
27621392,0,"public static byte[] decryptPasswordBased(final String algorithm, final byte[] encryptedData, final char[] password, final byte[] salt, final int count) {
    Validate.notNull(algorithm);
    Validate.notNull(encryptedData);
    Validate.notNull(password);
    Validate.notNull(salt);
    try {
        final Cipher cipher = createCipher(algorithm, Cipher.DECRYPT_MODE, password, salt, count);
        return cipher.doFinal(encryptedData);
    } catch (final Exception ex) {
        throw new RuntimeException(""Error decrypting the password!"", ex);
    }
}
",2
27621456,0,"public class sample{
/**
 * Creates a cipher for encryption or decryption.
 * 
 * @param algorithm  PBE algorithm like ""PBEWithMD5AndDES"" or ""PBEWithMD5AndTripleDES"".
 * @param mode Encyrption or decyrption.
 * @param password Password
 * @param salt Salt usable with algorithm.
 * @param count Iterations.
 * @return Ready initialized cipher.
 * @throws GeneralSecurityException Error creating the cipher.
 */
private static Cipher createCipher(final String algorithm, final int mode, final char[] password, final byte[] salt, final int count) throws GeneralSecurityException {
    final SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(algorithm);
    final PBEKeySpec keySpec = new PBEKeySpec(password);
    final SecretKey key = keyFactory.generateSecret(keySpec);
    final Cipher cipher = Cipher.getInstance(algorithm);
    final PBEParameterSpec params = new PBEParameterSpec(salt, count);
    cipher.init(mode, key, params);
    return cipher;
}

/**
 * Encrypts some data based on a password.
 * @param algorithm PBE algorithm like ""PBEWithMD5AndDES"" or ""PBEWithMD5AndTripleDES""
 * @param data Data to encrypt
 * @param password Password
 * @param salt Salt usable with algorithm
 * @param count Iterations.
 * @return Encrypted data.
 */
public static byte[] encryptPasswordBased(final String algorithm, final byte[] data, final char[] password, final byte[] salt, final int count) {
    Validate.notNull(algorithm);
    Validate.notNull(data);
    Validate.notNull(password);
    Validate.notNull(salt);
    try {
        final Cipher cipher = createCipher(algorithm, Cipher.ENCRYPT_MODE, password, salt, count);
        return cipher.doFinal(data);
    } catch (final Exception ex) {
        throw new RuntimeException(""Error encrypting the password!"", ex);
    }
}

/**
 * Decrypts some data based on a password.
 * @param algorithm PBE algorithm like ""PBEWithMD5AndDES"" or ""PBEWithMD5AndTripleDES""
 * @param encryptedData Data to decrypt
 * @param password Password
 * @param salt Salt usable with algorithm
 * @param count Iterations.
 * @return Encrypted data.
 */
public static byte[] decryptPasswordBased(final String algorithm, final byte[] encryptedData, final char[] password, final byte[] salt, final int count) {
    Validate.notNull(algorithm);
    Validate.notNull(encryptedData);
    Validate.notNull(password);
    Validate.notNull(salt);
    try {
        final Cipher cipher = createCipher(algorithm, Cipher.DECRYPT_MODE, password, salt, count);
        return cipher.doFinal(encryptedData);
    } catch (final Exception ex) {
        throw new RuntimeException(""Error decrypting the password!"", ex);
    }
}
",2
27621456,0,"public static byte[] encryptPasswordBased(final String algorithm, final byte[] data, final char[] password, final byte[] salt, final int count) {
    Validate.notNull(algorithm);
    Validate.notNull(data);
    Validate.notNull(password);
    Validate.notNull(salt);
    try {
        final Cipher cipher = createCipher(algorithm, Cipher.ENCRYPT_MODE, password, salt, count);
        return cipher.doFinal(data);
    } catch (final Exception ex) {
        throw new RuntimeException(""Error encrypting the password!"", ex);
    }
}

/**
 * Decrypts some data based on a password.
 * @param algorithm PBE algorithm like ""PBEWithMD5AndDES"" or ""PBEWithMD5AndTripleDES""
 * @param encryptedData Data to decrypt
 * @param password Password
 * @param salt Salt usable with algorithm
 * @param count Iterations.
 * @return Encrypted data.
 */",2
27621456,0,"public static byte[] decryptPasswordBased(final String algorithm, final byte[] encryptedData, final char[] password, final byte[] salt, final int count) {
    Validate.notNull(algorithm);
    Validate.notNull(encryptedData);
    Validate.notNull(password);
    Validate.notNull(salt);
    try {
        final Cipher cipher = createCipher(algorithm, Cipher.DECRYPT_MODE, password, salt, count);
        return cipher.doFinal(encryptedData);
    } catch (final Exception ex) {
        throw new RuntimeException(""Error decrypting the password!"", ex);
    }
}
",2
27621696,0,"    String privateKeyPEM = key;
    privateKeyPEM = privateKeyPEM.replace(""-----BEGIN PRIVATE KEY-----\n"", """");
    privateKeyPEM = privateKeyPEM.replace(""-----END PRIVATE KEY-----"", """");
    byte[] encoded = Base64.decodeBase64(privateKeyPEM);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");",3
27621696,0,"    String publicKeyPEM = key;
    publicKeyPEM = publicKeyPEM.replace(""-----BEGIN PUBLIC KEY-----\n"", """");
    publicKeyPEM = publicKeyPEM.replace(""-----END PUBLIC KEY-----"", """");
    byte[] encoded = Base64.decodeBase64(publicKeyPEM);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");",3
27706920,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }",1
27729343,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
27748576,0,"  for (Signature signature : info.signatures) {
  MessageDigest md = MessageDigest.getInstance(""SHA"");
  md.update(signature.toByteArray());
  Log.e(""MY KEY HASH:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
      }",4
27783382,0,"            byte[] keyb = seed.getBytes(""utf-8"");
            MessageDigest md = MessageDigest.getInstance(""SHA-256"");
            byte[] thedigest = md.digest(keyb);
            SecretKeySpec skey = new SecretKeySpec(thedigest, ""AES"");
            Cipher dcipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");",24
27783382,0,"            SecretKeySpec skey = new SecretKeySpec(thedigest, ""AES"");
            Cipher dcipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            dcipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(seed.getBytes(""UTF-8""), ""AES""), new IvParameterSpec(iv));",2
27783382,0,"            Cipher dcipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            dcipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(seed.getBytes(""UTF-8""), ""AES""), new IvParameterSpec(iv));",2
27783382,0,"            SecretKeySpec skc = new SecretKeySpec(thedigest, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key.getBytes(""UTF-8""), ""AES""), new IvParameterSpec(iv));",2
27783382,0,"            byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
            int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
            ctLength += cipher.doFinal(cipherText, ctLength);",2
27821166,0,"        CipherOutputStream cos = new CipherOutputStream(fos, cipher);

        int b;
        byte[] d = new byte[8];
        while((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }

        cos.flush();
        cos.close();
        fis.close();

",2
27821166,0,"            CipherInputStream cis = new CipherInputStream(fis, cipher);
            int b;
            byte[] d = new byte[8];
            while((b = cis.read(d)) != -1) {
                fos.write(d, 0, b);
            }
            fos.flush();
            fos.close();
            cis.close();",2
27821166,0,"            CipherInputStream cis = new CipherInputStream(fis, cipher);
            int b;
            byte[] d = new byte[8];
            while((b = cis.read(d)) != -1) {
                fos.write(d, 0, b);
            }
            fos.flush();
            fos.close();
            cis.close();",2
27841164,2,"public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
    return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
}

@Override
public Socket createSocket() throws IOException {
    return sslContext.getSocketFactory().createSocket();
}
",1
27928360,0,"        private static Socket makeSocketSafe(Socket socket) {
            if (socket instanceof SSLSocket) {
                socket = new NoSSLv3SSLSocket((SSLSocket) socket);
            }
            return socket;
        }

        @Override
        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
            return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
        }

        @Override
        public Socket createSocket(String host, int port) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port));
        }

        @Override
        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
        }

        @Override
        public Socket createSocket(InetAddress host, int port) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port));
        }

        @Override
        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
            return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
        }

        /**
         * Created by robUx4 on 25/10/2014.
         */",1
27928360,0,"        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
            return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
        }

        @Override
        public Socket createSocket(String host, int port) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port));
        }

        @Override
        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
        }

        @Override
        public Socket createSocket(InetAddress host, int port) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port));
        }

        @Override
        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
            return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
        }

        /**
         * Created by robUx4 on 25/10/2014.
         */",1
27928360,0,"        public Socket createSocket(String host, int port) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port));
        }

        @Override
        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
            return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
        }

        @Override",1
27928360,0,"            private NoSSLv3SSLSocket(SSLSocket delegate) {
                super(delegate);

                String canonicalName = delegate.getClass().getCanonicalName();
                if (!canonicalName.equals(""org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl"")) {
                    // try replicate the code from HttpConnection.setupSecureSocket()
                    try {
                        Method msetUseSessionTickets = delegate.getClass().getMethod(""setUseSessionTickets"", boolean.class);
                        if (null != msetUseSessionTickets) {
                            msetUseSessionTickets.invoke(delegate, true);
                        }
                    } catch (NoSuchMethodException ignored) {
                    } catch (InvocationTargetException ignored) {
                    } catch (IllegalAccessException ignored) {
                    }
                }",1
27955414,0,"   PrivateKey privateKey = kp.getPrivate();

   byte[] PublicKey = publicKey.getEncoded();
   byte[] PrivateKey = privateKey.getEncoded();

   out.println(""Encoded Public : ""+Base64.encode(PublicKey));
   out.println(""\nEncoded Private : ""+Base64.encode(PrivateKey));",3
27955414,1,"import codec.Base64;
import codec.CorruptedCodeException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PublicKey;
import java.security.Security;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
...
    Security.addProvider(new BouncyCastleProvider());

// Assume that we know the encoded public key then return it by decode the public key
    byte[] decodedPublic = Base64.decode(""MEIwFAYHKoZIzj0CAQYJKyQDAwIIAQEBAyoABNXclcmtUt8/rlGN47pc8ZpxkWgNgtKeeHdsVD0kIWLUMEULnchGZPA="".getBytes());

    X509EncodedKeySpec formatted_public = new X509EncodedKeySpec(decodedPublic);
    KeyFactory kf = KeyFactory.getInstance(""EC"",""BC"");
    PublicKey pubKey = kf.generatePublic(formatted_public);
",4
27955414,1,"    KeyFactory kf = KeyFactory.getInstance(""EC"",""BC"");
    PublicKey pubKey = kf.generatePublic(formatted_public);

    Cipher c = Cipher.getInstance(""ECIES"", ""BC"");

    c.init(Cipher.ENCRYPT_MODE, pubKey); // How can i put the AES128_CBC for ies parameter ? is that possible
",3
27955414,2,"import codec.Base64;
import codec.CorruptedCodeException;
import java.security.InvalidKeyException;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.Security;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
...
    Security.addProvider(new BouncyCastleProvider());
// Assume that we know the encoded private key
    byte[] decodedPrivate = Base64.decode(""MHECAQAwFAYHKoZIzj0CAQYJKyQDAwIIAQEBBFYwVAIBAQQUQmA9ifs472gNHBc5NSGYq56TlOKgCwYJKyQDAwIIAQEBoSwDKgAE1dyVya1S3z+uUY3julzxmnGRaA2C0p54d2xUPSQhYtQwRQudyEZk8A=="".getBytes());

    PKCS8EncodedKeySpec formatted_private = new PKCS8EncodedKeySpec(decodedPrivate);
    KeyFactory kf = KeyFactory.getInstance(""EC"", ""BC"");
    PrivateKey privKey = kf.generatePrivate(formatted_private);
",4
27955414,2,"    PrivateKey privKey = kf.generatePrivate(formatted_private);

    Cipher c = Cipher.getInstance(""ECIES"");
    c.init(Cipher.DECRYPT_MODE, privKey); //How can i adding the **AES128_CBC** ies param ?

// Assume that we know the encoded cipher text
    byte[] plaintext = c.doFinal(Base64.decode(""BKbCsKY7gDPld+F4jauQXvKSayYCt6vOjIGbsyXo5fHWo4Ax+Nt5BQ5FlkAGksFNRQ46agzfxjfuoxWkVfnt4gReDmpPYueUbiRiHp1Gwp0=""));",3
27962341,0,"        public synchronized byte[] encrypt( byte[] data )
        throws CryptoException {
            if( data == null || data.length == 0 ){
                return new byte[0];
            }

            cipher.init( true, key );
            return callCipher( data );
        }
       // Encrypts a string.
",2
27962341,0,"        public synchronized byte[] decrypt( byte[] data )
        throws CryptoException {
            if( data == null || data.length == 0 ){
                return new byte[0];
            }

            cipher.init( false, key );
            return callCipher( data );
        }
        // Decrypts a string that was previously encoded
        // using encryptString.
",2
27994236,2,"                byte[] array = md.digest(md5.getBytes());
                StringBuffer sb = new StringBuffer();
                for (int i = 0; i < array.length; ++i) {
                  sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3));
               }
                return sb.toString();",4
28030418,0,"Signature instance = Signature.getInstance(""SHA256withRSA"");
instance.initSign(privateKey, new SecureRandom());
instance.update(myData.getBytes(""UTF-8"")); // encoding is important
byte[] signature = instance.sign();

// verify
instance.initVerify(publicKey);
instance.update(myData.getBytes(""UTF-8"")); // encoding is important
System.out.println(instance.verify(signature));
",4
28045744,3,"Signature instance = Signature.getInstance(""SHA256withRSA"");
instance.initSign(privateKey, new SecureRandom());
instance.update(myData.getBytes(""UTF-8""));
byte[] signedBytes = instance.sign();

instance.initVerify(publicKey);
instance.update(myData.getBytes(""UTF-8""));
System.out.println(instance.verify(signedBytes));
",4
28050457,0,"    RSAPublicKey pubKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);
    cipher.init(Cipher.ENCRYPT_MODE, pubKey);
    byte[] cipherText = cipher.doFinal(input);
    System.out.println(""cipher: "" + new String(cipherText));
",3
28053625,0,"    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keyStore);
    TrustManager[] trustManagers = factory.getTrustManagers();
    if(trustManagers.length ==0){
        throw new NoSuchAlgorithmException(""Failed to find Default trust managers"");
    }

    this.defaultManager = (X509TrustManager) trustManagers[0];
",1
28053625,0,"            foundNext = false;
            for(int nextIndex = index + 1; nextIndex < x509Certificates.length; ++nextIndex){
                //look for the next certificate in the chain.
                if(x509Certificates[index].getIssuerDN().equals(x509Certificates[nextIndex].getSubjectDN())){
                    foundNext = true;
                    //exchange certificates so that 0 through index+1 are in proper order.
                    if(nextIndex != index+1){
                        X509Certificate tempCert = x509Certificates[nextIndex];
                        x509Certificates[nextIndex] = x509Certificates[index+1];
                        x509Certificates[index+1] = tempCert;
                    }
                    break;
                }

            }

            if(!foundNext){
                break;
            }

        }

        //if the cert is self signed and if it is expired, if so we drop it and pass the rest to checkServerTrusted, hoping we may have a similar bu unexpired trusted root.
        chainln = index +1;
        X509Certificate lastCert = x509Certificates[chainln - 1];
        Date now = new Date();
        if(lastCert.getSubjectDN().equals(lastCert.getIssuerDN()) && now.after(lastCert.getNotAfter())){
            --chainln;
        }",1
28053625,1,"public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
    return sslContext.getSocketFactory().createSocket(socket, host, port,autoClose);
}

@Override
public Socket createSocket() throws IOException{
    return sslContext.getSocketFactory().createSocket();
}",1
28070037,0," public void foo(){
Base64 encoder = new Base64(64);
String cert_begin = ""-----BEGIN CERTIFICATE-----\n"";
String end_cert = ""-----END CERTIFICATE-----"";      
byte[] derCert = x509cert.getEncoded();
String pemCertPre = new String(encoder.encode(derCert));
String pemCert = cert_begin + pemCertPre + end_cert;
return pemCert;
",3
28150343,0,"try
{
    cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, rsaKeyPair.getPublic());
    txt = cipher.doFinal(txt);
}
catch (Throwable e)
{
    e.printStackTrace();
    return;
}
System.out.println(""Encrypted message: "" + new String(txt));

// decrypt",3
28150343,0,"try
{
    cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");
    cipher.init(Cipher.DECRYPT_MODE, rsaKeyPair.getPrivate());
    txt = cipher.doFinal(txt);
}
catch (Throwable e)
{
    e.printStackTrace();
    return;
}
System.out.println(""Decrypted message: "" + new String(txt));
",3
28154780,0,"        byte[] key = (salt + password).getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key,16);",4
28154780,0,"        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }
        cos.flush();
        cos.close();
        fis.close();",2
28154780,0,"        byte[] key = (salt + password).getBytes(""UTF-8"");
        MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
        key = sha.digest(key);
        key = Arrays.copyOf(key,16);",4
28154780,0,"        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = cis.read(d)) != -1) {
            fos.write(d, 0, b);
        }
        fos.flush();
        fos.close();
        cis.close();",2
28154780,0,"        CipherInputStream cis = new CipherInputStream(fis, cipher);
        int b;
        byte[] d = new byte[8];
        while((b = cis.read(d)) != -1) {
            fos.write(d, 0, b);
        }
        fos.flush();
        fos.close();
        cis.close();",2
28178971,0,"        final BigInteger x = new BigInteger(1, Arrays.copyOfRange(
                uncompressedPoint, offset, offset + keySizeBytes));
        offset += keySizeBytes;
        final BigInteger y = new BigInteger(1, Arrays.copyOfRange(
                uncompressedPoint, offset, offset + keySizeBytes));
        final ECPoint w = new ECPoint(x, y);
        final ECPublicKeySpec ecPublicKeySpec = new ECPublicKeySpec(w, params);
        final KeyFactory keyFactory = KeyFactory.getInstance(""EC"");",3
28233537,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }
",1
28263522,1,"    SecureRandom random = new SecureRandom();
    byte[] salt = new byte[saltLength];
    random.nextBytes(salt);
    KeySpec keySpec = new PBEKeySpec(seed.toCharArray(), salt,
            iterationCount, keyLength);
    SecretKeyFactory keyFactory = SecretKeyFactory
            .getInstance(""PBKDF2WithHmacSHA1"");
    byte[] raw = keyFactory.generateSecret(keySpec).getEncoded();
",2
28263522,1,"    KeySpec keySpec = new PBEKeySpec(seed.toCharArray(), salt,
            iterationCount, keyLength);
    SecretKeyFactory keyFactory = SecretKeyFactory
            .getInstance(""PBKDF2WithHmacSHA1"");
    byte[] raw = keyFactory.generateSecret(keySpec).getEncoded();
",2
28301697,0,"public static byte[] encrypt(byte[] plainText, byte[] encryptionKey)
        throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
    SecretKeySpec key = new SecretKeySpec(encryptionKey, ""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(IV));
    return cipher.doFinal(plainText);
}
",2
28301697,0,"public static byte[] decrypt(byte[] cipherText, byte[] encryptionKey)
        throws Exception {
    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
    SecretKeySpec key = new SecretKeySpec(encryptionKey, ""AES"");
    cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(IV));
    return cipher.doFinal(cipherText);
}
",2
28314871,0,"        rfile.seek(rfile.length()-32); // second to last block
        rfile.read(iv); // get iv
        byte[] lastBlockEnc = new byte[16]; 
            // last block
            // it's padded, so we'll decrypt it and 
            // save it for the beginning of our data
        rfile.read(lastBlockEnc);
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");",2
28368275,0,"        final byte[] ivData = new byte[blockSize];
        final SecureRandom rnd = SecureRandom.getInstance(""SHA1PRNG"");
        rnd.nextBytes(ivData);
        final IvParameterSpec iv = new IvParameterSpec(ivData);

        cipher.init(Cipher.ENCRYPT_MODE, symKey, iv);

        final byte[] encryptedMessage = cipher.doFinal(encodedMessage);

        // concatenate IV and encrypted message
        final byte[] ivAndEncryptedMessage = new byte[ivData.length
                + encryptedMessage.length];
        System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);
        System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage,
                blockSize, encryptedMessage.length);
",2
28595657,0,"        Cipher decrypterWithPad = Cipher.getInstance(""AES/CBC/PKCS7PADDING"", ""BC"");
        decrypterWithPad.init(Cipher.DECRYPT_MODE, secretKey, IVspec);
        byte[] buffer1 = new byte[encryptedData.length]; 
        int decryptLen1 = decrypterWithPad.doFinal(encryptedData, 0, encryptedData.length, buffer1); 
        System.out.println(""Decrypted with Pad ("" + decryptLen1 + "" bytes):  \t"" + toHexString(buffer1));

        // decrypt without PKCS7 pad",2
28595657,0,"        Cipher decrypterWithoutPad = Cipher.getInstance(""AES/CBC/NOPADDING"", ""BC"");
        decrypterWithoutPad.init(Cipher.DECRYPT_MODE, secretKey, IVspec);
        byte[] buffer2 = new byte[encryptedData.length]; 
        int decryptLen2 = decrypterWithoutPad.doFinal(encryptedData, 0, encryptedData.length, buffer2); 
        System.out.println(""Decrypted without Pad ("" + decryptLen2 + "" bytes):\t"" + toHexString(buffer2));",2
28600389,0,"    final CipherOutputStream output = new CipherOutputStream(fos, cipher);

    int bytesRead = 0;
    final byte[] plainText = new byte[4096];
    while ((bytesRead = fis.read(plainText)) >= 0) {
        output.write(plainText, 0, bytesRead);
    }
    output.flush();
    output.close();
    fos.close();
    fis.close();
    final byte[] iv = cipher.getIV();

    // decrypt the file
    cipher.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));",2
28624160,0,"public class EncryptionDecryption {

    private static String salt;
    private static int iterations = 65536  ;
    private static int keySize = 256;
    private static byte[] ivBytes;

    private static SecretKey secretKey;

    public static void main(String []args) throws Exception {

        salt = getSalt();

        char[] message = ""PasswordToEncrypt"".toCharArray();
        System.out.println(""Message: "" + String.valueOf(message));
        System.out.println(""Encrypted: "" + encrypt(message));
        System.out.println(""Decrypted: "" + decrypt(encrypt(message).toCharArray()));
    }

    public static String encrypt(char[] plaintext) throws Exception {
        byte[] saltBytes = salt.getBytes();

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(plaintext, saltBytes, iterations, keySize);
        secretKey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] encryptedTextBytes = cipher.doFinal(String.valueOf(plaintext).getBytes(""UTF-8""));

        return DatatypeConverter.printBase64Binary(encryptedTextBytes);
    }

    public static String decrypt(char[] encryptedText) throws Exception {

        System.out.println(encryptedText);

        byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(new String(encryptedText));
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        }   catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }   catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return new String(decryptedTextBytes);

    }

    public static String getSalt() throws Exception {

        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        byte[] salt = new byte[20];
        sr.nextBytes(salt);
        return new String(salt);
    }
}",25
28624160,0,"        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();",2
28624160,0,"        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));
",2
28624160,0,"        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        }   catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }   catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return new String(decryptedTextBytes);
",2
28711528,0,"public static byte[] decrypt(byte[] cipher, byte[] key/* , byte[] iv */)
        throws Exception {
    /*
     * PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher( new
     * CBCBlockCipher(new AESEngine())); CipherParameters ivAndKey = new
     * ParametersWithIV(new KeyParameter(key), iv); aes.init(false,
     * ivAndKey); return cipherData(aes, cipher);
     */
    BufferedBlockCipher aes = new PaddedBufferedBlockCipher(
            new CBCBlockCipher(new AESEngine()));

    KeyParameter secretKey = new KeyParameter(key);

    aes.init(false, secretKey);
    return cipherData(aes, cipher);

}
",2
28711528,0,"public static byte[] encrypt(byte[] plain, byte[] key/* , byte[] iv */)
        throws Exception {
    /*
     * PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher( new
     * CBCBlockCipher(new AESEngine())); CipherParameters ivAndKey = new
     * ParametersWithIV(new KeyParameter(key), iv);
     */

    BufferedBlockCipher aes = new PaddedBufferedBlockCipher(
            new CBCBlockCipher(new AESEngine()));

    KeyParameter secretKey = new KeyParameter(key);
    aes.init(true, secretKey);
    return cipherData(aes, plain);

}
",2
28723318,1,"public class sample{
 public void foo(){
RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) privateKey;
return rsaPublicKey.getModulus().equals( rsaPrivateKey.getModulus() )
  && BigInteger.valueOf( 2 ).modPow(
  rsaPublicKey.getPublicExponent().multiply( rsaPrivateKey.getPrivateExponent() )
    .subtract( BigInteger.ONE ), 
  rsaPublicKey.getModulus() ).equals( BigInteger.ONE );

}",3
29092048,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.i(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
29092114,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""Obtained KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
29137323,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
29152379,5,"Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, ""AES""),
        new IvParameterSpec(iv));
byte[] recoveredPlaintextBytes = cipher.doFinal(ciphertextBytes);",2
29152379,6,"    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, ""AES""), new IvParameterSpec(iv));
    byte[] recoveredPlaintextBytes = cipher.doFinal(ciphertextBytes);",2
29152379,6,"public static byte[] EvpKDF(byte[] password, int keySize, int ivSize, byte[] salt, byte[] resultKey, byte[] resultIv) throws NoSuchAlgorithmException {
    return EvpKDF(password, keySize, ivSize, salt, 1, ""MD5"", resultKey, resultIv);
}
",2
29152379,6,"    int targetKeySize = keySize + ivSize;
    byte[] derivedBytes = new byte[targetKeySize * 4];
    int numberOfDerivedWords = 0;
    byte[] block = null;
    MessageDigest hasher = MessageDigest.getInstance(hashAlgorithm);
    while (numberOfDerivedWords < targetKeySize) {
        if (block != null) {
            hasher.update(block);
        }
        hasher.update(password);
        block = hasher.digest(salt);
        hasher.reset();

        // Iterations
        for (int i = 1; i < iterations; i++) {
            block = hasher.digest(block);
            hasher.reset();
        }

        System.arraycopy(block, 0, derivedBytes, numberOfDerivedWords * 4,
                Math.min(block.length, (targetKeySize - numberOfDerivedWords) * 4));

        numberOfDerivedWords += block.length/4;
    }

    System.arraycopy(derivedBytes, 0, resultKey, 0, keySize * 4);
    System.arraycopy(derivedBytes, keySize * 4, resultIv, 0, ivSize * 4);

    return derivedBytes; // key + iv",24
29152379,6,"    int targetKeySize = keySize + ivSize;
    byte[] derivedBytes = new byte[targetKeySize * 4];
    int numberOfDerivedWords = 0;
    byte[] block = null;
    MessageDigest hasher = MessageDigest.getInstance(hashAlgorithm);
    while (numberOfDerivedWords < targetKeySize) {
        if (block != null) {
            hasher.update(block);
        }
        hasher.update(password);
        block = hasher.digest(salt);
        hasher.reset();

        // Iterations
        for (int i = 1; i < iterations; i++) {
            block = hasher.digest(block);
            hasher.reset();
        }

        System.arraycopy(block, 0, derivedBytes, numberOfDerivedWords * 4,
                Math.min(block.length, (targetKeySize - numberOfDerivedWords) * 4));

        numberOfDerivedWords += block.length/4;
    }

    System.arraycopy(derivedBytes, 0, resultKey, 0, keySize * 4);
    System.arraycopy(derivedBytes, keySize * 4, resultIv, 0, ivSize * 4);

    return derivedBytes; // key + iv
}

/**
 * Copied from https://stackoverflow.com/a/140861
 * */
public static byte[] hexStringToByteArray(String s) {
    int len = s.length();
    byte[] data = new byte[len / 2];
    for (int i = 0; i < len; i += 2) {
        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)
                + Character.digit(s.charAt(i+1), 16));
    }
    return data;
}
",4
29236370,0,"    Cipher c = null;
    try {
        c = Cipher.getInstance(algorithm);
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    SecretKeySpec k =  new SecretKeySpec(key, algorithm);
    try {
        c.init(Cipher.ENCRYPT_MODE, k);",2
29236370,0,"    Cipher c = null;
    try {
        c = Cipher.getInstance(algorithm);
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    SecretKeySpec k =
            new SecretKeySpec(key, algorithm);
    try {
        c.init(Cipher.DECRYPT_MODE, k);",2
29242678,2,"public class sample{
public static PublicKey readPublicKeyNative(String publicKeyPath) {
     Security.addProvider(new BouncyCastleProvider());
     KeyFactory factory = null;
     PublicKey key = null;
     byte[] publicKeyFileBytes = null;

     try {
         publicKeyFileBytes = Files.readAllBytes(Paths.get(publicKeyPath));
     } catch (IOException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
     }
     String KeyString = new String(publicKeyFileBytes);
     //System.out.println(KeyString);
     //System.out.println(""FORMATTED:"");
     KeyString = KeyString.replaceAll(""-----BEGIN RSA PUBLIC KEY-----"", """");
     KeyString = KeyString.replaceAll(""-----END RSA PUBLIC KEY-----"", """");
     KeyString = KeyString.replaceAll(""[\n\r]"", """");
     KeyString = KeyString.trim();
     //System.out.println(KeyString);

     byte[] encoded = Base64.getDecoder().decode(KeyString);

     // PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);
     X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encoded);
     try {
         factory = KeyFactory.getInstance(""RSA"");
         key = factory.generatePublic(keySpec);
     } catch (NoSuchAlgorithmException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
     } catch (InvalidKeySpecException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
     }
     return key;
}

public static PrivateKey readPrivateKeyNative(String privateKeyPath) {
    Security.addProvider(new BouncyCastleProvider());
    KeyFactory factory = null;
    PrivateKey key = null;
    byte[] privateKeyFileBytes = null;

    try {
        privateKeyFileBytes = Files.readAllBytes(Paths.get(privateKeyPath));
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    String KeyString = new String(privateKeyFileBytes);
    //System.out.println(KeyString);
    //System.out.println(""FORMATTED:"");
    KeyString = KeyString.replaceAll(""-----BEGIN RSA PRIVATE KEY-----"", """");
    KeyString = KeyString.replaceAll(""-----END RSA PRIVATE KEY-----"", """");
    KeyString = KeyString.replaceAll(""[\n\r]"", """");
    KeyString = KeyString.trim();
    //System.out.println(KeyString);

    byte[] encoded = Base64.getDecoder().decode(KeyString);

    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);
    // X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encoded);
    try {
        factory = KeyFactory.getInstance(""RSA"");
        key = factory.generatePrivate(keySpec);
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeySpecException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return key;
}
",3
29242678,2,"public static PublicKey readPublicKeyNative(String publicKeyPath) {
     Security.addProvider(new BouncyCastleProvider());
     KeyFactory factory = null;
     PublicKey key = null;
     byte[] publicKeyFileBytes = null;

     try {
         publicKeyFileBytes = Files.readAllBytes(Paths.get(publicKeyPath));
     } catch (IOException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
     }
     String KeyString = new String(publicKeyFileBytes);
     //System.out.println(KeyString);
     //System.out.println(""FORMATTED:"");
     KeyString = KeyString.replaceAll(""-----BEGIN RSA PUBLIC KEY-----"", """");
     KeyString = KeyString.replaceAll(""-----END RSA PUBLIC KEY-----"", """");
     KeyString = KeyString.replaceAll(""[\n\r]"", """");
     KeyString = KeyString.trim();
     //System.out.println(KeyString);

     byte[] encoded = Base64.getDecoder().decode(KeyString);

     // PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);
     X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encoded);
     try {
         factory = KeyFactory.getInstance(""RSA"");
         key = factory.generatePublic(keySpec);
     } catch (NoSuchAlgorithmException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
     } catch (InvalidKeySpecException e) {
         // TODO Auto-generated catch block
         e.printStackTrace();
     }
     return key;
}
",3
29242678,2,"public static PrivateKey readPrivateKeyNative(String privateKeyPath) {
    Security.addProvider(new BouncyCastleProvider());
    KeyFactory factory = null;
    PrivateKey key = null;
    byte[] privateKeyFileBytes = null;

    try {
        privateKeyFileBytes = Files.readAllBytes(Paths.get(privateKeyPath));
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    String KeyString = new String(privateKeyFileBytes);
    //System.out.println(KeyString);
    //System.out.println(""FORMATTED:"");
    KeyString = KeyString.replaceAll(""-----BEGIN RSA PRIVATE KEY-----"", """");
    KeyString = KeyString.replaceAll(""-----END RSA PRIVATE KEY-----"", """");
    KeyString = KeyString.replaceAll(""[\n\r]"", """");
    KeyString = KeyString.trim();
    //System.out.println(KeyString);

    byte[] encoded = Base64.getDecoder().decode(KeyString);

    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);
    // X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encoded);
    try {
        factory = KeyFactory.getInstance(""RSA"");
        key = factory.generatePrivate(keySpec);
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeySpecException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return key;
}
",3
29242678,3,"public class sample{
public static PublicKey readPublicKeyNative(String publicKeyPath) {
    Security.addProvider(new BouncyCastleProvider());
    KeyFactory factory = null;
    PublicKey key = null;
    byte[] publicKeyFileBytes = null;

    try {
        publicKeyFileBytes = Files.readAllBytes(Paths.get(publicKeyPath));
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    String KeyString = new String(publicKeyFileBytes);

    KeyString = KeyString.replaceAll(""-----BEGIN PUBLIC KEY-----"", """");
    KeyString = KeyString.replaceAll(""-----END PUBLIC KEY-----"", """");
    KeyString = KeyString.replaceAll(""[\n\r]"", """");
    KeyString = KeyString.trim();

    byte[] encoded = Base64.getDecoder().decode(KeyString);

    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encoded);
    try {
        factory = KeyFactory.getInstance(""RSA"");
        key = factory.generatePublic(keySpec);
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeySpecException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return key;
}

public static PrivateKey readPrivateKeyNative(String privateKeyPath) {
    Security.addProvider(new BouncyCastleProvider());
    KeyFactory factory = null;
    PrivateKey key = null;
    byte[] privateKeyFileBytes = null;

    try {
        privateKeyFileBytes = Files.readAllBytes(Paths.get(privateKeyPath));
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    String KeyString = new String(privateKeyFileBytes);

    KeyString = KeyString.replaceAll(""-----BEGIN PRIVATE KEY-----"", """");
    KeyString = KeyString.replaceAll(""-----END PRIVATE KEY-----"", """");
    KeyString = KeyString.replaceAll(""[\n\r]"", """");
    KeyString = KeyString.trim();


    byte[] encoded = Base64.getDecoder().decode(KeyString);

    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);

    try {
        factory = KeyFactory.getInstance(""RSA"");
        key = factory.generatePrivate(keySpec);
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeySpecException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return key;
}
",3
29242678,3,"public static PublicKey readPublicKeyNative(String publicKeyPath) {
    Security.addProvider(new BouncyCastleProvider());
    KeyFactory factory = null;
    PublicKey key = null;
    byte[] publicKeyFileBytes = null;

    try {
        publicKeyFileBytes = Files.readAllBytes(Paths.get(publicKeyPath));
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    String KeyString = new String(publicKeyFileBytes);

    KeyString = KeyString.replaceAll(""-----BEGIN PUBLIC KEY-----"", """");
    KeyString = KeyString.replaceAll(""-----END PUBLIC KEY-----"", """");
    KeyString = KeyString.replaceAll(""[\n\r]"", """");
    KeyString = KeyString.trim();

    byte[] encoded = Base64.getDecoder().decode(KeyString);

    X509EncodedKeySpec keySpec = new X509EncodedKeySpec(encoded);
    try {
        factory = KeyFactory.getInstance(""RSA"");
        key = factory.generatePublic(keySpec);
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeySpecException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return key;
}
",3
29242678,3,"public static PrivateKey readPrivateKeyNative(String privateKeyPath) {
    Security.addProvider(new BouncyCastleProvider());
    KeyFactory factory = null;
    PrivateKey key = null;
    byte[] privateKeyFileBytes = null;

    try {
        privateKeyFileBytes = Files.readAllBytes(Paths.get(privateKeyPath));
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    String KeyString = new String(privateKeyFileBytes);

    KeyString = KeyString.replaceAll(""-----BEGIN PRIVATE KEY-----"", """");
    KeyString = KeyString.replaceAll(""-----END PRIVATE KEY-----"", """");
    KeyString = KeyString.replaceAll(""[\n\r]"", """");
    KeyString = KeyString.trim();


    byte[] encoded = Base64.getDecoder().decode(KeyString);

    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(encoded);

    try {
        factory = KeyFactory.getInstance(""RSA"");
        key = factory.generatePrivate(keySpec);
    } catch (NoSuchAlgorithmException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    } catch (InvalidKeySpecException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
    return key;
}
",3
29325210,0,"Cipher aesCBC = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
byte[] iv = new byte[aesCBC.getBlockSize()];
rng.nextBytes(iv);
aesCBC.init(Cipher.ENCRYPT_MODE, aesKey, new IvParameterSpec(iv));
",5
29347142,0,"Key key = generateKey();
Cipher c = Cipher.getInstance(ALGO);
c.init(Cipher.ENCRYPT_MODE, key);
byte[] encVal = c.doFinal(Data.getBytes());",2
29354222,0,"byte[] salt = new byte[16];
random.nextBytes(salt);

KeySpec spec = new PBEKeySpec(""password"".toCharArray(), salt, 65536, 256); // AES-256
SecretKeyFactory f = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
byte[] key = f.generateSecret(spec).getEncoded();
",2
29354222,0,"byte[] ivBytes = new byte[16];
random.nextBytes(ivBytes);
IvParameterSpec iv = new IvParameterSpec(ivBytes);

Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
c.init(Cipher.ENCRYPT_MODE, key, iv);",52
29354222,0,"byte[] ivBytes = new byte[16];
random.nextBytes(ivBytes);
IvParameterSpec iv = new IvParameterSpec(ivBytes);

Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
c.init(Cipher.ENCRYPT_MODE, key, iv);
byte[] encValue = c.doFinal(valueToEnc.getBytes());
",2
29354222,0,"random.nextBytes(ivBytes);
IvParameterSpec iv = new IvParameterSpec(ivBytes);

Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
c.init(Cipher.ENCRYPT_MODE, key, iv);",2
29354222,0,"IvParameterSpec iv = new IvParameterSpec(ivBytes);

Cipher c = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
c.init(Cipher.ENCRYPT_MODE, key, iv);
byte[] encValue = c.doFinal(valueToEnc.getBytes());
",2
29372812,1,"    private static PrivateKey generatePrivateKey(KeyFactory factory,
            String filename) throws InvalidKeySpecException,
            FileNotFoundException, IOException {
        PemFile pemFile = new PemFile(filename);
        byte[] content = pemFile.getPemObject().getContent();
        PKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(content);
        return factory.generatePrivate(privKeySpec);
    }
",3
29372812,1,"    private static PublicKey generatePublicKey(KeyFactory factory,
            String filename) throws InvalidKeySpecException,
            FileNotFoundException, IOException {
        PemFile pemFile = new PemFile(filename);
        byte[] content = pemFile.getPemObject().getContent();
        X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(content);
        return factory.generatePublic(pubKeySpec);
    }",3
29419826,2,"    public byte[] encrypt(byte[] plainText) throws Exception
    {
        SecretKeySpec secretKey = new SecretKeySpec(key, ALGORITHM);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);

        return cipher.doFinal(plainText);
    }

    /**
     * Decrypts the given byte array
     *
     * @param cipherText The data to decrypt
     */",2
29419826,2,"    public byte[] decrypt(byte[] cipherText) throws Exception
    {
        SecretKeySpec secretKey = new SecretKeySpec(key, ALGORITHM);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, secretKey);

        return cipher.doFinal(cipherText);
    }",2
29438602,0,"    public String decrypt(String encryptedString) {
        String decryptedText=null;
        try {
            cipher.init(Cipher.DECRYPT_MODE, key);
            BASE64Decoder base64decoder = new BASE64Decoder();
            byte[] encryptedText = base64decoder.decodeBuffer(encryptedString);
            byte[] plainText = cipher.doFinal(encryptedText);
            decryptedText= bytes2String(plainText);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }

",2
29471097,0,"    Key key = generateKey();
    Cipher c = Cipher.getInstance(ALGORITHM);
    c.init(Cipher.DECRYPT_MODE, key);
    //byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedValue);
    byte[] decordedValue = Base64.decode(encryptedValue, Base64.DEFAULT);

    byte[] decValue = c.doFinal(decordedValue);",2
29489617,1,"IvParameterSpec iv = new IvParameterSpec(ivData);
SecretKeySpec keySpec = new SecretKeySpec(keyData, ""AES"");
Cipher aes = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
aes.init(Cipher.ENCRYPT_MODE, keySpec, iv);",2
29564587,0,"    byte[] saltBytes = salt.getBytes(""UTF-8"");

    // Derive the key
    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    PBEKeySpec spec = new PBEKeySpec(
            password.toCharArray(),
            saltBytes,
            pswdIterations,
            keySize
            );

    SecretKey secretKey = factory.generateSecret(spec);
    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");


    //Get IVBytes of the first 16 bytes of the file",2
29576487,1,"public class sample{
 public void foo(){
SecureRandom r = new SecureRandom(); // should be the best PRNG
byte[] iv = new byte[16];
r.nextBytes(iv);

cipher.init(Cipher.ENCRYPT_MODE, skeySpec, new IvParameterSpec(iv));

}",5
29579366,0,"try {
    c.init(Cipher.ENCRYPT_MODE, new IEKeySpec(akey.getPrivate(), bkey.getPublic()), param);
    //c.init(Cipher.ENCRYPT_MODE, c1Key, param);
    //c.init(Cipher.ENCRYPT_MODE, publicKey, new SecureRandom());
    // How can i put the AES128_CBC for ies parameter ? is that possible
} catch (InvalidKeyException | InvalidAlgorithmParameterException f) {
    f.printStackTrace();
}",-1
29579366,0,"try {
    c.init(Cipher.DECRYPT_MODE, new IEKeySpec(bkey.getPrivate(), akey.getPublic()), param);
} catch (InvalidKeyException | InvalidAlgorithmParameterException f) {
    f.printStackTrace();
}
",-1
29596222,1,"    public Socket createSocket(InetAddress host, int port) throws IOException
    {
        SSLSocketFactory factory = m_ctx.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);

        ss.setEnabledProtocols(m_protocols);
        ss.setEnabledCipherSuites(m_ciphers);

        return ss;
    }
",1
29596222,1,"    public Socket createSocket(String host, int port) throws IOException
    {
        SSLSocketFactory factory = m_ctx.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);

        ss.setEnabledProtocols(m_protocols);
        ss.setEnabledCipherSuites(m_ciphers);

        return ss;
    }
",1
29603246,4,"    byte[] ciphertextBytes = Base64.decodeBase64(encrypted.getBytes());
    IvParameterSpec iv = new IvParameterSpec(ciphertextBytes, 0, 16);
    ciphertextBytes = Arrays.copyOfRange(ciphertextBytes, 16,
            ciphertextBytes.length);

    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
    byte[] original = cipher.doFinal(ciphertextBytes);

    // remove zero bytes at the end
    int lastLength = original.length;
    for (int i = original.length - 1; i > original.length - 16; i--) {
        if (original[i] == (byte) 0) {
            lastLength--;
        } else {
            break;
        }
    }

    return new String(original, 0, lastLength);",2
29605975,7,"public class sample{
 public void foo(){
try
{
    //paste Your package name at the first parameter
    PackageInfo info = getPackageManager().getPackageInfo(""PUT_YOUR_PACKAGE_NAME_HERE"",
            PackageManager.GET_SIGNATURES);
    for (android.content.pm.Signature signature : info.signatures)
    {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String sign = Base64.encodeToString(md.digest(), Base64.DEFAULT);
        Log.e(""MY KEY HASH:"", sign);
        Toast.makeText(getApplicationContext(),sign,     Toast.LENGTH_LONG).show();
    }
}
catch (PackageManager.NameNotFoundException e)
{
}
catch (NoSuchAlgorithmException e)
{
}

}",4
29605975,7,"    for (android.content.pm.Signature signature : info.signatures)
    {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String sign = Base64.encodeToString(md.digest(), Base64.DEFAULT);
        Log.e(""MY KEY HASH:"", sign);
        Toast.makeText(getApplicationContext(),sign,     Toast.LENGTH_LONG).show();
    }",4
29655559,1,"    SecretKeySpec key = new SecretKeySpec((keyString).getBytes(""UTF-8""), ""HmacSHA1"");
    Mac mac = Mac.getInstance(""HmacSHA1"");
    mac.init(key);

    byte[] bytes = mac.doFinal(s.getBytes(""UTF-8""));
",4
29667404,0,"         for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", ""KeyHash:  "" + Base64.encodeToString(md.digest(), Base64.DEFAULT));
         }",4
29668927,0,"byte[] cipherTextBytes = DatatypeConverter.parseBase64Binary(cipherText);
byte[] privateKeyBytes = DatatypeConverter.parseBase64Binary(privateKeyStr);

KeyFactory kf = KeyFactory.getInstance(""RSA"");
PKCS8EncodedKeySpec ks = new PKCS8EncodedKeySpec(privateKeyBytes);
PrivateKey privateKey = kf.generatePrivate(ks);
",3
29671316,2,"public class sample{
 public void foo(){
CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
gen.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(......));
gen.addCertificates(certs);

}",13
29701359,0,"    val cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new RijndaelEngine(256)), new PKCS7Padding());
    val keySize = keyBytes.length;
    val ivAndKey = new ParametersWithIV(new KeyParameter(keyBytes, 0, keySize), ivBytes, 0, keySize);
    cipher.init(true, ivAndKey);",2
29701359,0,"    val encrypted  = new Array[Byte](cipher.getOutputSize(messageBytes.length));
    val oLen = cipher.processBytes(messageBytes, 0, messageBytes.length, encrypted, 0);
    cipher.doFinal(encrypted, oLen);",2
29701359,0,"    val cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new RijndaelEngine(256)), new PKCS7Padding());
    val keySize = keyBytes.length;
    val ivAndKey = new ParametersWithIV(new KeyParameter(keyBytes, 0, keySize), ivBytes, 0, keySize);
    cipher.init(false, ivAndKey);",2
29701359,0,"    val decrypted  = new Array[Byte](cipher.getOutputSize(messageBytes.length));
    val oLen = cipher.processBytes(messageBytes, 0, messageBytes.length, decrypted, 0);
    cipher.doFinal(decrypted, oLen);
",2
29717950,0,"        int offset = generateRandomNonce(nonceAndCiphertext, 0, NONCE_SIZE);
        final GCMParameterSpec nonceIV = generateGCMParametersFromNonce(
                nonceAndCiphertext, 0, NONCE_SIZE, this.cipher.getBlockSize());

        try {
            this.cipher.init(Cipher.ENCRYPT_MODE, this.STATIC_SECRET_KEY,
                    nonceIV);
            offset += this.cipher.doFinal(plaintext, 0, plaintext.length,
                    nonceAndCiphertext, offset);
            if (offset != nonceAndCiphertext.length) {
                throw new IllegalStateException(
                        ""Something wrong during encryption"");
            }
            // Java 8 contains java.util.Base64
            return DatatypeConverter.printBase64Binary(nonceAndCiphertext);
        } catch (final GeneralSecurityException e) {
            throw new IllegalStateException(
                    ""Missing basic functionality from Java runtime"", e);
        }
    }

    public String decrypt(final String encrypted) throws BadPaddingException {
        final byte[] nonceAndCiphertext = DatatypeConverter
                .parseBase64Binary(encrypted);
        final GCMParameterSpec nonceIV = generateGCMParametersFromNonce(
                nonceAndCiphertext, 0, NONCE_SIZE, this.cipher.getBlockSize());
        try {
            this.cipher.init(Cipher.DECRYPT_MODE, this.STATIC_SECRET_KEY,
                    nonceIV);
            final byte[] plaintext = this.cipher.doFinal(nonceAndCiphertext,
                    NONCE_SIZE, nonceAndCiphertext.length - NONCE_SIZE);
            return new String(plaintext, UTF_8);",2
29717950,0,"        final byte[] nonceAndCiphertext = DatatypeConverter
                .parseBase64Binary(encrypted);
        final GCMParameterSpec nonceIV = generateGCMParametersFromNonce(
                nonceAndCiphertext, 0, NONCE_SIZE, this.cipher.getBlockSize());
        try {
            this.cipher.init(Cipher.DECRYPT_MODE, this.STATIC_SECRET_KEY,
                    nonceIV);
            final byte[] plaintext = this.cipher.doFinal(nonceAndCiphertext,
                    NONCE_SIZE, nonceAndCiphertext.length - NONCE_SIZE);
            return new String(plaintext, UTF_8);",2
29717950,1,"        int offset = generateRandomNonce(nonceAndCiphertext, 0, NONCE_SIZE);
        final IvParameterSpec nonceIV = generateIVFromNonce(nonceAndCiphertext,
                0, NONCE_SIZE, this.cipher.getBlockSize());

        try {
            this.cipher.init(Cipher.ENCRYPT_MODE, this.STATIC_SECRET_KEY,
                    nonceIV);
            offset += this.cipher.doFinal(plaintext, 0, plaintext.length,
                    nonceAndCiphertext, offset);
            if (offset != nonceAndCiphertext.length) {
                throw new IllegalStateException(
                        ""Something wrong during encryption"");
            }
            // Java 8 contains java.util.Base64
            return DatatypeConverter.printBase64Binary(nonceAndCiphertext);
        } catch (final GeneralSecurityException e) {
            throw new IllegalStateException(
                    ""Missing basic functionality from Java runtime"", e);
        }
    }

    public String decrypt(final String encrypted) {
        final byte[] nonceAndCiphertext = DatatypeConverter
                .parseBase64Binary(encrypted);
        final IvParameterSpec nonceIV = generateIVFromNonce(nonceAndCiphertext,
                0, NONCE_SIZE, this.cipher.getBlockSize());
        try {
            this.cipher.init(Cipher.DECRYPT_MODE, this.STATIC_SECRET_KEY,
                    nonceIV);
            final byte[] plaintext = this.cipher.doFinal(nonceAndCiphertext,
                    NONCE_SIZE, nonceAndCiphertext.length - NONCE_SIZE);
            // note: this may return an invalid result if the value is tampered
            // with
            // it may even contain more or less characters
            return new String(plaintext, UTF_8);",2
29717950,1,"        final byte[] nonceAndCiphertext = DatatypeConverter
                .parseBase64Binary(encrypted);
        final IvParameterSpec nonceIV = generateIVFromNonce(nonceAndCiphertext,
                0, NONCE_SIZE, this.cipher.getBlockSize());
        try {
            this.cipher.init(Cipher.DECRYPT_MODE, this.STATIC_SECRET_KEY,
                    nonceIV);
            final byte[] plaintext = this.cipher.doFinal(nonceAndCiphertext,
                    NONCE_SIZE, nonceAndCiphertext.length - NONCE_SIZE);
            // note: this may return an invalid result if the value is tampered
            // with
            // it may even contain more or less characters
            return new String(plaintext, UTF_8);",2
29744741,0,"public class sample{
 static {
    //for localhost testing only
    javax.net.ssl.HttpsURLConnection.setDefaultHostnameVerifier(
    new javax.net.ssl.HostnameVerifier(){

            @Override
        public boolean verify(String hostname,
                javax.net.ssl.SSLSession sslSession) {
            if (hostname.equals(""your_domain"")) {
                return true;
            }
            return false;
        }
    });
}
",1
29751875,1,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
29798051,0,"public class sample{
 public static String encrytData(String text) throws Exception {

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

    byte[] results = cipher.doFinal(text.getBytes());

    String result = Base64.encodeToString(results, Base64.NO_WRAP|Base64.DEFAULT);
    return result;

}


public static String decryptData(String text)throws Exception{

    byte[] encryted_bytes = Base64.decode(text, Base64.DEFAULT);

    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);

    byte[] decrypted = cipher.doFinal(encryted_bytes);
    String result = new String(decrypted);

    return result;
}
",2
29798051,0,"    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
",2
29798051,0,"    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

    byte[] results = cipher.doFinal(text.getBytes());
",2
29798051,0,"    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
    byte[] static_key = Constants.AES_KEY.getBytes();

    SecretKeySpec keySpec = new SecretKeySpec(static_key, ""AES"");
    IvParameterSpec ivSpec = new IvParameterSpec(Constants.IV_VECTOR);
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
",2
29853068,0,"public class sample{
 public void foo(){
// generate a key pair
KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"", ""BC"");
keyPairGenerator.initialize(4096, new SecureRandom());
KeyPair keyPair = keyPairGenerator.generateKeyPair();

// build a certificate generator
X509V3CertificateGenerator certGen = new X509V3CertificateGenerator();
X500Principal dnName = new X500Principal(""cn=example"");

// add some options
certGen.setSerialNumber(BigInteger.valueOf(System.currentTimeMillis()));
certGen.setSubjectDN(new X509Name(""dc=name""));
certGen.setIssuerDN(dnName); // use the same
// yesterday
certGen.setNotBefore(new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000));
// in 2 years
certGen.setNotAfter(new Date(System.currentTimeMillis() + 2 * 365 * 24 * 60 * 60 * 1000));
certGen.setPublicKey(keyPair.getPublic());
certGen.setSignatureAlgorithm(""SHA256WithRSAEncryption"");
certGen.addExtension(X509Extensions.ExtendedKeyUsage, true, new ExtendedKeyUsage(KeyPurposeId.id_kp_timeStamping));

// finally, sign the certificate with the private key of the same KeyPair
X509Certificate cert = certGen.generate(keyPair.getPrivate(), ""BC"");

}",3
29857305,0,"    public class Demo {

        public static final String PRIVATE_KEY=""/home/user/private.der"";
        public static final String PUBLIC_KEY=""/home/user/public.der"";

        public static void main(String[] args) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
            //get the private key
            File file = new File(PRIVATE_KEY);
            FileInputStream fis = new FileInputStream(file);
            DataInputStream dis = new DataInputStream(fis);

            byte[] keyBytes = new byte[(int) file.length()];
            dis.readFully(keyBytes);
            dis.close();

            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory kf = KeyFactory.getInstance(""RSA"");
            RSAPrivateKey privKey = (RSAPrivateKey) kf.generatePrivate(spec);
            System.out.println(""Exponent :"" + privKey.getPrivateExponent());
            System.out.println(""Modulus"" + privKey.getModulus());

            //get the public key
            File file1 = new File(PUBLIC_KEY);
            FileInputStream fis1 = new FileInputStream(file1);
            DataInputStream dis1 = new DataInputStream(fis1);
            byte[] keyBytes1 = new byte[(int) file1.length()];
            dis1.readFully(keyBytes1);
            dis1.close();

            X509EncodedKeySpec spec1 = new X509EncodedKeySpec(keyBytes1);
            KeyFactory kf1 = KeyFactory.getInstance(""RSA"");
            RSAPublicKey pubKey = (RSAPublicKey) kf1.generatePublic(spec1);

            System.out.println(""Exponent :"" + pubKey.getPublicExponent());
            System.out.println(""Modulus"" + pubKey.getModulus());
        }
    }",3
29857305,0,"            File file = new File(PRIVATE_KEY);
            FileInputStream fis = new FileInputStream(file);
            DataInputStream dis = new DataInputStream(fis);

            byte[] keyBytes = new byte[(int) file.length()];
            dis.readFully(keyBytes);
            dis.close();

            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory kf = KeyFactory.getInstance(""RSA"");
            RSAPrivateKey privKey = (RSAPrivateKey) kf.generatePrivate(spec);
            System.out.println(""Exponent :"" + privKey.getPrivateExponent());
            System.out.println(""Modulus"" + privKey.getModulus());

            //get the public key",3
29857305,0,"            File file1 = new File(PUBLIC_KEY);
            FileInputStream fis1 = new FileInputStream(file1);
            DataInputStream dis1 = new DataInputStream(fis1);
            byte[] keyBytes1 = new byte[(int) file1.length()];
            dis1.readFully(keyBytes1);
            dis1.close();

            X509EncodedKeySpec spec1 = new X509EncodedKeySpec(keyBytes1);
            KeyFactory kf1 = KeyFactory.getInstance(""RSA"");
            RSAPublicKey pubKey = (RSAPublicKey) kf1.generatePublic(spec1);

            System.out.println(""Exponent :"" + pubKey.getPublicExponent());
            System.out.println(""Modulus"" + pubKey.getModulus());",3
29875540,3,"    protected ClientConnectionManager createClientConnectionManager() {
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory
                .getSocketFactory(), 80));
        // Register for port 443 our SSLSocketFactory with our keystore
        // to the ConnectionManager
        registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
        return new SingleClientConnManager(getParams(), registry);
    }

    private SSLSocketFactory newSslSocketFactory() {
        try {
            // Get an instance of the Bouncy Castle KeyStore format
            KeyStore trusted = KeyStore.getInstance(""BKS"");
            // Get the raw resource, which contains the keystore with
            // your trusted certificates (root and any intermediate certs)
            InputStream in = context.getResources().openRawResource(
                    R.raw.mykeystore);
            try {
                // Initialize the keystore with the provided trusted
                // certificates
                // Also provide the password of the keystore
                trusted.load(in, ""mysecret"".toCharArray());
            } finally {
                in.close();
            }
            // Pass the keystore to the SSLSocketFactory. The factory is
            // responsible
            // for the verification of the server certificate.",1
29875540,3,"            KeyStore trusted = KeyStore.getInstance(""BKS"");
            // Get the raw resource, which contains the keystore with
            // your trusted certificates (root and any intermediate certs)
            InputStream in = context.getResources().openRawResource(
                    R.raw.mykeystore);
            try {
                // Initialize the keystore with the provided trusted
                // certificates
                // Also provide the password of the keystore
                trusted.load(in, ""mysecret"".toCharArray());
            } finally {
                in.close();
            }
            // Pass the keystore to the SSLSocketFactory. The factory is
            // responsible
            // for the verification of the server certificate.",1
29875540,4,"public class sample{
 public void foo(){
String keyStorePath = ""absolute path to your JKS keystore file"";
String keyStorePass = ""keystore password"";

System.setProperty(""javax.net.ssl.keyStore"", keyStorePath);
System.setProperty(""javax.net.ssl.keyStorePassword"", keyStorePass);

SSLServerSocketFactory sslserversocketfactory = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();
SSLServerSocket serverSocket = (SSLServerSocket) sslserversocketfactory.createServerSocket(port_number);

while (true) {
    new ClientThread((SSLSocket) serverSocket.accept()).start();
}

}",-1
29893607,1,"        KeyParameter keyParam = new KeyParameter(Convert.FromBase64String(keyString));
        ParametersWithIV keyParamWithIV = new ParametersWithIV(keyParam, iv, 0, 16);

        // Encrypt
        cipher.Init(true, keyParamWithIV);
        byte[] outputBytes = new byte[cipher.GetOutputSize(inputBytes.Length)];
        int length = cipher.ProcessBytes(inputBytes, outputBytes, 0);
        cipher.DoFinal(outputBytes, length); //Do the final block",2
29946540,0,"public NoSSLv3SocketFactory(SSLSocketFactory delegate) {
    this.delegate = delegate;
}

@Override
public String[] getDefaultCipherSuites() {
    return delegate.getDefaultCipherSuites();
}

@Override
public String[] getSupportedCipherSuites() {
    return delegate.getSupportedCipherSuites();
}

private Socket makeSocketSafe(Socket socket) {
    if (socket instanceof SSLSocket) {
        socket = new NoSSLv3SSLSocket((SSLSocket) socket);
    }
    return socket;
}

@Override
public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}

private class NoSSLv3SSLSocket extends DelegateSSLSocket {

    private NoSSLv3SSLSocket(SSLSocket delegate) {
        super(delegate);

    }

    @Override
    public void setEnabledProtocols(String[] protocols) {
        if (protocols != null && protocols.length == 1 && ""SSLv3"".equals(protocols[0])) {

            List<String> enabledProtocols = new ArrayList<String>(Arrays.asList(delegate.getEnabledProtocols()));
            if (enabledProtocols.size() > 1) {
                enabledProtocols.remove(""SSLv3"");
                System.out.println(""Removed SSLv3 from enabled protocols"");
            } else {
                System.out.println(""SSL stuck with protocol available for "" + String.valueOf(enabledProtocols));
            }
            protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);
        }
",1
29946540,0,"private Socket makeSocketSafe(Socket socket) {
    if (socket instanceof SSLSocket) {
        socket = new NoSSLv3SSLSocket((SSLSocket) socket);
    }
    return socket;
}

@Override
public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}
",1
29946540,0,"public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}
",1
29946540,0,"public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override",1
29949727,0,"   TrustManagerFactory tmf = TrustManagerFactory
     .getInstance(TrustManagerFactory.getDefaultAlgorithm());
   // Using null here initialises the TMF with the default trust store.
   tmf.init((KeyStore) null);

   // Get hold of the default trust manager
   X509TrustManager defaultTm = null;
   for (TrustManager tm : tmf.getTrustManagers()) {
    if (tm instanceof X509TrustManager) {
     defaultTm = (X509TrustManager) tm;
     break;
    }
   }
   //

   
",1
30001780,0,"public class sample{
 public void foo(){
try
{
    //paste Your package name at the first parameter
    PackageInfo info = getPackageManager().getPackageInfo(""PUT_YOUR_PACKAGE_NAME_HERE"",
            PackageManager.GET_SIGNATURES);
    for (android.content.pm.Signature signature : info.signatures)
    {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String sign = Base64.encodeToString(md.digest(), Base64.DEFAULT);
        Log.e(""MY KEY HASH:"", sign);
        Toast.makeText(getApplicationContext(), sign, Toast.LENGTH_LONG).show();
    }
}
catch (PackageManager.NameNotFoundException e)
{
}
catch (NoSuchAlgorithmException e)
{
}

}",4
30001780,0,"    for (android.content.pm.Signature signature : info.signatures)
    {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String sign = Base64.encodeToString(md.digest(), Base64.DEFAULT);
        Log.e(""MY KEY HASH:"", sign);
        Toast.makeText(getApplicationContext(), sign, Toast.LENGTH_LONG).show();
    }",4
30068455,2,"        IvParameterSpec ivSpec = new IvParameterSpec(rawIV);
        MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
        digest.update(keyString.getBytes());
        byte[] key = new byte[16];
        System.arraycopy(digest.digest(), 0, key, 0, key.length);
        SecretKeySpec keySpec = new SecretKeySpec(key, ""AES"");
        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec); //////////////////////////////This is the error line

        // Decrypt the data..",4
30092400,2,"        Key key = generateKey();
        Cipher c = Cipher.getInstance(ALGO);
        c.init(Cipher.ENCRYPT_MODE, key);
        byte[] encVal = c.doFinal(Data.getBytes());",2
30210458,0,"        public static String getToken() {
            try {
                LOG.info(""About to Generate Token in getToken()"");
                String token;
                // generate a random number
                String randomNum = Integer.toString(prng.nextInt());
                // get its digest
                MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
                byte[] result = sha.digest(randomNum.getBytes());
                token = hexEncode(result);
                LOG.info(""Token in getToken():   "" + token);
                return token;
            } catch (NoSuchAlgorithmException ex) {
                return null;
            }
        }
        /**
         * @param aInput
         * @return
         */
        private static String hexEncode(byte[] aInput) {
            StringBuilder result = new StringBuilder();
            char[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
                    'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };
            for (byte b : aInput) {
                result.append(digits[(b & 0xf0) >> 4]);
                result.append(digits[b & 0x0f]);
            }
            return result.toString();
        }",4
30212011,0,"    public static String getToken() {
        try {
            LOG.info(""About to Generate Token in getToken()"");
            String token;
            // generate a random number
            String randomNum = Integer.toString(prng.nextInt());
            // get its digest
            MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
            byte[] result = sha.digest(randomNum.getBytes());
            token = hexEncode(result);
            LOG.info(""Token in getToken():   "" + token);
            return token;
        } catch (NoSuchAlgorithmException ex) {
            return null;
        }
    }
    /**
     * @param aInput
     * @return
     */
    private static String hexEncode(byte[] aInput) {
        StringBuilder result = new StringBuilder();
        char[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h',
                'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z' };
        for (byte b : aInput) {
            result.append(digits[(b & 0xf0) >> 4]);
            result.append(digits[b & 0x0f]);
        }
        return result.toString();
    }",4
30302235,0,"public NoSSLv3SocketFactory(SSLSocketFactory delegate) {
    this.delegate = delegate;
}

@Override
public String[] getDefaultCipherSuites() {
    return delegate.getDefaultCipherSuites();
}

@Override
public String[] getSupportedCipherSuites() {
    return delegate.getSupportedCipherSuites();
}

private Socket makeSocketSafe(Socket socket) {
    if (socket instanceof SSLSocket) {
        socket = new NoSSLv3SSLSocket((SSLSocket) socket);
    }
    return socket;
}

@Override
public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}

private class NoSSLv3SSLSocket extends DelegateSSLSocket {

    private NoSSLv3SSLSocket(SSLSocket delegate) {
        super(delegate);

    }

    @Override
    public void setEnabledProtocols(String[] protocols) {
        if (protocols != null && protocols.length == 1 && ""SSLv3"".equals(protocols[0])) {

            List<String> enabledProtocols = new ArrayList<String>(Arrays.asList(delegate.getEnabledProtocols()));
            if (enabledProtocols.size() > 1) {
                enabledProtocols.remove(""SSLv3"");
                System.out.println(""Removed SSLv3 from enabled protocols"");
            } else {
                System.out.println(""SSL stuck with protocol available for "" + String.valueOf(enabledProtocols));
            }
            protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);
        }
",1
30302235,0,"private Socket makeSocketSafe(Socket socket) {
    if (socket instanceof SSLSocket) {
        socket = new NoSSLv3SSLSocket((SSLSocket) socket);
    }
    return socket;
}

@Override
public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}
",1
30302235,0,"public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}
",1
30302235,0,"public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override",1
30346024,0,"    public SecretKeySpec getKey(String password)
            throws UnsupportedEncodingException {


        int keyLength = 128;
        byte[] keyBytes = new byte[keyLength / 8];
        // explicitly fill with zeros
        Arrays.fill(keyBytes, (byte) 0x0);

        // if password is shorter then key length, it will be zero-padded
        // to key length
        byte[] passwordBytes = password.getBytes(""UTF-8"");
        int length = passwordBytes.length < keyBytes.length ?          passwordBytes.length
                : keyBytes.length;
        System.arraycopy(passwordBytes, 0, keyBytes, 0, length);
        SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");
        return key;
    }",2
30348046,3,"        final Cipher c = Cipher.getInstance(ALGORITHM);
        c.init(Cipher.DECRYPT_MODE, key);
        final byte[] decorVal = new BASE64Decoder().decodeBuffer(encryptedValue);
        final byte[] decValue = c.doFinal(decorVal);",2
30350304,0,"    public string RsaEncryptWithPublic(string clearText, string publicKey)
    {
        var bytesToEncrypt = Encoding.UTF8.GetBytes(clearText);

        var encryptEngine = new Pkcs1Encoding(new RsaEngine());

        using (var txtreader = new StringReader(publicKey))
        {
            var keyParameter = (AsymmetricKeyParameter)new PemReader(txtreader).ReadObject();

            encryptEngine.Init(true, keyParameter);
        }

        var encrypted = Convert.ToBase64String(encryptEngine.ProcessBlock(bytesToEncrypt, 0, bytesToEncrypt.Length));
        return encrypted;

    }
",3
30350304,0,"    public string RsaDecryptWithPublic(string base64Input, string publicKey)
    {
        var bytesToDecrypt = Convert.FromBase64String(base64Input);

        var decryptEngine = new Pkcs1Encoding(new RsaEngine());

        using (var txtreader = new StringReader(publicKey))
        {
            var keyParameter = (AsymmetricKeyParameter)new PemReader(txtreader).ReadObject();

            decryptEngine.Init(false, keyParameter);
        }

        var decrypted = Encoding.UTF8.GetString(decryptEngine.ProcessBlock(bytesToDecrypt, 0, bytesToDecrypt.Length));
        return decrypted;
    }",3
30384640,1,"            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(TOKEN_KEY.getBytes(""utf-8""), ""AES""), new IvParameterSpec(iv));",2
30421813,0,"public class sample{
public void PrintInstalledCertificates( ){

    try 
    {
        KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
        if (ks != null) 
        {
            ks.load(null, null);
            Enumeration<String> aliases = ks.aliases();
            while (aliases.hasMoreElements()) 
            {
                String alias = (String) aliases.nextElement();
                java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);

                //To print System Certs only
                if(cert.getIssuerDN().getName().contains(“system”))
                {
                    System.out.println(cert.getIssuerDN().getName());
                }

                //To print User Certs only 
                if(cert.getIssuerDN().getName().contains(“user”))
                {
                    System.out.println(cert.getIssuerDN().getName());
                }

                //To print all certs
                System.out.println(cert.getIssuerDN().getName());                           
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (java.security.cert.CertificateException e) {
        e.printStackTrace();
    }               
}
",1
30421940,0,"public class sample{
public void PrintInstalledCertificates( ){

               try 
                {
                    KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
                    if (ks != null) 
                    {
                        ks.load(null, null);
                        Enumeration<String> aliases = ks.aliases();
                        while (aliases.hasMoreElements()) 
                        {
                            String alias = (String) aliases.nextElement();
                            java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);
                                        //To print System Certs only
                                        if(cert.getIssuerDN().getName().contains(“system”)){
                                         System.out.println(cert.getIssuerDN().getName());
                                        }

                                        //To print User Certs only 
                                        if(cert.getIssuerDN().getName().contains(“user”)){
                                         System.out.println(cert.getIssuerDN().getName());
                                        }

                                        //To print all certs
                            System.out.println(cert.getIssuerDN().getName());                           
                        }
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                } catch (KeyStoreException e) {
                    e.printStackTrace();
                } catch (NoSuchAlgorithmException e) {
                    e.printStackTrace();
                } catch (java.security.cert.CertificateException e) {
                    e.printStackTrace();
                }               

     }
",1
30431207,0,"public class SimpleCrypto {

    private String charsetName = ""UTF8"";
    private String algorithm = ""DES"";
    private int base64Mode = Base64.DEFAULT;

    public String getCharsetName() {
        return charsetName;
    }

    public void setCharsetName(String charsetName) {
        this.charsetName = charsetName;
    }

    public String getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(String algorithm) {
        this.algorithm = algorithm;
    }

    public int getBase64Mode() {
        return base64Mode;
    }

    public void setBase64Mode(int base64Mode) {
        this.base64Mode = base64Mode;
    }

    public String encrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            byte[] dataBytes = data.getBytes(charsetName);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            return Base64.encodeToString(cipher.doFinal(dataBytes), base64Mode);
        } catch (Exception e) {
            return null;
        }
    }

    public String decrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            byte[] dataBytes = Base64.decode(data, base64Mode);
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));
            return new String(dataBytesDecrypted);
        } catch (Exception e) {
            return null;
        }
    }
}",2
30432155,0,"public class SimpleCrypto {

    private String charsetName = ""UTF8"";
    private String algorithm = ""DES"";
    private int base64Mode = Base64.DEFAULT;

    public String getCharsetName() {
        return charsetName;
    }

    public void setCharsetName(String charsetName) {
        this.charsetName = charsetName;
    }

    public String getAlgorithm() {
        return algorithm;
    }

    public void setAlgorithm(String algorithm) {
        this.algorithm = algorithm;
    }

    public int getBase64Mode() {
        return base64Mode;
    }

    public void setBase64Mode(int base64Mode) {
        this.base64Mode = base64Mode;
    }

    public String encrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            byte[] dataBytes = data.getBytes(charsetName);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            return Base64.encodeToString(cipher.doFinal(dataBytes), base64Mode);
        } catch (Exception e) {
            return null;
        }
    }

    public String decrypt(String key, String data) {
        if (key == null || data == null)
            return null;
        try {
            byte[] dataBytes = Base64.decode(data, base64Mode);
            DESKeySpec desKeySpec = new DESKeySpec(key.getBytes(charsetName));
            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(algorithm);
            SecretKey secretKey = secretKeyFactory.generateSecret(desKeySpec);
            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            byte[] dataBytesDecrypted = (cipher.doFinal(dataBytes));
            return new String(dataBytesDecrypted);
        } catch (Exception e) {
            return null;
        }
    }
}",2
30457076,1,"public class sample{
 public void foo(){
CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
gen.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(......));
gen.addCertificates(certs);

}",13
30513529,1,"static byte[] encrypt(TweakableBlockCipherParameters params, byte[] plaintext) throws Exception {
    return encryptOrDecrypt(true, params, plaintext);
}

static byte[] decrypt(TweakableBlockCipherParameters params, byte[] ciphertext) throws Exception {
    return encryptOrDecrypt(false, params, ciphertext);
}
",2
30524987,0,"static byte[] encrypt(SecretKey key, byte[] plaintext) throws Exception {
    return encryptOrDecrypt(true, key, plaintext);
}

static byte[] decrypt(SecretKey key, byte[] ciphertext) throws Exception {
    return encryptOrDecrypt(false, key, ciphertext);
}
",2
30529229,0,"  Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
  IvParameterSpec ivspec = new IvParameterSpec(iv);
  cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, ""AES""), ivspec);
  byte[] result = cipher.doFinal(data);",2
30550481,0,"        Cipher cipher = Cipher.getInstance(""RSA"");
        cipher.init(Cipher.DECRYPT_MODE, myPrivateKey); 
        byte[] decoded = Base64.decodeBase64(encCardNo);        
        byte[] cipherData = cipher.doFinal(decoded);",3
30610023,0,"                byte[] trimbuf = new byte[nread];

                for (int i = 0; i < nread; i++) {
                    trimbuf[i] = inbuf[i];
                }

                // encrypt the buffer using the cipher obtained previosly
                byte[] tmpBuf = mEcipher.update(trimbuf);

                // I don't think this should happen, but just in case..
                if (tmpBuf != null) {
                    outputStream.write(tmpBuf);
                }",-1
30647564,0,"    byte[] out = new byte[b.getOutputSize(tData.length)];

    int len = b.processBytes(tData, 0, tData.length, out, 0);

    len += b.doFinal(out, len);
",2
30660244,0,"        byte[] salt = new byte[SALT_SIZE];
        SecureRandom saltSecureRandom = SecureRandom.getInstance(PRNG_ALGORITHM);
        saltSecureRandom.nextBytes(salt);

        //Create cipher key & use to initialize cipher
        byte[] keyBytes = PBEKeyFactory.getKey(PASSWORD, salt, ITERATIONS, KEY_LENGTH);
        SecretKeySpec secret = new SecretKeySpec(keyBytes, ALGORITHM);
",5
30660244,0,"        byte[] keyBytes = PBEKeyFactory.getKey(PASSWORD, salt, ITERATIONS, KEY_LENGTH);
        SecretKeySpec secret = new SecretKeySpec(keyBytes, ALGORITHM);

        Cipher cipher = Cipher.getInstance(TRANSFORMATION);
        cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(new byte[16]));

        //Create byte array of encrypted data",2
30660244,0,"        byte[] macsalt = new byte[SALT_SIZE];
        SecureRandom macsaltSecureRandom = SecureRandom.getInstance(PRNG_ALGORITHM);
        macsaltSecureRandom.nextBytes(macsalt);

        //PBEKeyFactory.getKey(password, salt, iterations, keylength)    
        //returns a byte array representation of a SecretKey.
        //Used a SecretKeyFactory instead of a KeyGenerator to make key.
        //SecretKeyFactory gives back the same key given the same specifications
        //whereas KeyGenerator gives back a new random key each time.
        byte[] macPBE = PBEKeyFactory.getKey(PASSWORD, macsalt, ITERATIONS, KEY_LENGTH);

        SecretKeySpec macKey = new SecretKeySpec(macPBE, MAC_ALGORITHM);",5
30660244,0,"        byte[] macPBE = PBEKeyFactory.getKey(PASSWORD, macsalt, ITERATIONS, KEY_LENGTH);

        SecretKeySpec macKey = new SecretKeySpec(macPBE, MAC_ALGORITHM);
        Mac mac = Mac.getInstance(MAC_ALGORITHM);
        mac.init(macKey);
        byte[] macBytes = mac.doFinal(crypt);
",2
30660244,0,"            byte[] macKeyBytes = PBEKeyFactory.getKey(PASSWORD, macSalt, ITERATIONS, KEY_LENGTH);
            SecretKeySpec macKey = new SecretKeySpec(macKeyBytes, MAC_ALGORITHM);
            Mac mac = Mac.getInstance(MAC_ALGORITHM);
            mac.init(macKey);
            byte[] compMacBytes = mac.doFinal(cryptBytes);
            //Check if computed and derived MAC's are the same",2
30660244,0,"                byte[] cryptKeyBytes = PBEKeyFactory.getKey(PASSWORD, cryptSalt, ITERATIONS, KEY_LENGTH);
                SecretKeySpec cryptKey = new SecretKeySpec(cryptKeyBytes, ALGORITHM);

                //Creates cipher and reads decrypted data to array
                Cipher cipher = Cipher.getInstance(TRANSFORMATION);
                cipher.init(Cipher.DECRYPT_MODE, cryptKey, new IvParameterSpec(new byte[16]));",2
30742240,0,"        public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
            final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
            sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());
            return sslSocket;
        }

        @Override
        public Socket createSocket() throws IOException {
            final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket();
            sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());
            return sslSocket;
        }",1
30776194,2,"public class sample{
 public void foo(){
KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
keyStore.load(new FileInputStream(new File(""keystore.jks"")),
        ""secret"".toCharArray());
SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory(
        new SSLContextBuilder()
                .loadTrustMaterial(null, new TrustSelfSignedStrategy())
                .loadKeyMaterial(keyStore, ""password"".toCharArray()).build());
HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build();
ClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(
        httpClient);
RestTemplate restTemplate = new RestTemplate(requestFactory);
ResponseEntity<String> response = restTemplate.getForEntity(
        ""https://localhost:8443"", String.class);

}",1
30929175,0,"        if (privateKeyPem.indexOf(PEM_PRIVATE_START) != -1) { // PKCS#8 format
            privateKeyPem = privateKeyPem.replace(PEM_PRIVATE_START, """").replace(PEM_PRIVATE_END, """");
            privateKeyPem = privateKeyPem.replaceAll(""\\s"", """");

            byte[] pkcs8EncodedKey = Base64.getDecoder().decode(privateKeyPem);

            KeyFactory factory = KeyFactory.getInstance(""RSA"");
            return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));
",3
30929175,0,"        } else if (privateKeyPem.indexOf(PEM_RSA_PRIVATE_START) != -1) {  // PKCS#1 format

            privateKeyPem = privateKeyPem.replace(PEM_RSA_PRIVATE_START, """").replace(PEM_RSA_PRIVATE_END, """");
            privateKeyPem = privateKeyPem.replaceAll(""\\s"", """");

            DerInputStream derReader = new DerInputStream(Base64.getDecoder().decode(privateKeyPem));

            DerValue[] seq = derReader.getSequence(0);

            if (seq.length < 9) {
                throw new GeneralSecurityException(""Could not parse a PKCS1 private key."");
            }

            // skip version seq[0];
            BigInteger modulus = seq[1].getBigInteger();
            BigInteger publicExp = seq[2].getBigInteger();
            BigInteger privateExp = seq[3].getBigInteger();
            BigInteger prime1 = seq[4].getBigInteger();
            BigInteger prime2 = seq[5].getBigInteger();
            BigInteger exp1 = seq[6].getBigInteger();
            BigInteger exp2 = seq[7].getBigInteger();
            BigInteger crtCoef = seq[8].getBigInteger();

            RSAPrivateCrtKeySpec keySpec = new RSAPrivateCrtKeySpec(modulus, publicExp, privateExp, prime1, prime2, exp1, exp2, crtCoef);

            KeyFactory factory = KeyFactory.getInstance(""RSA"");

            return factory.generatePrivate(keySpec);
        }

        throw new GeneralSecurityException(""Not supported format of a private key"");",3
30934866,0,"public class sample{
 public void foo(){
PackageInfo info;
try {
    info = getPackageManager().getPackageInfo(""com.your.project.package"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }
} catch (PackageManager.NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}

}",4
30934866,0,"    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }",4
30934866,0,"    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String something = new String(Base64.encode(md.digest(), 0));
        //String something = new String(Base64.encodeBytes(md.digest()));
        Log.e(""hash key"", something);
    }
} catch (PackageManager.NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}
",4
30978219,0,"            public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
                final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
                sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());
                return sslSocket;
            }

            @Override
            public Socket createSocket() throws IOException {
                final SSLSocket sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket();
                sslSocket.setEnabledCipherSuites(sslSocket.getSupportedCipherSuites());
                return sslSocket;
            }",1
31037133,0,"public class sample{
 public void foo(){
SecureRandom r = new SecureRandom();
byte[] ivBytes = new byte[16];
r.nextBytes(ivBytes);

cipher.init(Cipher.ENCRYPT_MODE, keySpec, new IvParameterSpec(ivBytes));

}",5
31067127,0,"public class sample{
 public void foo(){
/*
 * First, create (or ask some other component for) the adequate encryptor for
 * decrypting the values in our .properties file.
*/
StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor();
encryptor.setPassword(""jasypt""); // could be got from web, env variable...

/*
 * Create our EncryptableProperties object and load it the usual way.
 */
Properties props = new EncryptableProperties(encryptor);
props.load(new FileInputStream(""/path/to/my/configuration.properties""));

/*
 * To get a non-encrypted value, we just get it with getProperty...
 */
String datasourceUsername = props.getProperty(""datasource.username"");

/*
 * ...and to get an encrypted value, we do exactly the same. Decryption will
 * be transparently performed behind the scenes.
 */ 
String datasourcePassword = props.getProperty(""datasource.password"");

// From now on, datasourcePassword equals ""reports_passwd""...

}",2
31082141,0,"        SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

        if ((localAddress != null) || (localPort > 0)) {
// we need to bind explicitly
            if (localPort < 0) {
                localPort = 0; // indicates ""any""
            }
            InetSocketAddress isa = new InetSocketAddress(localAddress,
                    localPort);
            sslsock.bind(isa);
        }
",1
31243962,1,"     MessageDigest md = MessageDigest.getInstance(""SHA-256"");
     md.update(pwd.getBytes(""UTF-8""));
     byte[] digest = md.digest();
     stmt.setString(5, new String(digest, ""UTF-8""));

     int action = stmt.executeUpdate();",4
31243962,21,"MessageDigest md = MessageDigest.getInstance(""SHA-256"");
md.update(pwd.getBytes(""UTF-8""));
byte[] digest = md.digest();
stmt.setString(5, new String(digest, ""UTF-8""));

int action = stmt.executeUpdate();
",4
31245375,0,"    SecretKey secretKey = factory.generateSecret(spec);
    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);",2
31245375,0,"    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, secret);
    byte[] ivBytes = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV();",2
31245375,0,"    SecretKey secretKey = factory.generateSecret(spec);
    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivBytes));",2
31245375,0,"    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivBytes));",2
31245375,0,"    SecretKeySpec secret = new SecretKeySpec(secretKey.getEncoded(), ""AES"");
    Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(ivBytes));",2
31288511,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
31306198,0,"    CipherInputStream cis = new CipherInputStream(bytesStream, cipher);

    int b;
    byte[] d = new byte[1024];
    while((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }
    fos.flush();
    fos.close();
    cis.close();",2
31306198,0,"    CipherInputStream cis = new CipherInputStream(bytesStream, cipher);

    int b;
    byte[] d = new byte[1024];
    while((b = cis.read(d)) != -1) {
        fos.write(d, 0, b);
    }
    fos.flush();
    fos.close();
    cis.close();",2
31310087,5,"            public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {
                return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
            }

            @Override
            public Socket createSocket() throws IOException {
                return sslContext.getSocketFactory().createSocket();
            }",1
31361403,0,"    public static byte[] encryptRSA(Key key, byte[] data) {
        byte[] cipherText = null;
        try {
            final Cipher cipher = Cipher.getInstance(RSA_ECB_PKCS1_PADDING);
            cipher.init(Cipher.ENCRYPT_MODE, key);
            cipherText = cipher.doFinal(data);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return cipherText;
    }
",3
31361403,0,"    public static byte[] decryptRSA(Key key, byte[] data) {
        byte[] decryptedText = null;
        try {
            final Cipher cipher = Cipher.getInstance(RSA_ECB_PKCS1_PADDING);
            cipher.init(Cipher.DECRYPT_MODE, key);
            decryptedText = cipher.doFinal(data);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return decryptedText;
    }
",3
31433753,0,"        byte[] keyData = new byte[keysize / Byte.SIZE];
        System.arraycopy(givenKey, 0, keyData, 0, Math.min(givenKey.length, keyData.length));
        KeyParameter keyParameter = new KeyParameter(keyData);
        BlockCipher rijndael = new RijndaelEngine(256);
        ZeroBytePadding c = new ZeroBytePadding();
        PaddedBufferedBlockCipher pbbc = new PaddedBufferedBlockCipher(rijndael, c);",2
31433753,0,"        byte[] plaintext = data.getBytes(Charset.forName(""UTF8""));
        byte[] ciphertext = new byte[pbbc.getOutputSize(plaintext.length)];
        int offset = 0;
        offset += pbbc.processBytes(plaintext, 0, plaintext.length, ciphertext, offset);
        offset += pbbc.doFinal(ciphertext, offset);",2
31436459,0,"  } finally { cert.close(); }

  // creating a KeyStore containing our trusted CAs
  String keyStoreType = KeyStore.getDefaultType();
  KeyStore keyStore = KeyStore.getInstance(keyStoreType);
  keyStore.load(null, null);
  keyStore.setCertificateEntry(""ca"", ca);

  // creating a TrustManager that trusts the CAs in our KeyStore",1
31436459,0,"  } finally { cert.close(); }

  // creating a KeyStore containing our trusted CAs
  String keyStoreType = KeyStore.getDefaultType();
  KeyStore keyStore = KeyStore.getInstance(keyStoreType);
  keyStore.load(null, null);
  keyStore.setCertificateEntry(""ca"", ca);

  // creating a TrustManager that trusts the CAs in our KeyStore
  String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
  TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
  tmf.init(keyStore);

  // creating an SSLSocketFactory that uses our TrustManager",1
31533404,0,"  KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, iterations, derivedKeyLength);
  SecretKeyFactory f = SecretKeyFactory.getInstance(algorithm);

  byte[] encryptedPassword = f.generateSecret(spec).getEncoded();
",2
31557473,4,"Store store = signedData.getCertificates(); 
SignerInformationStore signers = signedData.getSignerInfos(); 

Collection c = signers.getSigners(); 
Iterator it = c.iterator(); 

while (it.hasNext()) { 
    SignerInformation signer = (SignerInformation)it.next(); 

    Collection certCollection = store.getMatches(signer.getSID()); 
    Iterator certIt = certCollection.iterator(); 

    X509CertificateHolder certHolder = (X509CertificateHolder)certIt.next(); ",3
31646928,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
31657455,0,"KeyStore trustStore=KeyStore.getInstance(KeyStore.getDefaultType());

// If we're on an OS version prior to Ice Cream Sandwich (4.0) then use the standard way to get the system
//   trustStore -- System.getProperty() else we need to use the special name to get the trustStore KeyStore
//   instance as they changed their trustStore implementation.
if (Build.VERSION.RELEASE.compareTo(""4.0"") < 0) {
    TrustManagerFactory trustManagerFactory=TrustManagerFactory
        .getInstance(TrustManagerFactory.getDefaultAlgorithm());
    FileInputStream trustStoreStream=new FileInputStream(System.getProperty(""javax.net.ssl.trustStore""));
    trustStore.load(trustStoreStream, null);
    trustManagerFactory.init(trustStore);
    trustStoreStream.close();
} else {
    trustStore=KeyStore.getInstance(""AndroidCAStore"");
}
",1
31669137,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""Your Tag"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
31675689,1,"public class sample{
public byte[] encrypt(byte[] msg, byte[] key, byte[] iv) throws Exception {
    //prepare key
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");

    //prepare cipher
    String cipherALG = ""AES/CBC/PKCS5padding""; // use your preferred algorithm 
    Cipher cipher = Cipher.getInstance(cipherALG);
    String string = cipher.getAlgorithm();

    //as iv (Initial Vector) is only required for CBC mode
    if (string.contains(""CBC"")) {
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);      
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
    } else {
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
    }

    byte[] encMessage = cipher.doFinal(msg);        
    return encMessage;
}
",2
31675689,2,"public class sample{
public byte[] decrypt(byte[] encMsgtoDec, byte[] key, byte[] iv) throws Exception {
    //prepare key
    SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");

    //prepare cipher
    String cipherALG = ""AES/CBC/PKCS5padding""; // use your preferred algorithm 
    Cipher cipher = Cipher.getInstance(cipherALG);
    String string = cipher.getAlgorithm();

    //as iv (Initial Vector) is only required for CBC mode
    if (string.contains(""CBC"")) {
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);      
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
    } else {
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
    }

    byte[] decMsg = cipher.doFinal(encMsgtoDec);        
    return decMsg;
}
",2
31723443,0,"        KeyStore p12 = KeyStore.getInstance(""pkcs12"");
        p12.load(new FileInputStream(pathToFile), passphrase.toCharArray());
        Enumeration e = p12.aliases();",3
31742384,5,"public class MyHttpClient extends DefaultHttpClient {

    final Context context;

    public MyHttpClient(Context context) {
        this.context = context;
    }

    @Override
    protected ClientConnectionManager createClientConnectionManager() {
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        // Register for port 443 our SSLSocketFactory with our keystore
        // to the ConnectionManager
        registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
        return new SingleClientConnManager(getParams(), registry);
    }

    private SSLSocketFactory newSslSocketFactory() {
        try {
            // Trust manager / truststore
            KeyStore trustStore=KeyStore.getInstance(KeyStore.getDefaultType());

            // If we're on an OS version prior to Ice Cream Sandwich (4.0) then use the standard way to get the system
            //   trustStore -- System.getProperty() else we need to use the special name to get the trustStore KeyStore
            //   instance as they changed their trustStore implementation.
            if (Build.VERSION.RELEASE.compareTo(""4.0"") < 0) {
                TrustManagerFactory trustManagerFactory=TrustManagerFactory
                        .getInstance(TrustManagerFactory.getDefaultAlgorithm());
                FileInputStream trustStoreStream=new FileInputStream(System.getProperty(""javax.net.ssl.trustStore""));
                trustStore.load(trustStoreStream, null);
                trustManagerFactory.init(trustStore);
                trustStoreStream.close();
            } else {
                trustStore=KeyStore.getInstance(""AndroidCAStore"");
            }

            InputStream certificateStream = context.getResources().openRawResource(R.raw.mykst);
            KeyStore keyStore=KeyStore.getInstance(""BKS"");
            try {
                keyStore.load(certificateStream, ""mypassword"".toCharArray());
                Enumeration<String> aliases=keyStore.aliases();
                while (aliases.hasMoreElements()) {
                    String alias=aliases.nextElement();
                    if (keyStore.getCertificate(alias).getType().equals(""X.509"")) {
                        X509Certificate cert=(X509Certificate)keyStore.getCertificate(alias);
                        if (new Date().after(cert.getNotAfter())) {
                            // This certificate has expired
                            return null;
                        }
                    }
                }
            } catch (IOException ioe) {
                // This occurs when there is an incorrect password for the certificate
                return null;
            } finally {
                certificateStream.close();
            }

            KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            keyManagerFactory.init(keyStore, ""mypassword"".toCharArray());

            return new SSLSocketFactory(keyStore, ""mypassword"", trustStore);
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    }
}",1
31742384,5,"            KeyStore trustStore=KeyStore.getInstance(KeyStore.getDefaultType());

            // If we're on an OS version prior to Ice Cream Sandwich (4.0) then use the standard way to get the system
            //   trustStore -- System.getProperty() else we need to use the special name to get the trustStore KeyStore
            //   instance as they changed their trustStore implementation.
            if (Build.VERSION.RELEASE.compareTo(""4.0"") < 0) {
                TrustManagerFactory trustManagerFactory=TrustManagerFactory
                        .getInstance(TrustManagerFactory.getDefaultAlgorithm());
                FileInputStream trustStoreStream=new FileInputStream(System.getProperty(""javax.net.ssl.trustStore""));
                trustStore.load(trustStoreStream, null);
                trustManagerFactory.init(trustStore);
                trustStoreStream.close();
            } else {
                trustStore=KeyStore.getInstance(""AndroidCAStore"");
            }
",1
31749867,5,"public class MyHttpClient extends DefaultHttpClient {

    final Context context;

    public MyHttpClient(Context context) {
        this.context = context;
    }

    @Override
    protected ClientConnectionManager createClientConnectionManager() {
        SchemeRegistry registry = new SchemeRegistry();
        registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));
        // Register for port 443 our SSLSocketFactory with our keystore
        // to the ConnectionManager
        registry.register(new Scheme(""https"", newSslSocketFactory(), 443));
        return new SingleClientConnManager(getParams(), registry);
    }

    private SSLSocketFactory newSslSocketFactory() {
        try {
            // Trust manager / truststore
            KeyStore trustStore=KeyStore.getInstance(KeyStore.getDefaultType());

            // If we're on an OS version prior to Ice Cream Sandwich (4.0) then use the standard way to get the system
            //   trustStore -- System.getProperty() else we need to use the special name to get the trustStore KeyStore
            //   instance as they changed their trustStore implementation.
            if (Build.VERSION.RELEASE.compareTo(""4.0"") < 0) {
                TrustManagerFactory trustManagerFactory=TrustManagerFactory
                        .getInstance(TrustManagerFactory.getDefaultAlgorithm());
                FileInputStream trustStoreStream=new FileInputStream(System.getProperty(""javax.net.ssl.trustStore""));
                trustStore.load(trustStoreStream, null);
                trustManagerFactory.init(trustStore);
                trustStoreStream.close();
            } else {
                trustStore=KeyStore.getInstance(""AndroidCAStore"");
            }

            InputStream certificateStream = context.getResources().openRawResource(R.raw.mykst);
            KeyStore keyStore=KeyStore.getInstance(""BKS"");
            try {
                keyStore.load(certificateStream, ""mypassword"".toCharArray());
                Enumeration<String> aliases=keyStore.aliases();
                while (aliases.hasMoreElements()) {
                    String alias=aliases.nextElement();
                    if (keyStore.getCertificate(alias).getType().equals(""X.509"")) {
                        X509Certificate cert=(X509Certificate)keyStore.getCertificate(alias);
                        if (new Date().after(cert.getNotAfter())) {
                            // This certificate has expired
                            return null;
                        }
                    }
                }
            } catch (IOException ioe) {
                // This occurs when there is an incorrect password for the certificate
                return null;
            } finally {
                certificateStream.close();
            }

            KeyManagerFactory keyManagerFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
            keyManagerFactory.init(keyStore, ""mypassword"".toCharArray());

            return new SSLSocketFactory(keyStore, ""mypassword"", trustStore);
        } catch (Exception e) {
            throw new AssertionError(e);
        }
    }
}",1
31749867,5,"            KeyStore trustStore=KeyStore.getInstance(KeyStore.getDefaultType());

            // If we're on an OS version prior to Ice Cream Sandwich (4.0) then use the standard way to get the system
            //   trustStore -- System.getProperty() else we need to use the special name to get the trustStore KeyStore
            //   instance as they changed their trustStore implementation.
            if (Build.VERSION.RELEASE.compareTo(""4.0"") < 0) {
                TrustManagerFactory trustManagerFactory=TrustManagerFactory
                        .getInstance(TrustManagerFactory.getDefaultAlgorithm());
                FileInputStream trustStoreStream=new FileInputStream(System.getProperty(""javax.net.ssl.trustStore""));
                trustStore.load(trustStoreStream, null);
                trustManagerFactory.init(trustStore);
                trustStoreStream.close();
            } else {
                trustStore=KeyStore.getInstance(""AndroidCAStore"");
            }
",1
31785730,1,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
31858690,0,"public class sample{
 public void foo(){
RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) privateKey;
return rsaPublicKey.getModulus().equals( rsaPrivateKey.getModulus() )
    && BigInteger.valueOf( 2 ).modPow( rsaPublicKey.getPublicExponent()
    .multiply( rsaPrivateKey.getPrivateExponent() ).subtract( BigInteger.ONE ),
    rsaPublicKey.getModulus() ).equals( BigInteger.ONE );

}",3
32029900,2,"        final org.bouncycastle.asn1.pkcs.RSAPublicKey pkcs1PublicKey;
        try {
            pkcs1PublicKey = org.bouncycastle.asn1.pkcs.RSAPublicKey
                    .getInstance(pemContent);
        } catch (final Exception e) {
            throw new IllegalArgumentException(
                    ""Could not parse BER PKCS#1 public key structure"", e);
        }

        // --- convert to JCE RSAPublicKey
        final RSAPublicKeySpec spec = new RSAPublicKeySpec(
                pkcs1PublicKey.getModulus(), pkcs1PublicKey.getPublicExponent());
        final KeyFactory rsaKeyFact;
        try {
            rsaKeyFact = KeyFactory.getInstance(""RSA"");
        } catch (final NoSuchAlgorithmException e) {
            throw new IllegalStateException(""RSA KeyFactory should be available"", e);
        }
        try {
            return (RSAPublicKey) rsaKeyFact.generatePublic(spec);
        } catch (InvalidKeySpecException e) {
            throw new IllegalArgumentException(
                    ""Invalid RSA public key, modulus and/or exponent invalid"", e);
        }",3
32038878,0,"public class sample{
 public void foo(){
MessageDigest md = MessageDigest.getInstance(""SHA-256"");
String secret = ""secret"";
md.update(secret.getBytes(""UTF-8""));
byte[] key = md.digest();

}",4
32156143,4,"public class sample{
HostnameVerifier hostnameVerifier = new HostnameVerifier() {
    @Override
    public boolean verify(String hostname, SSLSession session) {
        HostnameVerifier hv =
            HttpsURLConnection.getDefaultHostnameVerifier();
        return hv.verify(""localhost"", session);
    }
};
",1
32166210,2,"Cipher oaepFromInit = Cipher.getInstance(""RSA/ECB/OAEPPadding"");
OAEPParameterSpec oaepParams = new OAEPParameterSpec(""SHA-256"", ""MGF1"", new MGF1ParameterSpec(""SHA-1""), PSpecified.DEFAULT);
oaepFromInit.init(Cipher.DECRYPT_MODE, privkey, oaepParams);
byte[] pt = oaepFromInit.doFinal(ct);
System.out.println(new String(pt, StandardCharsets.UTF_8));
",3
32167799,3,"Cipher oaepFromInit = Cipher.getInstance(""RSA/ECB/OAEPPadding"");
OAEPParameterSpec oaepParams = new OAEPParameterSpec(""SHA-256"", ""MGF1"", new MGF1ParameterSpec(""SHA-1""), PSpecified.DEFAULT);
oaepFromInit.init(Cipher.DECRYPT_MODE, privkey, oaepParams);
byte[] pt = oaepFromInit.doFinal(ct);
System.out.println(new String(pt, StandardCharsets.UTF_8));
",3
32174717,0,"                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    String sign = Base64.encodeToString(md.digest(), Base64.DEFAULT);
                    Log.e(""MY KEY HASH:"", sign);
                    //textInstructionsOrLink = (TextView)findViewById(R.id.textstring);
                    //textInstructionsOrLink.setText(sign);
                    Toast.makeText(getApplicationContext(), sign, Toast.LENGTH_LONG).show();
                }",4
32182348,0,"    byte[] byteData = md.digest();
    StringBuilder sb = new StringBuilder();

    for (byte currByte : byteData)
        sb.append(Integer.toString((currByte & 0xff) + 0x100, 16).substring(1));
",4
32182348,0,"    byte[] byteData = md.digest();
    StringBuilder sb = new StringBuilder();

    for (byte currByte : byteData)
        sb.append(Integer.toString((currByte & 0xff) + 0x100, 16).substring(1));

    return sb.toString();",4
32219177,0,"        InputStream caInput = getResources().openRawResource(keystoreResId);

        // creating a KeyStore containing trusted CAs

        if (keyStoreType == null || keyStoreType.length() == 0) {
            keyStoreType = KeyStore.getDefaultType();
        }
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
",2
32311317,3,"  public static String getSignatureHash(Context ctxt, String packageName)
                                                                         throws NameNotFoundException,
                                                                         NoSuchAlgorithmException {
    MessageDigest md=MessageDigest.getInstance(""SHA-256"");
    Signature sig=
        ctxt.getPackageManager()
            .getPackageInfo(packageName, PackageManager.GET_SIGNATURES).signatures[0];

    return(toHexStringWithColons(md.digest(sig.toByteArray())));
  }

  // based on https://stackoverflow.com/a/2197650/115145

  public static String toHexStringWithColons(byte[] bytes) {
    char[] hexArray=
        { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B',
            'C', 'D', 'E', 'F' };
    char[] hexChars=new char[(bytes.length * 3) - 1];
    int v;

    for (int j=0; j < bytes.length; j++) {
      v=bytes[j] & 0xFF;
      hexChars[j * 3]=hexArray[v / 16];
      hexChars[j * 3 + 1]=hexArray[v % 16];

      if (j < bytes.length - 1) {
        hexChars[j * 3 + 2]=':';
      }
    }

    return new String(hexChars);
  }",4
32311317,3,"  public static String getSignatureHash(Context ctxt, String packageName)
                                                                         throws NameNotFoundException,
                                                                         NoSuchAlgorithmException {
    MessageDigest md=MessageDigest.getInstance(""SHA-256"");
    Signature sig=
        ctxt.getPackageManager()
            .getPackageInfo(packageName, PackageManager.GET_SIGNATURES).signatures[0];

    return(toHexStringWithColons(md.digest(sig.toByteArray())));",4
32312413,3,"public class sample{
HostnameVerifier hostnameVerifier = new HostnameVerifier() {
    @Override
    public boolean verify(String hostname, SSLSession session) {
        HostnameVerifier hv =
            HttpsURLConnection.getDefaultHostnameVerifier();
        return hv.verify(""localhost"", session);
    }
};
",1
32327809,0,"      public Socket createSocket(Socket socket, String host, int port,
                  boolean autoClose) throws IOException, UnknownHostException {
            return sslContext.getSocketFactory().createSocket(socket, host, port,
                        autoClose);
      }

      @Override
      public Socket createSocket() throws IOException {
            return sslContext.getSocketFactory().createSocket();
      }",1
32408174,3,"public class sample{
HostnameVerifier hostnameVerifier = new HostnameVerifier() {
    @Override
    public boolean verify(String hostname, SSLSession session) {
        HostnameVerifier hv =
            HttpsURLConnection.getDefaultHostnameVerifier();
        return hv.verify(""localhost"", session);
    }
};
",1
32421771,0,"private static String hmacSha1(String value, String key)
            throws UnsupportedEncodingException, NoSuchAlgorithmException,
            InvalidKeyException {
        String type = ""HmacSHA1"";
        SecretKeySpec secret = new SecretKeySpec(key.getBytes(), type);
        Mac mac = Mac.getInstance(type);
        mac.init(secret);
        byte[] bytes = mac.doFinal(value.getBytes());
        return bytesToHex(bytes);
    }

    private final static char[] hexArray = ""0123456789abcdef"".toCharArray();

    private static String bytesToHex(byte[] bytes) {
        char[] hexChars = new char[bytes.length * 2];
        int v;
        for (int j = 0; j < bytes.length; j++) {
            v = bytes[j] & 0xFF;
            hexChars[j * 2] = hexArray[v >>> 4];
            hexChars[j * 2 + 1] = hexArray[v & 0x0F];
        }
        return new String(hexChars);
    }
",4
32421771,0,"        SecretKeySpec secret = new SecretKeySpec(key.getBytes(), type);
        Mac mac = Mac.getInstance(type);
        mac.init(secret);
        byte[] bytes = mac.doFinal(value.getBytes());",4
32465585,0,"var rawData = atob(encrypted_text);
var iv = rawData.substring(0,16);
var crypttext = rawData.substring(16);
var plaintextArray = CryptoJS.AES.decrypt(
  { ciphertext: CryptoJS.enc.Latin1.parse(crypttext) },
  CryptoJS.enc.Hex.parse(password),
  { iv: CryptoJS.enc.Latin1.parse(iv) }
);",2
32484787,5,"        InputStream caInput = getResources().openRawResource(keystoreResId);

        // creating a KeyStore containing trusted CAs

        if (keyStoreType == null || keyStoreType.length() == 0) {
            keyStoreType = KeyStore.getDefaultType();
        }
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
",2
32499836,0,"        tmf = TrustManagerFactory.getInstance(TrustManagerFactory
                .getDefaultAlgorithm());

        tmf.init((KeyStore) null);

        X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];",1
32499836,1,"    try 
    {
        KeyStore ks = KeyStore.getInstance(""AndroidCAStore"");
        if (ks != null) 
        {
            ks.load(null, null);
            Enumeration aliases = ks.aliases();
            while (aliases.hasMoreElements()) 
            {
                String alias = (String) aliases.nextElement();
                java.security.cert.X509Certificate cert = (java.security.cert.X509Certificate) ks.getCertificate(alias);

                if (cert.getIssuerDN().getName().contains(""MyCert"")) {
                    isCertExist = true;
                    break;
                }
            }
        }
    } catch (IOException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (java.security.cert.CertificateException e) {
        e.printStackTrace();
    }
",1
32565922,0,"        final byte[] salt = Arrays.copyOfRange(inBytes, magic.length,
                magic.length + 8);

        final byte[] passAndSalt = concat(pass, salt);

        byte[] hash = new byte[0];
        byte[] keyAndIv = new byte[0];",2
32587565,1,"        byte[] array = md.digest(md5.getBytes());
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < array.length; ++i) {
            sb.append(Integer.toHexString((array[i] & 0xFF) | 0x100).substring(1,3));
        }
        return sb.toString();",4
32605878,1,"   public Socket createSocket(String host, int port) throws IOException
   {
      return acceptOnlyTLS12(base.createSocket(host, port));
   }
   @Override
   public Socket createSocket(String host, int port, InetAddress localAddress, int localPort) throws IOException
   {
      return acceptOnlyTLS12(base.createSocket(host, port, localAddress, localPort));
   }
   @Override",1
32616019,0,"    byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
    int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
    ctLength += cipher.doFinal(cipherText, ctLength);
",2
32627098,12,"        if (algorithm == null) {
            algorithm = KeyManagerFactory.getDefaultAlgorithm(); // ""SunX509""
            log.debug(""Using default key store algorithm "" + algorithm);
        }
        KeyManagerFactory kmf = null;
        KeyStore keyStore = loadStore(storeIn, storePwd, storeType);
        kmf = KeyManagerFactory.getInstance(algorithm);",1
32627098,12,"        if (algorithm == null) {
            algorithm = TrustManagerFactory.getDefaultAlgorithm();
            log.debug(""Using default trust store algorithm "" + algorithm);
        }
        TrustManagerFactory tmf = null;
        KeyStore trustStore = loadStore(storeIn, storePwd, storeType);
        tmf = TrustManagerFactory.getInstance(algorithm);",1
32650252,1,"public class sample{
 public void foo(){

SSLSocketFactory sf = new SSLSocketFactoryImpl();
SSLSocket s = (SSLSocket) sf.createSocket();
System.out.println( Arrays.toString( s.getSupportedProtocols() )) ;

}",1
32674422,0,"    private HostnameVerifier getHostnameVerifier() {
        return new HostnameVerifier() {
            @Override
            public boolean verify(String hostname, SSLSession session) {
                //return true; // verify always returns true, which could cause insecure network traffic due to trusting TLS/SSL server certificates for wrong hostnames
                HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();
                return hv.verify(""localhost"", session);
            }
        };
    }
",1
32786929,2,"    byte[] plaintextPadded = new byte[targetSize];
    System.arraycopy(plaintext, 0, plaintextPadded, 0, plaintext.length);

    cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
    byte[] encrypted = cipher.doFinal(plaintextPadded);",2
32802242,0,"    final byte[] secretBase64Key = Base64.decodeBase64(secretKey);
    final SecretKey key = new SecretKeySpec(secretBase64Key, DE_SEDE);
    final Cipher cipher = Cipher.getInstance(PADDING);
    cipher.init(Cipher.ENCRYPT_MODE, key);",2
32802242,0,"    final byte[] secretBase64Key = Base64.decodeBase64(secretKey);
    final SecretKey key = new SecretKeySpec(secretBase64Key, DE_SEDE);
    final Cipher decipher = Cipher.getInstance(PADDING);
    decipher.init(Cipher.DECRYPT_MODE, key);",2
32928781,1,"    for (Signature signature : info.signatures){
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }",4
32977032,4,"    Key key = new SecretKeySpec(keyValue, ""AES"");
    byte[] iv = Base64.decode(ivValue.getBytes(""UTF-8""), Base64.DEFAULT);
    byte[] decodedValue = Base64.decode(encryptedData.getBytes(""UTF-8""), Base64.DEFAULT);
",2
32977032,4,"    Key key = new SecretKeySpec(keyValue, ""AES"");
    byte[] iv = Base64.decode(ivValue.getBytes(""UTF-8""), Base64.DEFAULT);
    byte[] decodedValue = Base64.decode(encryptedData.getBytes(""UTF-8""), Base64.DEFAULT);
",2
32977032,4,"    Cipher c = Cipher.getInstance(""AES/CBC/PKCS7Padding""); // or PKCS5Padding
    c.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
    byte[] decValue = c.doFinal(decodedValue);

    int firstQuoteIndex = 0;
    while(decValue[firstQuoteIndex] != (byte)'""') firstQuoteIndex++;
    return new String(Arrays.copyOfRange(decValue, firstQuoteIndex + 1, decValue.length-2));",2
32977032,5,"    Key key = new SecretKeySpec(keyValue, ""AES"");
    byte[] iv = Base64.decode(ivValue.getBytes(""UTF-8""), Base64.DEFAULT);
    byte[] decodedValue = Base64.decode(encryptedData.getBytes(""UTF-8""), Base64.DEFAULT);
",2
32977032,5,"    Key key = new SecretKeySpec(keyValue, ""AES"");
    byte[] iv = Base64.decode(ivValue.getBytes(""UTF-8""), Base64.DEFAULT);
    byte[] decodedValue = Base64.decode(encryptedData.getBytes(""UTF-8""), Base64.DEFAULT);
",2
32977032,5,"    Cipher c = Cipher.getInstance(""AES/CBC/PKCS7Padding""); // or PKCS5Padding
    c.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(iv));
    byte[] decValue = c.doFinal(decodedValue);

    int firstQuoteIndex = 0;
    while(decValue[firstQuoteIndex] != (byte)'""') firstQuoteIndex++;
    return new String(Arrays.copyOfRange(decValue, firstQuoteIndex + 1, decValue.length-2));",2
32980130,0,"        InputStream caInput = getResources().openRawResource(keystoreResId);

        // creating a KeyStore containing trusted CAs

        if (keyStoreType == null || keyStoreType.length() == 0) {
            keyStoreType = KeyStore.getDefaultType();
        }
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
",2
33071430,4,"public class sample{
HostnameVerifier hostnameVerifier = new HostnameVerifier() {
    @Override
    public boolean verify(String hostname, SSLSession session) {
        HostnameVerifier hv =
            HttpsURLConnection.getDefaultHostnameVerifier();
        return hv.verify(""localhost"", session);
    }
};
",1
33108325,0,"    final byte[] ivData = new byte[blockSize];
    final SecureRandom rnd = SecureRandom.getInstance(""SHA1PRNG"");
    rnd.nextBytes(ivData);
    final IvParameterSpec iv = new IvParameterSpec(ivData);

    cipher.init(Cipher.ENCRYPT_MODE, key, iv);
    final byte[] encryptedMessage = cipher.doFinal(encodedMessage);

    // concatenate IV and encrypted message
    final byte[] ivAndEncryptedMessage = new byte[ivData.length + encryptedMessage.length];
    System.arraycopy(ivData, 0, ivAndEncryptedMessage, 0, blockSize);
    System.arraycopy(encryptedMessage, 0, ivAndEncryptedMessage, blockSize, encryptedMessage.length);",2
33122393,0,"public class TestHttpClient {
    // Reference: http://boredwookie.net/index.php/blog/how-to-use-bouncy-castle-lightweight-api-s-tlsclient/
    //            bcprov-jdk15on-153.tar\src\org\bouncycastle\crypto\tls\test\TlsClientTest.java
    public static void main(String[] args) throws Exception {
        java.security.SecureRandom secureRandom = new java.security.SecureRandom();
        Socket socket = new Socket(java.net.InetAddress.getByName(""www.google.com""), 443);
        TlsClientProtocol protocol = new TlsClientProtocol(socket.getInputStream(), socket.getOutputStream(),secureRandom);
        DefaultTlsClient client = new DefaultTlsClient() {
            public TlsAuthentication getAuthentication() throws IOException {
                TlsAuthentication auth = new TlsAuthentication() {
                    // Capture the server certificate information!
                    public void notifyServerCertificate(org.bouncycastle.crypto.tls.Certificate serverCertificate) throws IOException {
                    }

                    public TlsCredentials getClientCredentials(CertificateRequest certificateRequest) throws IOException {
                        return null;
                    }
                };
                return auth;
            }
        };
        protocol.connect(client);

        java.io.OutputStream output = protocol.getOutputStream();
        output.write(""GET / HTTP/1.1\r\n"".getBytes(""UTF-8""));
        output.write(""Host: www.google.com\r\n"".getBytes(""UTF-8""));
        output.write(""Connection: close\r\n"".getBytes(""UTF-8"")); // So the server will close socket immediately.
        output.write(""\r\n"".getBytes(""UTF-8"")); // HTTP1.1 requirement: last line must be empty line.
        output.flush();

        java.io.InputStream input = protocol.getInputStream();
        BufferedReader reader = new BufferedReader(new InputStreamReader(input));
        String line;
        while ((line = reader.readLine()) != null)
        {
            System.out.println(line);
        }
    }
}",1
33147202,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }



    /**
     * Based on http://download.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#X509TrustManager
     */",1
33147202,0,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }



    /**
     * Based on http://download.oracle.com/javase/1.5.0/docs/guide/security/jsse/JSSERefGuide.html#X509TrustManager
     */
    public static class AdditionalKeyStoresTrustManager implements X509TrustManager {

        protected ArrayList<X509TrustManager> x509TrustManagers = new ArrayList<X509TrustManager>();


        protected AdditionalKeyStoresTrustManager(KeyStore... additionalkeyStores) {
            final ArrayList<TrustManagerFactory> factories = new ArrayList<TrustManagerFactory>();

            try {
                // The default Trustmanager with default keystore
                final TrustManagerFactory original = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                original.init((KeyStore) null);
                factories.add(original);

                for( KeyStore keyStore : additionalkeyStores ) {
                    final TrustManagerFactory additionalCerts = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                    additionalCerts.init(keyStore);
                    factories.add(additionalCerts);
                }

            } catch (Exception e) {
                throw new RuntimeException(e);
            }



            /*
             * Iterate over the returned trustmanagers, and hold on
             * to any that are X509TrustManagers
             */
            for (TrustManagerFactory tmf : factories)
                for( TrustManager tm : tmf.getTrustManagers() )
                    if (tm instanceof X509TrustManager)
                        x509TrustManagers.add( (X509TrustManager)tm );


            if( x509TrustManagers.size()==0 )
                throw new RuntimeException(""Couldn't find any X509TrustManagers"");

        }

        /*
         * Delegate to the default trust manager.
         */
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            final X509TrustManager defaultX509TrustManager = x509TrustManagers.get(0);
            defaultX509TrustManager.checkClientTrusted(chain, authType);
        }

        /*
         * Loop over the trustmanagers until we find one that accepts our server
         */
        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
            for( X509TrustManager tm : x509TrustManagers ) {
                try {
                    tm.checkServerTrusted(chain,authType);
                    return;
                } catch( CertificateException e ) {
                    // ignore
                }
            }
            throw new CertificateException();
        }

        public X509Certificate[] getAcceptedIssuers() {
            final ArrayList<X509Certificate> list = new ArrayList<X509Certificate>();
            for( X509TrustManager tm : x509TrustManagers )
                list.addAll(Arrays.asList(tm.getAcceptedIssuers()));
            return list.toArray(new X509Certificate[list.size()]);
        }
    }
",1
33147202,0,"            } catch (Exception e) {
                throw new RuntimeException(e);
            }



            /*
             * Iterate over the returned trustmanagers, and hold on
             * to any that are X509TrustManagers
             */
            for (TrustManagerFactory tmf : factories)
                for( TrustManager tm : tmf.getTrustManagers() )
                    if (tm instanceof X509TrustManager)
                        x509TrustManagers.add( (X509TrustManager)tm );

",1
33147202,0,"        public X509Certificate[] getAcceptedIssuers() {
            final ArrayList<X509Certificate> list = new ArrayList<X509Certificate>();
            for( X509TrustManager tm : x509TrustManagers )
                list.addAll(Arrays.asList(tm.getAcceptedIssuers()));
            return list.toArray(new X509Certificate[list.size()]);
        }",1
33185921,1,"  public static byte[] encrypt(byte[] key1, byte[] key2, byte[] value) {
    try {
      IvParameterSpec iv = new IvParameterSpec(key2);
      SecretKeySpec skeySpec = new SecretKeySpec(key1, ""AES"");

      Cipher cipher = Cipher.getInstance(""AES/CBC/NOPADDING"");
      cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);

      byte[] encrypted = cipher.doFinal(value);

      return encrypted;

    } catch (Exception ex) {
      ex.printStackTrace();
    }

    return null;
  }
",2
33185921,1,"      IvParameterSpec iv = new IvParameterSpec(key2);
      SecretKeySpec skeySpec = new SecretKeySpec(key1, ""AES"");

      Cipher cipher = Cipher.getInstance(""AES/CBC/NOPADDING"");
      cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
",2
33185921,1,"  public static byte[] decrypt(byte[] key1, byte[] key2, byte[] encrypted) {
    try {
      IvParameterSpec iv = new IvParameterSpec(key2);
      SecretKeySpec skeySpec = new SecretKeySpec(key1, ""AES"");

      Cipher cipher = Cipher.getInstance(""AES/CBC/NOPADDING"");
      cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);

      byte[] original = cipher.doFinal(encrypted);

      return original;

    } catch (Exception ex) {
      ex.printStackTrace();
    }

    return null;
  }
",2
33185921,1,"      IvParameterSpec iv = new IvParameterSpec(key2);
      SecretKeySpec skeySpec = new SecretKeySpec(key1, ""AES"");

      Cipher cipher = Cipher.getInstance(""AES/CBC/NOPADDING"");
      cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
",2
33210966,0,"public class TestHttpClient {
    // Reference: http://boredwookie.net/index.php/blog/how-to-use-bouncy-castle-lightweight-api-s-tlsclient/
    //            bcprov-jdk15on-153.tar\src\org\bouncycastle\crypto\tls\test\TlsClientTest.java
    public static void main(String[] args) throws Exception {
        java.security.SecureRandom secureRandom = new java.security.SecureRandom();
        Socket socket = new Socket(java.net.InetAddress.getByName(""www.google.com""), 443);
        TlsClientProtocol protocol = new TlsClientProtocol(socket.getInputStream(), socket.getOutputStream(),secureRandom);
        DefaultTlsClient client = new DefaultTlsClient() {
            public TlsAuthentication getAuthentication() throws IOException {
                TlsAuthentication auth = new TlsAuthentication() {
                    // Capture the server certificate information!
                    public void notifyServerCertificate(org.bouncycastle.crypto.tls.Certificate serverCertificate) throws IOException {
                    }

                    public TlsCredentials getClientCredentials(CertificateRequest certificateRequest) throws IOException {
                        return null;
                    }
                };
                return auth;
            }
        };
        protocol.connect(client);

        java.io.OutputStream output = protocol.getOutputStream();
        output.write(""GET / HTTP/1.1\r\n"".getBytes(""UTF-8""));
        output.write(""Host: www.google.com\r\n"".getBytes(""UTF-8""));
        output.write(""Connection: close\r\n"".getBytes(""UTF-8"")); // So the server will close socket immediately.
        output.write(""\r\n"".getBytes(""UTF-8"")); // HTTP1.1 requirement: last line must be empty line.
        output.flush();

        java.io.InputStream input = protocol.getInputStream();
        BufferedReader reader = new BufferedReader(new InputStreamReader(input));
        String line;
        while ((line = reader.readLine()) != null)
        {
            System.out.println(line);
        }
    }
}",1
33216302,0,"public class sample{
public static PGPSecretKey readSecretKeyFromCol(InputStream in, long keyId) throws IOException, PGPException {
    in = PGPUtil.getDecoderStream(in);
    PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(in, new BcKeyFingerprintCalculator());

    PGPSecretKey key = pgpSec.getSecretKey(keyId);

    if (key == null) {
        throw new IllegalArgumentException(""Can't find encryption key in key ring."");
    }
    return key;
}
",4
33216302,1,"public class sample{
@SuppressWarnings(""rawtypes"")
    public static PGPPublicKey readPublicKeyFromCol(InputStream in) throws IOException, PGPException {
        in = PGPUtil.getDecoderStream(in);
        PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection(in, new BcKeyFingerprintCalculator());
        PGPPublicKey key = null;
        Iterator rIt = pgpPub.getKeyRings();
        while (key == null && rIt.hasNext()) {
            PGPPublicKeyRing kRing = (PGPPublicKeyRing) rIt.next();
            Iterator kIt = kRing.getPublicKeys();
            while (key == null && kIt.hasNext()) {
                PGPPublicKey k = (PGPPublicKey) kIt.next();
                if (k.isEncryptionKey()) {
                    key = k;
                }
            }
        }
        if (key == null) {
            throw new IllegalArgumentException(""Can't find encryption key in key ring."");
        }
        return key;
    }
",3
33216302,2,"public class sample{
public void decryptFile(InputStream in, InputStream secKeyIn, InputStream pubKeyIn, char[] pass) throws IOException, PGPException, InvalidCipherTextException {
        Security.addProvider(new BouncyCastleProvider());

        PGPPublicKey pubKey = readPublicKeyFromCol(pubKeyIn);

        PGPSecretKey secKey = readSecretKeyFromCol(secKeyIn, pubKey.getKeyID());

        in = PGPUtil.getDecoderStream(in);

        JcaPGPObjectFactory pgpFact;


        PGPObjectFactory pgpF = new PGPObjectFactory(in, new BcKeyFingerprintCalculator());

        Object o = pgpF.nextObject();
        PGPEncryptedDataList encList;

        if (o instanceof PGPEncryptedDataList) {

            encList = (PGPEncryptedDataList) o;

        } else {

            encList = (PGPEncryptedDataList) pgpF.nextObject();

        }

        Iterator<PGPPublicKeyEncryptedData> itt = encList.getEncryptedDataObjects();
        PGPPrivateKey sKey = null;
        PGPPublicKeyEncryptedData encP = null;
        while (sKey == null && itt.hasNext()) {
            encP = itt.next();
            secKey = readSecretKeyFromCol(new FileInputStream(""PrivateKey.asc""), encP.getKeyID());
            sKey = secKey.extractPrivateKey(new BcPBESecretKeyDecryptorBuilder(new BcPGPDigestCalculatorProvider()).build(pass));
        }
        if (sKey == null) {
            throw new IllegalArgumentException(""Secret key for message not found."");
        }

        InputStream clear = encP.getDataStream(new BcPublicKeyDataDecryptorFactory(sKey));

        pgpFact = new JcaPGPObjectFactory(clear);

        PGPCompressedData c1 = (PGPCompressedData) pgpFact.nextObject();

        pgpFact = new JcaPGPObjectFactory(c1.getDataStream());

        PGPLiteralData ld = (PGPLiteralData) pgpFact.nextObject();
        ByteArrayOutputStream bOut = new ByteArrayOutputStream();

        InputStream inLd = ld.getDataStream();

        int ch;
        while ((ch = inLd.read()) >= 0) {
            bOut.write(ch);
        }

        //System.out.println(bOut.toString());

        bOut.writeTo(new FileOutputStream(ld.getFileName()));
        //return bOut;

    }

    public static void encryptFile(OutputStream out, String fileName, PGPPublicKey encKey) throws IOException, NoSuchProviderException, PGPException {
        Security.addProvider(new BouncyCastleProvider());

        ByteArrayOutputStream bOut = new ByteArrayOutputStream();

        PGPCompressedDataGenerator comData = new PGPCompressedDataGenerator(PGPCompressedData.ZIP);

        PGPUtil.writeFileToLiteralData(comData.open(bOut), PGPLiteralData.BINARY, new File(fileName));

        comData.close();

        PGPEncryptedDataGenerator cPk = new PGPEncryptedDataGenerator(new BcPGPDataEncryptorBuilder(SymmetricKeyAlgorithmTags.TRIPLE_DES).setSecureRandom(new SecureRandom()));

        cPk.addMethod(new BcPublicKeyKeyEncryptionMethodGenerator(encKey));

        byte[] bytes = bOut.toByteArray();

        OutputStream cOut = cPk.open(out, bytes.length);

        cOut.write(bytes);

        cOut.close();

        out.close();
    }
",4
33216302,2,"        if (o instanceof PGPEncryptedDataList) {

            encList = (PGPEncryptedDataList) o;

        } else {

            encList = (PGPEncryptedDataList) pgpF.nextObject();

        }

        Iterator<PGPPublicKeyEncryptedData> itt = encList.getEncryptedDataObjects();
        PGPPrivateKey sKey = null;
        PGPPublicKeyEncryptedData encP = null;",4
33216302,3,"public class sample{
 public void foo(){
try {
             decryptFile(new FileInputStream(""encryptedFile.gpg""), new FileInputStream(""PrivateKey.asc""), new FileInputStream(""PublicKey.asc""), ""yourKeyPassword"".toCharArray());

            PGPPublicKey pubKey = readPublicKeyFromCol(new FileInputStream(""PublicKey.asc""));

            encryptFile(new FileOutputStream(""encryptedFileOutput.gpg""), ""fileToEncrypt.txt"", pubKey);




        } catch (PGPException e) {
            fail(""exception: "" + e.getMessage(), e.getUnderlyingException());
        }

}",4
33216826,0,"public class sample{
public static PGPSecretKey readSecretKeyFromCol(InputStream in, long keyId) throws IOException, PGPException {
in = PGPUtil.getDecoderStream(in);
PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection(in, new BcKeyFingerprintCalculator());

PGPSecretKey key = pgpSec.getSecretKey(keyId);

if (key == null) {
    throw new IllegalArgumentException(""Can't find encryption key in key ring."");
}
return key;
}
",4
33216826,1,"public class sample{
@SuppressWarnings(""rawtypes"")
public static PGPPublicKey readPublicKeyFromCol(InputStream in) throws IOException, PGPException {
    in = PGPUtil.getDecoderStream(in);
    PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection(in, new BcKeyFingerprintCalculator());
    PGPPublicKey key = null;
    Iterator rIt = pgpPub.getKeyRings();
    while (key == null && rIt.hasNext()) {
        PGPPublicKeyRing kRing = (PGPPublicKeyRing) rIt.next();
        Iterator kIt = kRing.getPublicKeys();
        while (key == null && kIt.hasNext()) {
            PGPPublicKey k = (PGPPublicKey) kIt.next();
            if (k.isEncryptionKey()) {
                key = k;
            }
        }
    }
    if (key == null) {
        throw new IllegalArgumentException(""Can't find encryption key in key ring."");
    }
    return key;
}
",3
33216826,2,"public class sample{
public void decryptFile(InputStream in, InputStream secKeyIn, InputStream pubKeyIn, char[] pass) throws IOException, PGPException, InvalidCipherTextException {
    Security.addProvider(new BouncyCastleProvider());

    PGPPublicKey pubKey = readPublicKeyFromCol(pubKeyIn);

    PGPSecretKey secKey = readSecretKeyFromCol(secKeyIn, pubKey.getKeyID());

    in = PGPUtil.getDecoderStream(in);

    JcaPGPObjectFactory pgpFact;


    PGPObjectFactory pgpF = new PGPObjectFactory(in, new BcKeyFingerprintCalculator());

    Object o = pgpF.nextObject();
    PGPEncryptedDataList encList;

    if (o instanceof PGPEncryptedDataList) {

        encList = (PGPEncryptedDataList) o;

    } else {

        encList = (PGPEncryptedDataList) pgpF.nextObject();

    }

    Iterator<PGPPublicKeyEncryptedData> itt = encList.getEncryptedDataObjects();
    PGPPrivateKey sKey = null;
    PGPPublicKeyEncryptedData encP = null;
    while (sKey == null && itt.hasNext()) {
        encP = itt.next();
        secKey = readSecretKeyFromCol(new FileInputStream(""PrivateKey.asc""), encP.getKeyID());
        sKey = secKey.extractPrivateKey(new BcPBESecretKeyDecryptorBuilder(new BcPGPDigestCalculatorProvider()).build(pass));
    }
    if (sKey == null) {
        throw new IllegalArgumentException(""Secret key for message not found."");
    }

    InputStream clear = encP.getDataStream(new BcPublicKeyDataDecryptorFactory(sKey));

    pgpFact = new JcaPGPObjectFactory(clear);

    PGPCompressedData c1 = (PGPCompressedData) pgpFact.nextObject();

    pgpFact = new JcaPGPObjectFactory(c1.getDataStream());

    PGPLiteralData ld = (PGPLiteralData) pgpFact.nextObject();
    ByteArrayOutputStream bOut = new ByteArrayOutputStream();

    InputStream inLd = ld.getDataStream();

    int ch;
    while ((ch = inLd.read()) >= 0) {
        bOut.write(ch);
    }

    //System.out.println(bOut.toString());

    bOut.writeTo(new FileOutputStream(ld.getFileName()));
    //return bOut;

}

public static void encryptFile(OutputStream out, String fileName, PGPPublicKey encKey) throws IOException, NoSuchProviderException, PGPException {
    Security.addProvider(new BouncyCastleProvider());

    ByteArrayOutputStream bOut = new ByteArrayOutputStream();

    PGPCompressedDataGenerator comData = new PGPCompressedDataGenerator(PGPCompressedData.ZIP);

    PGPUtil.writeFileToLiteralData(comData.open(bOut), PGPLiteralData.BINARY, new File(fileName));

    comData.close();

    PGPEncryptedDataGenerator cPk = new PGPEncryptedDataGenerator(new BcPGPDataEncryptorBuilder(SymmetricKeyAlgorithmTags.TRIPLE_DES).setSecureRandom(new SecureRandom()));

    cPk.addMethod(new BcPublicKeyKeyEncryptionMethodGenerator(encKey));

    byte[] bytes = bOut.toByteArray();

    OutputStream cOut = cPk.open(out, bytes.length);

    cOut.write(bytes);

    cOut.close();

    out.close();
}
",4
33216826,2,"    if (o instanceof PGPEncryptedDataList) {

        encList = (PGPEncryptedDataList) o;

    } else {

        encList = (PGPEncryptedDataList) pgpF.nextObject();

    }

    Iterator<PGPPublicKeyEncryptedData> itt = encList.getEncryptedDataObjects();
    PGPPrivateKey sKey = null;
    PGPPublicKeyEncryptedData encP = null;",4
33216826,3,"public class sample{
 public void foo(){
try {
         decryptFile(new FileInputStream(""encryptedFile.gpg""), new FileInputStream(""PrivateKey.asc""), new FileInputStream(""PublicKey.asc""), ""yourKeyPassword"".toCharArray());

        PGPPublicKey pubKey = readPublicKeyFromCol(new FileInputStream(""PublicKey.asc""));

        encryptFile(new FileOutputStream(""encryptedFileOutput.gpg""), ""fileToEncrypt.txt"", pubKey);




    } catch (PGPException e) {
        fail(""exception: "" + e.getMessage(), e.getUnderlyingException());
    }

}",4
33249876,0,"    KeyStore clientStore = KeyStore.getInstance(""PKCS12"");
    clientStore.load(new FileInputStream(""/Users/me/authClient.p12""), ""mypassword"".toCharArray());

    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmf.init(clientStore, ""mypassword"".toCharArray());
    KeyManager[] keyManagers = kmf.getKeyManagers();

    KeyStore trustStore = KeyStore.getInstance(""JKS"");
    trustStore.load(new FileInputStream(""/Users/me/authClient-truststore.jks""), ""mypassword"".toCharArray());

    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(trustStore);
    TrustManager[] tms = tmf.getTrustManagers();
",1
33249876,0,"    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmf.init(clientStore, ""mypassword"".toCharArray());
    KeyManager[] keyManagers = kmf.getKeyManagers();

    KeyStore trustStore = KeyStore.getInstance(""JKS"");
    trustStore.load(new FileInputStream(""/Users/me/authClient-truststore.jks""), ""mypassword"".toCharArray());

    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(trustStore);
    TrustManager[] tms = tmf.getTrustManagers();
",-1
33260623,0,"        byte[] bytes = messageDigest.digest();
        StringBuilder buffer = new StringBuilder();
        for (byte b : bytes)
        {
            buffer.append(Integer.toString((b & 0xff) + 0x100, 16).substring(1));
        }",4
33260623,0,"        byte[] bytes = messageDigest.digest();
        StringBuilder buffer = new StringBuilder();
        for (byte b : bytes)
        {
            buffer.append(Integer.toString((b & 0xff) + 0x100, 16).substring(1));
        }
        return buffer.toString();",4
33308732,2,"        in = PGPUtil.getDecoderStream(in);
        PGPObjectFactory pgpF = new PGPObjectFactory(in);
        PGPEncryptedDataList enc;
        Object o = pgpF.nextObject();
        if (o instanceof PGPEncryptedDataList) {
            enc = (PGPEncryptedDataList) o;
        } else {
            enc = (PGPEncryptedDataList) pgpF.nextObject();
        }",4
33308732,2,"            PGPObjectFactory pgpFact = new PGPObjectFactory(clear);
            PGPCompressedData cData = (PGPCompressedData) pgpFact.nextObject();
            pgpFact = new PGPObjectFactory(cData.getDataStream());
            PGPLiteralData ld = (PGPLiteralData) pgpFact.nextObject();
            InputStream unc = ld.getInputStream();
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            int ch;
            while ((ch = unc.read()) >= 0) {
                out.write(ch);
            }
            byte[] returnBytes = out.toByteArray();
            out.close();",3
33308732,2,"        Iterator<?> kIt = publicKeyRing.getPublicKeys();
        while (kIt.hasNext()) {
            PGPPublicKey k = (PGPPublicKey) kIt.next();
            if (k.isEncryptionKey()) {
                return k;
            }
        }",4
33308732,2,"    private static PGPPublicKeyRing getPGPPublicKeyRing() throws IOException {
        ArmoredInputStream ais = new ArmoredInputStream(new ByteArrayInputStream(Device.getDevice().getPgpPublicKey().getBytes()));
        return (PGPPublicKeyRing) new PGPObjectFactory(ais).nextObject();
    }
",3
33308732,2,"    private static PGPSecretKeyRing getPGPSecretKeyRing() throws IOException {
        ArmoredInputStream ais = new ArmoredInputStream(new ByteArrayInputStream(Device.getDevice().getPgpSecretKey().getBytes()));
        return (PGPSecretKeyRing) new PGPObjectFactory(ais).nextObject();
    }
",3
33308732,2,"    public final static String genPGPPublicKey (PGPKeyRingGenerator krgen) throws IOException {
        ByteArrayOutputStream baosPkr = new ByteArrayOutputStream();
        PGPPublicKeyRing pkr = krgen.generatePublicKeyRing();
        ArmoredOutputStream armoredStreamPkr = new ArmoredOutputStream(baosPkr);
        pkr.encode(armoredStreamPkr);
        armoredStreamPkr.close();
        return new String(baosPkr.toByteArray(), Charset.defaultCharset());
    }
",3
33308732,2,"    public final static String genPGPPrivKey (PGPKeyRingGenerator krgen) throws IOException {
        ByteArrayOutputStream baosPriv = new ByteArrayOutputStream ();
        PGPSecretKeyRing skr = krgen.generateSecretKeyRing();
        ArmoredOutputStream armoredStreamPriv = new ArmoredOutputStream(baosPriv);
        skr.encode(armoredStreamPriv);
        armoredStreamPriv.close();
        return new String(baosPriv.toByteArray(), Charset.defaultCharset());
    }",3
33388132,0,"            SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(), HMAC_SHA1_ALGORITHM);
            Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);
            mac.init(signingKey);
            byte[] rawHmac = mac.doFinal(data.getBytes());",4
33426378,0,"RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, publicExponent);
KeyFactory kf = KeyFactory.getInstance(""RSA"");
PublicKey generatedPublic = kf.generatePublic(keySpec);
System.out.printf(""Modulus: %X%n"", modulus);
System.out.printf(""Public exponent: %d ... 17? Why?%n"", publicExponent); // 17? OK.
System.out.printf(""See, Java class result: %s, is RSAPublicKey: %b%n"", generatedPublic.getClass().getName(), generatedPublic instanceof RSAPublicKey);
",3
33488427,1,"        } finally {
            caInput.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore",1
33488427,1,"        } finally {
            caInput.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        // Create an SSLContext that uses our TrustManager",1
33489269,0,"byte[] cipherText = new byte[cipher.getOutputSize(input.length)];
int ctLength = cipher.update(input, 0, input.length, cipherText, 0);
ctLength += cipher.doFinal(cipherText, ctLength);
",2
33495988,0,"    private SSLSocket _createSSLSocket(final String host , final TlsClientProtocol tlsClientProtocol) {
     return new SSLSocket() {            
        private java.security.cert.Certificate[] peertCerts;

         @Override
          public InputStream getInputStream() throws IOException {
              return tlsClientProtocol.getInputStream();
          }

          @Override
          public OutputStream getOutputStream() throws IOException {
              return tlsClientProtocol.getOutputStream();
          }

          @Override
          public synchronized void close() throws IOException {         
             tlsClientProtocol.close();
          }

           @Override
           public void addHandshakeCompletedListener(HandshakeCompletedListener arg0) {         

           }

            @Override
            public boolean getEnableSessionCreation() {         
                return false;
            }

            @Override
            public String[] getEnabledCipherSuites() {          
                return null;
            }

            @Override
            public String[] getEnabledProtocols() {
                // TODO Auto-generated method stub
                return null;
            }

            @Override
            public boolean getNeedClientAuth(){         
                return false;
            }

            @Override
            public SSLSession getSession() {
                   return new SSLSession() {

                    @Override
                    public int getApplicationBufferSize() {                 
                        return 0;
                    }

                    @Override
                    public String getCipherSuite() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public long getCreationTime() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public byte[] getId() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public long getLastAccessedTime() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public java.security.cert.Certificate[] getLocalCertificates() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public Principal getLocalPrincipal() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public int getPacketBufferSize() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public X509Certificate[] getPeerCertificateChain()
                            throws SSLPeerUnverifiedException {
                        // TODO Auto-generated method stub
                        return null;
                    }

                    @Override
                    public java.security.cert.Certificate[] getPeerCertificates()throws SSLPeerUnverifiedException {
                         return peertCerts;
                    }

                    @Override
                    public String getPeerHost() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public int getPeerPort() {                      
                        return 0;
                    }

                    @Override
                    public Principal getPeerPrincipal() throws SSLPeerUnverifiedException {
                      return null;
                         //throw new UnsupportedOperationException();

                    }

                    @Override
                    public String getProtocol() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public SSLSessionContext getSessionContext() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public Object getValue(String arg0) {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public String[] getValueNames() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public void invalidate() {
                         throw new UnsupportedOperationException();

                    }

                    @Override
                    public boolean isValid() {
                         throw new UnsupportedOperationException();
                    }

                    @Override
                    public void putValue(String arg0, Object arg1) {
                         throw new UnsupportedOperationException();

                    }

                    @Override
                    public void removeValue(String arg0) {
                         throw new UnsupportedOperationException();

                    }

                   };
            }


            @Override
            public String[] getSupportedProtocols() {       
                return null;
            }

            @Override
            public boolean getUseClientMode() {             
                return false;
            }

            @Override
            public boolean getWantClientAuth() {

                return false;
            }

            @Override
            public void removeHandshakeCompletedListener(HandshakeCompletedListener arg0) {             

            }

            @Override
            public void setEnableSessionCreation(boolean arg0) {


            }

            @Override
            public void setEnabledCipherSuites(String[] arg0) {         

            }

            @Override
            public void setEnabledProtocols(String[] arg0) {


            }

            @Override
            public void setNeedClientAuth(boolean arg0) {           

            }

            @Override
            public void setUseClientMode(boolean arg0) {            

            }

            @Override
            public void setWantClientAuth(boolean arg0) {               

            }

            @Override
            public String[] getSupportedCipherSuites() {            
                return null;
            }
            @Override
            public void startHandshake() throws IOException {
                  tlsClientProtocol.connect(new DefaultTlsClient() {                       
                         @Override
                          public Hashtable<Integer, byte[]> getClientExtensions() throws IOException {
                                Hashtable<Integer, byte[]> clientExtensions = super.getClientExtensions();
                                if (clientExtensions == null) {
                                    clientExtensions = new Hashtable<Integer, byte[]>();
                                }

                                //Add host_name
                                byte[] host_name = host.getBytes();

                                final ByteArrayOutputStream baos = new ByteArrayOutputStream();
                                final DataOutputStream dos = new DataOutputStream(baos);
                                dos.writeShort(host_name.length + 3); // entry size
                                dos.writeByte(0); // name type = hostname
                                dos.writeShort(host_name.length);
                                dos.write(host_name);
                                dos.close();
                                clientExtensions.put(ExtensionType.server_name, baos.toByteArray());
                                return clientExtensions;
                        }

                        @Override
                        public TlsAuthentication getAuthentication()
                                throws IOException {
                            return new TlsAuthentication() {


                                @Override
                                public void notifyServerCertificate(Certificate serverCertificate) throws IOException {

                                  try {
                                        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
                                        List<java.security.cert.Certificate> certs = new LinkedList<java.security.cert.Certificate>();
                                        for ( org.bouncycastle.asn1.x509.Certificate c : serverCertificate.getCertificateList()) {                                          
                                            certs.add(cf.generateCertificate(new ByteArrayInputStream(c.getEncoded())));
                                        }
                                        peertCerts = certs.toArray(new java.security.cert.Certificate[0]);
                                    } catch (CertificateException e) {                                   
                                       System.out.println( ""Failed to cache server certs""+ e);
                                       throw new IOException(e);
                                    }

                                }

                                @Override
                                public TlsCredentials getClientCredentials(CertificateRequest arg0)
                                        throws IOException {                                    
                                    return null;
                                }

                            };

                        }

                   });



            }




     };//Socket

    }",1
33561701,0,"     KeyPairGenerator generator;
                generator = KeyPairGenerator.getInstance(""RSA"", ""BC"");
                generator.initialize(256, new SecureRandom());
                KeyPair pair = generator.generateKeyPair();
                pubKey = pair.getPublic();
                privKey = pair.getPrivate();            
                byte[] publicKeyBytes = pubKey.getEncoded();
                String pubKeyStr = new String(Base64.encode(publicKeyBytes));
                byte[] privKeyBytes = privKey.getEncoded();
                String privKeyStr = new String(Base64.encode(privKeyBytes));            
                SPE = SP.edit();
                SPE.putString(""PublicKey"", pubKeyStr);
                SPE.putString(""PrivateKey"", privKeyStr);           
                SPE.commit();

  } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }           
    }

public PublicKey getPublicKey(){
        String pubKeyStr = SP.getString(""PublicKey"", """");       
        byte[] sigBytes = Base64.decode(pubKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePublic(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPublicKeyAsString(){
        return SP.getString(""PublicKey"", """");       
    }
    public PrivateKey getPrivateKey(){
        String privKeyStr = SP.getString(""PrivateKey"", """");
        byte[] sigBytes = Base64.decode(privKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePrivate(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPrivateKeyAsString(){
        return SP.getString(""PrivateKey"", """");      
    }
",3
33561701,0,"public PublicKey getPublicKey(){
        String pubKeyStr = SP.getString(""PublicKey"", """");       
        byte[] sigBytes = Base64.decode(pubKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePublic(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPublicKeyAsString(){
        return SP.getString(""PublicKey"", """");       
    }",3
33561701,0,"    public PrivateKey getPrivateKey(){
        String privKeyStr = SP.getString(""PrivateKey"", """");
        byte[] sigBytes = Base64.decode(privKeyStr);
        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(sigBytes);
        KeyFactory keyFact = null;
        try {
            keyFact = KeyFactory.getInstance(""RSA"", ""BC"");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchProviderException e) {
            e.printStackTrace();
        }
        try {
            return  keyFact.generatePrivate(x509KeySpec);
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }
        return null;
    }
    public String getPrivateKeyAsString(){
        return SP.getString(""PrivateKey"", """");      
    }
",3
33696344,1,"  KeyStore keystore = KeyStore.getInstance(""JKS"");
  keystore.load(null);
  keystore.setCertificateEntry(""cert-alias"", cert);
  keystore.setKeyEntry(""key-alias"", key, ""changeit"".toCharArray(), new Certificate[] { cert });

  KeyManagerFactory kmf = KeyManagerFactory.getInstance(""SunX509"");
  kmf.init(keystore, ""changeit"".toCharArray());

  KeyManager[] km = kmf.getKeyManagers();

  context.init(km, null, null);

  return context.getSocketFactory();",1
33696344,1,"   private byte[] parseDERFromPEM(byte[] pem, String beginDelimiter, String endDelimiter) {
  String data = new String(pem);
  String[] tokens = data.split(beginDelimiter);
  tokens = tokens[1].split(endDelimiter);
  return DatatypeConverter.parseBase64Binary(tokens[0]);
   }
",1
33763179,1,"        } finally {
            caInput.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore",1
33763179,1,"        } finally {
            caInput.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        // Create an SSLContext that uses our TrustManager",1
33768305,3,"using (MemoryStream ms = new MemoryStream())
{
    using (CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(), CryptoStreamMode.Write))
    {
        cs.Write(clearBytes, 0, clearBytes.Length);
        cs.Close();
    }
    encryptedText = Convert.ToBase64String(ms.ToArray());
}
",2
33890329,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
33890446,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
34007611,0,"        final byte[] secretBase64Key = Base64.decodeBase64(secretKey);
        final SecretKey key = new SecretKeySpec(secretBase64Key, DE_SEDE);
        final Cipher cipher = Cipher.getInstance(PADDING);
        cipher.init(Cipher.ENCRYPT_MODE, key);",2
34007611,0,"        final byte[] secretBase64Key = Base64.decodeBase64(secretKey);
        final SecretKey key = new SecretKeySpec(secretBase64Key, DE_SEDE);
        final Cipher decipher = Cipher.getInstance(PADDING);
        decipher.init(Cipher.DECRYPT_MODE, key);",2
34041971,0,"public byte[] createSha1(File file) throws Exception  {
MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
InputStream fis = new FileInputStream(file);
int n = 0;
byte[] buffer = new byte[8192];
while (n != -1) {
    n = fis.read(buffer);
    if (n > 0) {
        digest.update(buffer, 0, n);
    }
}
return digest.digest();
}
",4
34075332,3,"    MessageDigest md = MessageDigest.getInstance(""SHA1"");
    FileInputStream fis = new FileInputStream(datafile);
    byte[] dataBytes = new byte[1024];

    int nread = 0; 

    while ((nread = fis.read(dataBytes)) != -1) {
      md.update(dataBytes, 0, nread);
    }

    byte[] mdbytes = md.digest();

    //convert the byte to hex format
    StringBuffer sb = new StringBuffer("""");
    for (int i = 0; i < mdbytes.length; i++) {
      sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
    }
  //SNAP - YOUR CODE ENDS",4
34075332,3,"    byte[] dataBytes = new byte[1024];

    int nread = 0; 

    while ((nread = fis.read(dataBytes)) != -1) {
      md.update(dataBytes, 0, nread);
    }

    byte[] mdbytes = md.digest();

    //convert the byte to hex format",4
34075332,4,"        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        FileInputStream fis = new FileInputStream(datafile);
        byte[] dataBytes = new byte[1024];

        int nread = 0;

        while ((nread = fis.read(dataBytes)) != -1) {
            md.update(dataBytes, 0, nread);
        }

        byte[] mdbytes = md.digest();

        // convert the byte to hex format
        StringBuffer sb = new StringBuffer("""");
        for (int i = 0; i < mdbytes.length; i++) {
            sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
        }
        // SNAP - YOUR CODE ENDS",4
34075332,4,"        byte[] dataBytes = new byte[1024];

        int nread = 0;

        while ((nread = fis.read(dataBytes)) != -1) {
            md.update(dataBytes, 0, nread);
        }

        byte[] mdbytes = md.digest();

        // convert the byte to hex format",4
34092350,0,"        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        FileInputStream fis = new FileInputStream(datafile);
        byte[] dataBytes = new byte[1024];

        int nread = 0;

        while ((nread = fis.read(dataBytes)) != -1) {
            md.update(dataBytes, 0, nread);
        }

        byte[] mdbytes = md.digest();

        // convert the byte to hex format
        StringBuffer sb = new StringBuffer("""");
        for (int i = 0; i < mdbytes.length; i++) {
            sb.append(Integer.toString((mdbytes[i] & 0xff) + 0x100, 16).substring(1));
        }
        // SNAP - YOUR CODE ENDS",4
34092350,0,"        byte[] dataBytes = new byte[1024];

        int nread = 0;

        while ((nread = fis.read(dataBytes)) != -1) {
            md.update(dataBytes, 0, nread);
        }

        byte[] mdbytes = md.digest();

        // convert the byte to hex format",4
34093905,0,"byte[] signature = sigAlg.sign();

// check padding manually
Cipher rsaRaw = Cipher.getInstance(""RSA/ECB/NoPadding"");
// encrypt or decrypt is actually the same operation for raw RSA
rsaRaw.init(Cipher.ENCRYPT_MODE, keyPair.getPublic());
byte[] paddedSig = rsaRaw.doFinal(signature);
// using Bouncy Castle's hex encoder, you can use any encoder",3
34098298,0,"KeyPairGenerator aliceKeyGen = KeyPairGenerator.getInstance(""ECDH"", ""BC"");
aliceKeyGen.initialize(new ECGenParameterSpec(""prime256v1""), new SecureRandom());

KeyPair alicePair = aliceKeyGen.generateKeyPair();
ECPublicKey alicePub = (ECPublicKey)alicePair.getPublic();
ECPrivateKey alicePvt = (ECPrivateKey)alicePair.getPrivate();

byte[] alicePubEncoded = alicePub.getEncoded();
byte[] alicePvtEncoded = alicePvt.getEncoded();

System.out.println(""Alice public: "" + DatatypeConverter.printHexBinary(alicePubEncoded));
System.out.println(""Alice private: "" + DatatypeConverter.printHexBinary(alicePvtEncoded));


// POST hex(alicePubEncoded)

// Bob receives Alice's public key

KeyFactory kf = KeyFactory.getInstance(""EC"");",3
34098298,0,"ECPrivateKey alicePvt = (ECPrivateKey)alicePair.getPrivate();

byte[] alicePubEncoded = alicePub.getEncoded();
byte[] alicePvtEncoded = alicePvt.getEncoded();

System.out.println(""Alice public: "" + DatatypeConverter.printHexBinary(alicePubEncoded));
System.out.println(""Alice private: "" + DatatypeConverter.printHexBinary(alicePvtEncoded));


// POST hex(alicePubEncoded)

// Bob receives Alice's public key
",3
34098298,0,"KeyPairGenerator bobKeyGen = KeyPairGenerator.getInstance(""ECDH"", ""BC"");
bobKeyGen.initialize(new ECGenParameterSpec(""prime256v1""), new SecureRandom());

KeyPair bobPair = bobKeyGen.generateKeyPair();
ECPublicKey bobPub = (ECPublicKey)bobPair.getPublic();
ECPrivateKey bobPvt = (ECPrivateKey)bobPair.getPrivate();

byte[] bobPubEncoded = bobPub.getEncoded();
byte[] bobPvtEncoded = bobPvt.getEncoded();

System.out.println(""Bob public: "" + DatatypeConverter.printHexBinary(bobPubEncoded));
System.out.println(""Bob private: "" + DatatypeConverter.printHexBinary(bobPvtEncoded));

KeyAgreement bobKeyAgree = KeyAgreement.getInstance(""ECDH"");",3
34098298,0,"ECPrivateKey bobPvt = (ECPrivateKey)bobPair.getPrivate();

byte[] bobPubEncoded = bobPub.getEncoded();
byte[] bobPvtEncoded = bobPvt.getEncoded();

System.out.println(""Bob public: "" + DatatypeConverter.printHexBinary(bobPubEncoded));
System.out.println(""Bob private: "" + DatatypeConverter.printHexBinary(bobPvtEncoded));
",3
34236976,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());

            Log.e(""Hash key"", """"+Base64.encodeToString(md.digest(),Base64.NO_WRAP));
        }",4
34271871,0,"        KeyPair keyPair = keyPairGenerator.generateKeyPair();

        // Signature
        Signature signatureProvider = null;
        if (null != provider)
            signatureProvider = Signature.getInstance(""SHA256WithRSA"", provider);
        else
            signatureProvider = Signature.getInstance(""SHA256WithRSA"");",3
34271871,0,"        byte[] hashToEncrypt = digestInfo.getEncoded();

        // Crypto
        // You could also use ""RSA/ECB/PKCS1Padding"" for both the BC and SUN Providers.
        Cipher encCipher = null;
        if (null != provider)
            encCipher = Cipher.getInstance(""RSA/NONE/PKCS1Padding"", provider);
        else
            encCipher = Cipher.getInstance(""RSA"");",3
34349335,0,"        Cipher c = Cipher.getInstance(ALGO);
        c.init(Cipher.DECRYPT_MODE, key);
        byte[] decordedValue = new BASE64Decoder().decodeBuffer(encryptedData);
        byte[] decValue = c.doFinal(decordedValue);",2
34508569,1,"public class sample{
 public void foo(){
SSLSocketFactory sf = new SSLSocketFactoryImpl();
SSLSocket s = (SSLSocket) sf.createSocket();
System.out.println( Arrays.toString( s.getSupportedProtocols() )) ;

}",1
34518649,0,"    public synchronized String encode(String password, String saltKey)throws NoSuchAlgorithmException, IOException {
        String encodedPassword = null;
        byte[] salt = base64ToByte(saltKey);

        MessageDigest digest = MessageDigest.getInstance(""SHA-256"");
        digest.reset();
        digest.update(salt);

        byte[] btPass = digest.digest(password.getBytes(""UTF-8""));
        for (int i = 0; i < ITERATION_COUNT; i++) {
            digest.reset();
            btPass = digest.digest(btPass);
        }

        encodedPassword = byteToBase64(btPass);
        return encodedPassword;
    }
",4
34533032,0,"        org.bouncycastle.asn1.pkcs.RSAPublicKey pkcs1PublicKey;
        try {
            pkcs1PublicKey = org.bouncycastle.asn1.pkcs.RSAPublicKey
                    .getInstance(pkcs1EncodedPublicKey);
        } catch (Exception e) {
            throw new IllegalArgumentException(
                    ""Could not parse BER PKCS#1 public key structure"", e);
        }

        // --- convert to JCE RSAPublicKey
        RSAPublicKeySpec spec = new RSAPublicKeySpec(
                pkcs1PublicKey.getModulus(), pkcs1PublicKey.getPublicExponent());
        KeyFactory rsaKeyFact;
        try {
            rsaKeyFact = KeyFactory.getInstance(""RSA"");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(""RSA KeyFactory should be available"", e);
        }
        try {
            return (RSAPublicKey) rsaKeyFact.generatePublic(spec);
        } catch (InvalidKeySpecException e) {
            throw new IllegalArgumentException(
                    ""Invalid RSA public key, modulus and/or exponent invalid"", e);
        }",3
34533032,0,"    private static void decryptBC(RSAPublicKey publicKey, String plainData,
            byte[] ciphertext) throws Exception {
        Cipher oaep = Cipher.getInstance(""RSA/ECB/OAEPWithSHA1AndMGF1Padding"", ""BC"");
        // this *should* fail
        oaep.init(Cipher.DECRYPT_MODE, publicKey);
        byte[] plaintext = oaep.doFinal(ciphertext);
        System.out.println(new String(plaintext, UTF_8));
    }
",3
34533032,0,"    private static void decryptSun(RSAPublicKey publicKey, String plainData,
            byte[] ciphertext) throws Exception {
        Cipher oaep = Cipher.getInstance(""RSA/ECB/OAEPWithSHA1AndMGF1Padding"", ""SunJCE"");
        // this fails beautifully
        oaep.init(Cipher.DECRYPT_MODE, publicKey);
        byte[] plaintext = oaep.doFinal(ciphertext);
        System.out.println(new String(plaintext, UTF_8));
    }
",3
34533032,0,"    private static void verifyBC(RSAPublicKey publicKey, String plainData,
            byte[] ciphertext) throws Exception {
        // what should work (for PKCS#1 v1.5 signatures), requires Bouncy Castle provider
        Signature sig = Signature.getInstance( ""SHA256withRSAandMGF1"");
        sig.initVerify(publicKey);
        sig.update(plainData.getBytes(UTF_8));
        System.out.println(sig.verify(ciphertext));
    }",4
34598687,0,"CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
// From https://www.washington.edu/itconnect/security/ca/load-der.crt

InputStream caInput = new BufferedInputStream(new FileInputStream(""load-   der.crt""));
Certificate ca;
try {
ca = cf.generateCertificate(caInput);
System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
} finally {
caInput.close();
}
",1
34687264,11,"        final TrustManager[] tms = tmfactory.getTrustManagers();
        if (tms != null) {
            if (trustStrategy != null) {
                for (int i = 0; i < tms.length; i++) {
                    final TrustManager tm = tms[i];
                    if (tm instanceof X509TrustManager) {
                        tms[i] = new TrustManagerDelegate(
                                (X509TrustManager) tm, trustStrategy);
                    }
                }
            }
            for (final TrustManager tm : tms) {
                this.trustmanagers.add(tm);
            }
        }
        return this;",1
34687264,11,"        Args.notNull(file, ""Truststore file"");
        final KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        final FileInputStream instream = new FileInputStream(file);
        try {
            trustStore.load(instream, storePassword);
        } finally {
            instream.close();
        }",-1
34687264,11,"        Args.notNull(url, ""Truststore URL"");
        final KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());
        final InputStream instream = url.openStream();
        try {
            trustStore.load(instream, storePassword);
        } finally {
            instream.close();
        }",2
34687264,11,"        final KeyManager[] kms =  kmfactory.getKeyManagers();
        if (kms != null) {
            if (aliasStrategy != null) {
                for (int i = 0; i < kms.length; i++) {
                    final KeyManager km = kms[i];
                    if (km instanceof X509ExtendedKeyManager) {
                        kms[i] = new KeyManagerDelegate((X509ExtendedKeyManager) km, aliasStrategy);
                    }
                }
            }
            for (final KeyManager km : kms) {
                keymanagers.add(km);
            }
        }
        return this;",1
34687264,11,"        Args.notNull(file, ""Keystore file"");
        final KeyStore identityStore = KeyStore.getInstance(KeyStore.getDefaultType());
        final FileInputStream instream = new FileInputStream(file);
        try {
            identityStore.load(instream, storePassword);
        } finally {
            instream.close();
        }",-1
34687264,11,"        Args.notNull(url, ""Keystore URL"");
        final KeyStore identityStore = KeyStore.getInstance(KeyStore.getDefaultType());
        final InputStream instream = url.openStream();
        try {
            identityStore.load(instream, storePassword);
        } finally {
            instream.close();
        }",2
34689286,0,"byte[] salt = new byte[16];
random.nextBytes(salt);
KeySpec spec = new PBEKeySpec(""password"".toCharArray(), salt, 65536, 128);
SecretKeyFactory f = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
byte[] hash = f.generateSecret(spec).getEncoded();",2
34769709,3,"        org.bouncycastle.asn1.pkcs.RSAPublicKey pkcs1PublicKey;
        try {
            pkcs1PublicKey = org.bouncycastle.asn1.pkcs.RSAPublicKey
                    .getInstance(pkcs1EncodedPublicKey);
        } catch (Exception e) {
            throw new IllegalArgumentException(
                    ""Could not parse BER PKCS#1 public key structure"", e);
        }

        // --- convert to JCE RSAPublicKey
        RSAPublicKeySpec spec = new RSAPublicKeySpec(
                pkcs1PublicKey.getModulus(), pkcs1PublicKey.getPublicExponent());
        KeyFactory rsaKeyFact;
        try {
            rsaKeyFact = KeyFactory.getInstance(""RSA"");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException(""RSA KeyFactory should be available"", e);
        }
        try {
            return (RSAPublicKey) rsaKeyFact.generatePublic(spec);
        } catch (InvalidKeySpecException e) {
            throw new IllegalArgumentException(
                    ""Invalid RSA public key, modulus and/or exponent invalid"", e);
        }",3
34769709,3,"    private static void verifyBC(PublicKey publicKey, String plainData,
            byte[] ciphertext) throws Exception {
        // what should work (for PKCS#1 v1.5 signatures), requires Bouncy Castle provider
        //Signature sig = Signature.getInstance( ""SHA256withRSAandMGF1"");
        Signature sig = Signature.getInstance( ""SHA256withRSA"");
        sig.initVerify(publicKey);
        sig.update(plainData.getBytes(UTF_8));
        System.out.println(sig.verify(ciphertext));
    }
",4
34965976,0,"    public static byte[] encrypt(final SecretKeySpec key, final byte[] iv, final byte[] message)
            throws GeneralSecurityException {
        final Cipher cipher = Cipher.getInstance(AES_MODE);
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, key);//, ivSpec
        byte[] cipherText = cipher.doFinal(message);
        log(""cipherText"", cipherText);
        return cipherText;
    }


    /**
     * Decrypt and decode ciphertext using 256-bit AES with key generated from password
     *
     * @param password used to generated key
     * @param base64EncodedCipherText the encrpyted message encoded with base64
     * @return message in Plain text (String UTF-8)
     * @throws GeneralSecurityException if there's an issue decrypting
     */",2
34965976,0,"    public static byte[] decrypt(final SecretKeySpec key, final byte[] iv, final byte[] decodedCipherText)
            throws GeneralSecurityException {
        final Cipher cipher = Cipher.getInstance(AES_MODE );
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.DECRYPT_MODE, key);//, ivSpec
        byte[] decryptedBytes = cipher.doFinal(decodedCipherText);
        log(""decryptedBytes"", decryptedBytes);
        return decryptedBytes;
    }



",2
34976571,0,"    System.out.println(""pack"");
    for(int i = 0; i < 4; i++)
    {
        System.out.println(pack[i]);
    }
    System.out.println("""");

    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");",3
34976571,0,"    System.out.println(""pack2"");
    for(int i = 0; i < 4; i++)
    {
        System.out.println(pack2[i]);
    }
    System.out.println("""");

    Cipher cip2 = Cipher.getInstance(""RSA"");",3
35000317,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
35082426,1,"KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
sr.setSeed(keyStart);
kgen.init(128, sr); 
SecretKey skey = kgen.generateKey();
byte[] key = skey.getEncoded();    

// encrypt",5
35132212,1,"    private SSLSocket _createSSLSocket(final String host, final TlsClientProtocol tlsClientProtocol) {
        return new SSLSocket() {
            private java.security.cert.Certificate[] peertCerts;

            @Override public InputStream getInputStream() throws IOException { return tlsClientProtocol.getInputStream(); }
            @Override public OutputStream getOutputStream() throws IOException { return tlsClientProtocol.getOutputStream(); }
            @Override public synchronized void close() throws IOException { tlsClientProtocol.close(); }
            @Override public void addHandshakeCompletedListener( HandshakeCompletedListener arg0) { }
            @Override public boolean getEnableSessionCreation() { return false; }
            @Override public String[] getEnabledCipherSuites() { return null; }
            @Override public String[] getEnabledProtocols() { return null; }
            @Override public boolean getNeedClientAuth() { return false; }

            @Override
            public SSLSession getSession() {
                return new SSLSession() {

                    @Override
                    public int getApplicationBufferSize() {
                        return 0;
                    }

                    @Override public String getCipherSuite() { throw new UnsupportedOperationException(); }
                    @Override public long getCreationTime() { throw new UnsupportedOperationException(); }
                    @Override public byte[] getId() { throw new UnsupportedOperationException(); }
                    @Override public long getLastAccessedTime() { throw new UnsupportedOperationException(); }
                    @Override public java.security.cert.Certificate[] getLocalCertificates() { throw new UnsupportedOperationException(); }
                    @Override public Principal getLocalPrincipal() { throw new UnsupportedOperationException(); }
                    @Override public int getPacketBufferSize() { throw new UnsupportedOperationException(); }
                    @Override public X509Certificate[] getPeerCertificateChain() throws SSLPeerUnverifiedException { return null; }
                    @Override public java.security.cert.Certificate[] getPeerCertificates() throws SSLPeerUnverifiedException { return peertCerts; }
                    @Override public String getPeerHost() { throw new UnsupportedOperationException(); }
                    @Override public int getPeerPort() { return 0; }
                    @Override public Principal getPeerPrincipal() throws SSLPeerUnverifiedException { return null; }
                    @Override public String getProtocol() { throw new UnsupportedOperationException(); }
                    @Override public SSLSessionContext getSessionContext() { throw new UnsupportedOperationException(); }
                    @Override public Object getValue(String arg0) { throw new UnsupportedOperationException(); }
                    @Override public String[] getValueNames() { throw new UnsupportedOperationException(); }
                    @Override public void invalidate() { throw new UnsupportedOperationException(); }
                    @Override public boolean isValid() { throw new UnsupportedOperationException(); }
                    @Override public void putValue(String arg0, Object arg1) { throw new UnsupportedOperationException(); }
                    @Override public void removeValue(String arg0) { throw new UnsupportedOperationException(); }
            };
        }

        @Override public String[] getSupportedProtocols() { return null; }
        @Override public boolean getUseClientMode() { return false; }
        @Override public boolean getWantClientAuth() { return false; }
        @Override public void removeHandshakeCompletedListener(HandshakeCompletedListener arg0) { }
        @Override public void setEnableSessionCreation(boolean arg0) { }
        @Override public void setEnabledCipherSuites(String[] arg0) { }
        @Override public void setEnabledProtocols(String[] arg0) { }
        @Override public void setNeedClientAuth(boolean arg0) { }
        @Override public void setUseClientMode(boolean arg0) { }
        @Override public void setWantClientAuth(boolean arg0) { }
        @Override public String[] getSupportedCipherSuites() { return null; }

            @Override
            public void startHandshake() throws IOException {
                tlsClientProtocol.connect(new DefaultTlsClient() {

                    @SuppressWarnings(""unchecked"")
                    @Override
                    public Hashtable<Integer, byte[]> getClientExtensions() throws IOException {
                        Hashtable<Integer, byte[]> clientExtensions = super.getClientExtensions();
                        if (clientExtensions == null) {
                            clientExtensions = new Hashtable<Integer, byte[]>();
                        }

                        //Add host_name
                        byte[] host_name = host.getBytes();

                        final ByteArrayOutputStream baos = new ByteArrayOutputStream();
                        final DataOutputStream dos = new DataOutputStream(baos);
                        dos.writeShort(host_name.length + 3);
                        dos.writeByte(0);
                        dos.writeShort(host_name.length);
                        dos.write(host_name);
                        dos.close();
                        clientExtensions.put(ExtensionType.server_name, baos.toByteArray());
                        return clientExtensions;
                    }

                    @Override
                    public TlsAuthentication getAuthentication() throws IOException {
                        return new TlsAuthentication() {

                            @Override
                            public void notifyServerCertificate(Certificate serverCertificate) throws IOException {
                                try {
                                    KeyStore ks = _loadKeyStore();

                                    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
                                    List<java.security.cert.Certificate> certs = new LinkedList<java.security.cert.Certificate>();
                                    boolean trustedCertificate = false;
                                    for ( org.bouncycastle.asn1.x509.Certificate c : serverCertificate.getCertificateList()) {
                                        java.security.cert.Certificate cert = cf.generateCertificate(new ByteArrayInputStream(c.getEncoded()));
                                        certs.add(cert);

                                        String alias = ks.getCertificateAlias(cert);
                                        if(alias != null) {
                                            if (cert instanceof java.security.cert.X509Certificate) {
                                                try {
                                                    ( (java.security.cert.X509Certificate) cert).checkValidity();
                                                    trustedCertificate = true;
                                                } catch(CertificateExpiredException cee) {
                                                   // Accept all the certs!
                                                }
                                            }
                                        } else {
                                            // Accept all the certs!
                                        }

                                    }
                                    if (!trustedCertificate) {
                                        // Accept all the certs!
                                    }
                                    peertCerts = certs.toArray(new java.security.cert.Certificate[0]);
                                } catch (Exception ex) {
                                    ex.printStackTrace();
                                    throw new IOException(ex);
                                }
                            }

                            @Override
                            public TlsCredentials getClientCredentials(CertificateRequest certificateRequest) throws IOException {
                                return null;
                            }

                            private KeyStore _loadKeyStore() throws Exception {
                                FileInputStream trustStoreFis = null;
                                try {
                                    KeyStore localKeyStore = null;

                                    String trustStoreType = System.getProperty(""javax.net.ssl.trustStoreType"")!=null?System.getProperty(""javax.net.ssl.trustStoreType""):KeyStore.getDefaultType();
                                    String trustStoreProvider = System.getProperty(""javax.net.ssl.trustStoreProvider"")!=null?System.getProperty(""javax.net.ssl.trustStoreProvider""):"""";

                                    if (trustStoreType.length() != 0) {
                                        if (trustStoreProvider.length() == 0) {
                                            localKeyStore = KeyStore.getInstance(trustStoreType);
                                        } else {
                                            localKeyStore = KeyStore.getInstance(trustStoreType, trustStoreProvider);
                                        }

                                        char[] keyStorePass = null;
                                        String str5 = System.getProperty(""javax.net.ssl.trustStorePassword"")!=null?System.getProperty(""javax.net.ssl.trustStorePassword""):"""";

                                        if (str5.length() != 0) {
                                            keyStorePass = str5.toCharArray();
                                        }

                                        localKeyStore.load(trustStoreFis, keyStorePass);

                                        if (keyStorePass != null) {
                                            for (int i = 0; i < keyStorePass.length; i++) {
                                                keyStorePass[i] = 0;
                                            }
                                        }
                                    }
                                    return localKeyStore;
                                } finally {
                                    if (trustStoreFis != null) {
                                        trustStoreFis.close();
                                    }
                                }
                            }
                        };
                    }

                });
            } // startHandshake
        };
    }",1
35202220,0,"public class sample{
public static void printHashKey(Context pContext) {
    try {
        PackageInfo info = getPackageInfo(pContext, PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String hashKey = new String(Base64.encode(md.digest(), 0));
            Log.i(TAG, ""printHashKey() Hash Key: "" + hashKey);
        }
    } catch (NoSuchAlgorithmException e) {
        Log.e(TAG, ""printHashKey()"", e);
    } catch (Exception e) {
        Log.e(TAG, ""printHashKey()"", e);
    }
}
",4
35202220,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String hashKey = new String(Base64.encode(md.digest(), 0));
            Log.i(TAG, ""printHashKey() Hash Key: "" + hashKey);
        }",4
35246273,0,"    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
35571883,0,"public class EasyX509TrustManager
    implements X509TrustManager {

private X509TrustManager standardTrustManager = null;

/**
 * Constructor for EasyX509TrustManager.
 */
public EasyX509TrustManager(KeyStore keystore)
        throws NoSuchAlgorithmException, KeyStoreException {
    super();
    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keystore);
    TrustManager[] trustmanagers = factory.getTrustManagers();
    if (trustmanagers.length == 0) {
        throw new NoSuchAlgorithmException(""no trust manager found"");
    }
    this.standardTrustManager = (X509TrustManager) trustmanagers[0];
}

/**
 * @see X509TrustManager#checkClientTrusted(X509Certificate[], String authType)
 */
public void checkClientTrusted(X509Certificate[] certificates, String authType)
        throws CertificateException {
    standardTrustManager.checkClientTrusted(certificates, authType);
}

/**
 * @see X509TrustManager#checkServerTrusted(X509Certificate[], String authType)
 */
public void checkServerTrusted(X509Certificate[] certificates, String authType)
        throws CertificateException {
    if ((certificates != null) && (certificates.length == 1)) {
        certificates[0].checkValidity();
    } else {
        standardTrustManager.checkServerTrusted(certificates, authType);
    }
}

/**
 * @see X509TrustManager#getAcceptedIssuers()
 */
public X509Certificate[] getAcceptedIssuers() {
    return this.standardTrustManager.getAcceptedIssuers();
}

}",1
35571883,0,"    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    factory.init(keystore);
    TrustManager[] trustmanagers = factory.getTrustManagers();
    if (trustmanagers.length == 0) {
        throw new NoSuchAlgorithmException(""no trust manager found"");
    }
    this.standardTrustManager = (X509TrustManager) trustmanagers[0];",1
35571883,1,"    SSLSocket sslsock = (SSLSocket) ((sock != null) ? sock : createSocket());

    if ((localAddress != null) || (localPort > 0)) {
        // we need to bind explicitly
        if (localPort < 0) {
            localPort = 0; // indicates ""any""
        }
        InetSocketAddress isa = new InetSocketAddress(localAddress,
                localPort);
        sslsock.bind(isa);
    }
",1
35571883,1,"public Socket createSocket(Socket socket, String host, int port,
                           boolean autoClose) throws IOException, UnknownHostException {
    return getSSLContext().getSocketFactory().createSocket(socket, host, port, autoClose);
}

// -------------------------------------------------------------------
// javadoc in org.apache.http.conn.scheme.SocketFactory says :
// Both Object.equals() and Object.hashCode() must be overridden
// for the correct operation of some connection managers
// -------------------------------------------------------------------

public boolean equals(Object obj) {
    return ((obj != null) && obj.getClass().equals(
            EasySSLSocketFactory.class));
}

public int hashCode() {
    return EasySSLSocketFactory.class.hashCode();
}
",1
35576792,14,"    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }",4
35603880,0,"            } finally {
                caInput.close();
            }

            /** Create a KeyStore containing our trusted CAs **/
            String keyStoreType = KeyStore.getDefaultType();
            KeyStore keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            keyStore.setCertificateEntry(""ca"", ca);

            /**Create a TrustManager that trusts the CAs in our KeyStore **/",1
35603880,0,"            } finally {
                caInput.close();
            }

            /** Create a KeyStore containing our trusted CAs **/
            String keyStoreType = KeyStore.getDefaultType();
            KeyStore keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            keyStore.setCertificateEntry(""ca"", ca);

            /**Create a TrustManager that trusts the CAs in our KeyStore **/
            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
            tmf.init(keyStore);

            /** Create an SSLContext that uses our TrustManager **/",1
35653636,3,"expand.init(new SecretKeySpec(prk, ""HmacSHA256""));
String info = ""Content-Encoding: aesgcm128"";
expand.update(info.getBytes(StandardCharsets.US_ASCII));
expand.update((byte)1);
final byte[] key_bytes = expand.doFinal();

// Use the result",4
35692802,0,"            byte[] b = new byte[1024];
            int bytesRead = 0;
            while ((bytesRead = mFileInputStream.read(b)) != -1) {
               bos.write(b, 0, bytesRead);
            }
            byte[] ba = bos.toByteArray();",4
35739960,0,"        publicKeyPEM = publicKeyPEM.replace(""-----BEGIN PUBLIC KEY-----\n"", """");
        publicKeyPEM = publicKeyPEM.replace(""-----END PUBLIC KEY-----"", """");
        BASE64Decoder base64Decoder = new BASE64Decoder();
        byte[] publicKeyBytes = base64Decoder.decodeBuffer(publicKeyPEM);

        // create a key object from the bytes
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKeyBytes);",3
35751778,0,"        if(privateKey != null)
        {

            File privKeyFile = new File(System.getProperty(""user.home"") + ""/.etc/privkey"");

            if(!privKeyFile.exists())
            {
                privKeyFile.createNewFile();
            }

            System.out.println(""private key: "" + Base64.getEncoder().encodeToString(kp.getPrivate().getEncoded()));

            RSAPrivateKeySpec pubSpec = kf.getKeySpec(kp.getPrivate(), RSAPrivateKeySpec.class);

            ObjectOutputStream oout = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(System.getProperty(""user.home"") + ""/.etc/privkey"")));

            oout.writeObject(pubSpec.getModulus());

            oout.writeObject(pubSpec.getPrivateExponent());

            oout.close();

",3
35751778,0,"        }if(publicKey != null)
        {

            File pubKeyFile = new File(System.getProperty(""user.home"") + ""/.etc/pubkey.pub"");

            if(!pubKeyFile.exists())
            {
                pubKeyFile.createNewFile();
            }

            System.out.println(""public key: "" + Base64.getEncoder().encodeToString(kp.getPublic().getEncoded()));

            RSAPublicKeySpec pubSpec = kf.getKeySpec(kp.getPublic(), RSAPublicKeySpec.class);

            ObjectOutputStream oout = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(System.getProperty(""user.home"") + ""/.etc/pubkey.pub"")));

            oout.writeObject(pubSpec.getModulus());

            oout.writeObject(pubSpec.getPublicExponent());

            oout.close();

        }


",3
35765334,0,"public class sample{
// I placed this block right below my class declaration so it runs
// as soon as the class is defined. (this is for localhost testing ONLY!!!!)    
static {
    //for localhost testing only
    javax.net.ssl.HttpsURLConnection.setDefaultHostnameVerifier(
    new javax.net.ssl.HostnameVerifier(){

        public boolean verify(String hostname,
                javax.net.ssl.SSLSession sslSession) {
            if (hostname.equals(""localhost"")) {
                return true;
            }
            return false;
        }
    });
}

// then in an init function, I set it all up here
this.secureAppServer = new NanoHTTPD(9043);
File f =new File(""src/main/resources/key001.jks"");
System.setProperty(""javax.net.ssl.trustStore"", f.getAbsolutePath());
this.secureAppServer.setServerSocketFactory(new SecureServerSocketFactory(NanoHTTPD.makeSSLSocketFactory(""/"" +f.getName(), ""myawesomepassword"".toCharArray()), null));

this.secureAppServer.start();
",1
35773340,1,"SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.ENCRYPT_MODE, secret, new IvParameterSpec(iv));",2
35826825,1,"    public NoSSLv3SocketFactory(SSLSocketFactory delegate) {
        this.delegate = delegate;
    }

    @Override
    public String[] getDefaultCipherSuites() {
        return delegate.getDefaultCipherSuites();
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return delegate.getSupportedCipherSuites();
    }

    private Socket makeSocketSafe(Socket socket) {
        if (socket instanceof SSLSocket) {
            socket = new NoSSLv3SSLSocket((SSLSocket) socket);
        }
        return socket;
    }

    @Override
    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
    }

    private class NoSSLv3SSLSocket extends DelegateSSLSocket {

        private NoSSLv3SSLSocket(SSLSocket delegate) {
            super(delegate);

        }

        @Override
        public void setEnabledProtocols(String[] protocols) {
            if (protocols != null && protocols.length == 1 && ""SSLv3"".equals(protocols[0])) {

                List<String> enabledProtocols = new ArrayList<String>(Arrays.asList(delegate.getEnabledProtocols()));
                if (enabledProtocols.size() > 1) {
                    enabledProtocols.remove(""SSLv3"");
                    System.out.println(""Removed SSLv3 from enabled protocols"");
                } else {
                    System.out.println(""SSL stuck with protocol available for "" + String.valueOf(enabledProtocols));
                }
                protocols = enabledProtocols.toArray(new String[enabledProtocols.size()]);
            }
",1
35826825,1,"    private Socket makeSocketSafe(Socket socket) {
        if (socket instanceof SSLSocket) {
            socket = new NoSSLv3SSLSocket((SSLSocket) socket);
        }
        return socket;
    }

    @Override
    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
    }
",1
35826825,1,"    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
    }
",1
35826825,1,"    public Socket createSocket(String host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
    }

    @Override",1
35830788,0,"PEMParser pemParser = new PEMParser(new FileReader(file));
Object object = pemParser.readObject();
if (object instanceof X509CertificateHolder) {
    X509CertificateHolder holder = (X509CertificateHolder)object;
    cert = new JcaX509CertificateConverter().setProvider(""BC"").getCertificate(holder);
}",1
35830788,2,"    PEMParser pemParser = new PEMParser(new StringReader(cert1));
    Object object = pemParser.readObject();
    if (object instanceof X509CertificateHolder) {
        X509CertificateHolder holder = (X509CertificateHolder)object;
        cert = new JcaX509CertificateConverter().setProvider(""BC"").getCertificate(holder);
    }",1
35848742,0,"    byte[] bytes = bundle.getByteArray(""x509-certificate"");
    if (bytes == null) {
        certificate = null;
    } else {
        try {
            CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            Certificate cert = certFactory.generateCertificate(new ByteArrayInputStream(bytes));
            certificate = (X509Certificate) cert;
        } catch (CertificateException e) {
            certificate = null;
        }
    }",2
35858045,0,"    byte[] bytes = bundle.getByteArray(""x509-certificate"");

    if (bytes == null) {
        x509Certificate = null;
    } else {
        try {
            CertificateFactory certFactory = CertificateFactory.getInstance(""X.509"");
            Certificate cert = certFactory.generateCertificate(new ByteArrayInputStream(bytes));
            x509Certificate = (X509Certificate) cert;
        } catch (CertificateException e) {
            x509Certificate = null;
        }
    }
",2
35883207,1,"    private static void doForth() throws Exception {
        KeyStore ks = KeyStore.getInstance(KEYSTORE_TYPE, ""BC"");
        ks.load(new FileInputStream(KEYSTORE_FILE), KEYSTORE_PWD);
        X500PrivateCredential creds = new X500PrivateCredential(
                (X509Certificate) ks.getCertificate(KEYSTORE_ALIAS),
                (PrivateKey) ks.getKey(KEYSTORE_ALIAS, KEYSTORE_PWD)
        );
        createSignature(CONTENT_SRC_PATH, creds, new FileOutputStream(SIGNEDDATA_TARGET_PATH.toFile()));
    }
",3
35883207,1,"        CMSSignedDataGenerator gen = new CMSSignedDataGenerator() {
            {
                addSignerInfoGenerator(
                        new JcaSignerInfoGeneratorBuilder(
                                new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build()
                        ).build(
                                new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(creds.getPrivateKey()),
                                creds.getCertificate()
                        )
                );
                addCertificates(new JcaCertStore(new ArrayList<X509Certificate>() {
                    {
                        add(creds.getCertificate());
                    }
                }));
            }
        };
        // Build CMS",4
35883207,7,"private static void createSignature(Path srcfile, X500PrivateCredential creds, FileOutputStream target) throws Exception {                
    CMSSignedDataStreamGenerator gen = new CMSSignedDataStreamGenerator() {
        {
            addSignerInfoGenerator(
                    new JcaSignerInfoGeneratorBuilder(
                            new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build()
                    ).build(
                            new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(creds.getPrivateKey()),
                            creds.getCertificate()
                    )
            );
            addCertificates(new JcaCertStore(new ArrayList<X509Certificate>() {
                {
                    add(creds.getCertificate());
                }
            }));
        }
    };
    try (OutputStream sigOut = gen.open(target, true)) {
        Files.copy(srcfile, sigOut);
    }
}
",4
35883207,7,"    CMSSignedDataStreamGenerator gen = new CMSSignedDataStreamGenerator() {
        {
            addSignerInfoGenerator(
                    new JcaSignerInfoGeneratorBuilder(
                            new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build()
                    ).build(
                            new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(creds.getPrivateKey()),
                            creds.getCertificate()
                    )
            );
            addCertificates(new JcaCertStore(new ArrayList<X509Certificate>() {
                {
                    add(creds.getCertificate());
                }
            }));
        }
    };",4
35883207,8,"    private static void doForth() throws Exception {
        KeyStore ks = KeyStore.getInstance(KEYSTORE_TYPE, ""BC"");
        ks.load(new FileInputStream(KEYSTORE_FILE), KEYSTORE_PWD);
        X500PrivateCredential creds = new X500PrivateCredential(
                (X509Certificate) ks.getCertificate(KEYSTORE_ALIAS),
                (PrivateKey) ks.getKey(KEYSTORE_ALIAS, KEYSTORE_PWD)
        );
        createSignature(CONTENT_SRC_PATH, creds, new FileOutputStream(SIGNEDDATA_TARGET_PATH.toFile()));
    }
",3
35883207,8,"    private static void createSignature(Path srcfile, X500PrivateCredential creds, FileOutputStream target) throws Exception {                
        CMSSignedDataStreamGenerator gen = new CMSSignedDataStreamGenerator() {
            {
                addSignerInfoGenerator(
                        new JcaSignerInfoGeneratorBuilder(
                                new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build()
                        ).build(
                                new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(creds.getPrivateKey()),
                                creds.getCertificate()
                        )
                );
                addCertificates(new JcaCertStore(new ArrayList<X509Certificate>() {
                    {
                        add(creds.getCertificate());
                    }
                }));
            }
        };
        try (OutputStream sigOut = gen.open(target, true)) {
            Files.copy(srcfile, sigOut);
        }
    }",4
35883207,8,"        CMSSignedDataStreamGenerator gen = new CMSSignedDataStreamGenerator() {
            {
                addSignerInfoGenerator(
                        new JcaSignerInfoGeneratorBuilder(
                                new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build()
                        ).build(
                                new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(creds.getPrivateKey()),
                                creds.getCertificate()
                        )
                );
                addCertificates(new JcaCertStore(new ArrayList<X509Certificate>() {
                    {
                        add(creds.getCertificate());
                    }
                }));
            }
        };",4
35885436,3,"    private static void doForth() throws Exception {
        KeyStore ks = KeyStore.getInstance(KEYSTORE_TYPE, ""BC"");
        ks.load(new FileInputStream(KEYSTORE_FILE), KEYSTORE_PWD);
        X500PrivateCredential creds = new X500PrivateCredential(
                (X509Certificate) ks.getCertificate(KEYSTORE_ALIAS),
                (PrivateKey) ks.getKey(KEYSTORE_ALIAS, KEYSTORE_PWD)
        );
        createSignature(CONTENT_SRC_PATH, creds, new FileOutputStream(SIGNEDDATA_TARGET_PATH.toFile()));
    }
",3
35885436,3,"    private static void createSignature(Path srcfile, X500PrivateCredential creds, FileOutputStream target) throws Exception {
        CMSSignedDataStreamGenerator gen = new CMSSignedDataStreamGenerator() {
            {
                addSignerInfoGenerator(
                        new JcaSignerInfoGeneratorBuilder(
                                new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build()
                        ).build(
                                new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(creds.getPrivateKey()),
                                creds.getCertificate()
                        )
                );
                addCertificates(new JcaCertStore(new ArrayList<X509Certificate>() {
                    {
                        add(creds.getCertificate());
                    }
                }));
            }
        };
        try (OutputStream sigOut = gen.open(target, true)) {
            Files.copy(srcfile, sigOut);
        }
    }",4
35885436,3,"        CMSSignedDataStreamGenerator gen = new CMSSignedDataStreamGenerator() {
            {
                addSignerInfoGenerator(
                        new JcaSignerInfoGeneratorBuilder(
                                new JcaDigestCalculatorProviderBuilder().setProvider(""BC"").build()
                        ).build(
                                new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(creds.getPrivateKey()),
                                creds.getCertificate()
                        )
                );
                addCertificates(new JcaCertStore(new ArrayList<X509Certificate>() {
                    {
                        add(creds.getCertificate());
                    }
                }));
            }
        };",4
35898003,0,"KeyStore lKeyStore = KeyStore.getInstance( KeyStore.getDefaultType() );
InputStream lISKeyStore = new FileInputStream( new File( ""C:/Security/ssl.keystore"" ) );
try
{
  lKeyStore.load( lISKeyStore, ""MyPassword"".toCharArray() );
}
finally
{
  lISKeyStore.close();
}
KeyManagerFactory lKeyManagerFactory = KeyManagerFactory.getInstance( KeyManagerFactory.getDefaultAlgorithm() );",1
35898003,0,"KeyStore lTrustStore = KeyStore.getInstance(KeyStore.getDefaultType());
InputStream lIStrustStore = new FileInputStream( new File( ""C:/Security/ssl.truststore"" ) );
try
{
  lTrustStore.load(lIStrustStore, ""MyPassword"".toCharArray() );
}
finally
{
  lIStrustStore.close();
}

TrustManagerFactory lTrustManagerFactory = TrustManagerFactory.getInstance( TrustManagerFactory.getDefaultAlgorithm() );",1
35982099,1,"public class sample{
public String encode(String key, String data) {
    try {

        Mac sha256_HMAC = Mac.getInstance(""HmacSHA256"");
        SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(""UTF-8""), ""HmacSHA256"");
        sha256_HMAC.init(secret_key);

        return new String(Hex.encodeHex(sha256_HMAC.doFinal(data.getBytes(""UTF-8""))));

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }

    return null;
}
",4
35982099,1,"    try {

        Mac sha256_HMAC = Mac.getInstance(""HmacSHA256"");
        SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(""UTF-8""), ""HmacSHA256"");
        sha256_HMAC.init(secret_key);

        return new String(Hex.encodeHex(sha256_HMAC.doFinal(data.getBytes(""UTF-8""))));
",4
35982128,1,"public class sample{
public String encode(String key, String data) {
    try {

        Mac sha256_HMAC = Mac.getInstance(""HmacSHA256"");
        SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(""UTF-8""), ""HmacSHA256"");
        sha256_HMAC.init(secret_key);

        return new String(Hex.encodeHex(sha256_HMAC.doFinal(data.getBytes(""UTF-8""))));

    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (UnsupportedEncodingException e) {
        e.printStackTrace();
    }

    return null;
}
",4
35982128,1,"    try {

        Mac sha256_HMAC = Mac.getInstance(""HmacSHA256"");
        SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(""UTF-8""), ""HmacSHA256"");
        sha256_HMAC.init(secret_key);

        return new String(Hex.encodeHex(sha256_HMAC.doFinal(data.getBytes(""UTF-8""))));
",4
36006338,0,"public class sample{
public static String encode(String key, String data) throws Exception {
    Mac sha256_HMAC = Mac.getInstance(""HmacSHA256"");
    SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(""UTF-8""), ""HmacSHA256"");
    sha256_HMAC.init(secret_key);

    return Hex.encodeHexString(sha256_HMAC.doFinal(data.getBytes(""UTF-8"")));
}
",4
36009795,0,"    HostnameVerifier hv = new HostnameVerifier() {
        @Override
        public boolean verify(String urlHostName, SSLSession session) {
            if (!urlHostName.equalsIgnoreCase(session.getPeerHost())) {
                logger.warn(""Warning: URL host '"" + urlHostName + ""' is different to SSLSession host '"" + session.getPeerHost() + ""'."");
            }
            return true;
        }",1
36021145,5,"public class sample{
public KeyStore getKeyStore() {
    try {
        return KeyStore.getInstance(""AndroidKeyStore"");
    } catch (KeyStoreException exception) {
        throw new RuntimeException(""Failed to get an instance of KeyStore"", exception);
    }
}

public KeyPairGenerator getKeyPairGenerator() {
    try {
        return KeyPairGenerator.getInstance(""RSA"", ""AndroidKeyStore"");
    } catch(NoSuchAlgorithmException | NoSuchProviderException exception) {
        throw new RuntimeException(""Failed to get an instance of KeyPairGenerator"", exception);
    }
}

public Cipher getCipher() {
    try {
        return Cipher.getInstance(""RSA/ECB/OAEPWithSHA-256AndMGF1Padding"");
    } catch(NoSuchAlgorithmException | NoSuchPaddingException exception) {
        throw new RuntimeException(""Failed to get an instance of Cipher"", exception);
    }
}

private void createKeyPair() {
    try {
        mKeyPairGenerator.initialize(
                new KeyGenParameterSpec.Builder(KEY_ALIAS, KeyProperties.PURPOSE_DECRYPT)
                        .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_OAEP)
                        .setUserAuthenticationRequired(true)
                        .build());
        mKeyPairGenerator.generateKeyPair();
    } catch(InvalidAlgorithmParameterException exception) {
        throw new RuntimeException(""Failed to generate key pair"", exception);
    }
}

private boolean initCipher(int opmode) {
    try {
        mKeyStore.load(null);

        if(opmode == Cipher.ENCRYPT_MODE) {
            PublicKey key = mKeyStore.getCertificate(KEY_ALIAS).getPublicKey();

            PublicKey unrestricted = KeyFactory.getInstance(key.getAlgorithm())
                    .generatePublic(new X509EncodedKeySpec(key.getEncoded()));

            OAEPParameterSpec spec = new OAEPParameterSpec(
                    ""SHA-256"", ""MGF1"", MGF1ParameterSpec.SHA1, PSource.PSpecified.DEFAULT);

            mCipher.init(opmode, unrestricted, spec);
        } else {
            PrivateKey key = (PrivateKey) mKeyStore.getKey(KEY_ALIAS, null);
            mCipher.init(opmode, key);
        }

        return true;
    } catch (KeyPermanentlyInvalidatedException exception) {
        return false;
    } catch(KeyStoreException | CertificateException | UnrecoverableKeyException
            | IOException | NoSuchAlgorithmException | InvalidKeyException
            | InvalidAlgorithmParameterException exception) {
        throw new RuntimeException(""Failed to initialize Cipher"", exception);
    }
}

private void encrypt(String password) {
    try {
        initCipher(Cipher.ENCRYPT_MODE);
        byte[] bytes = mCipher.doFinal(password.getBytes());
        String encrypted = Base64.encodeToString(bytes, Base64.NO_WRAP);
        mPreferences.getString(""password"").set(encrypted);
    } catch(IllegalBlockSizeException | BadPaddingException exception) {
        throw new RuntimeException(""Failed to encrypt password"", exception);
    }
}

private String decrypt(Cipher cipher) {
    try {
        String encoded = mPreferences.getString(""password"").get();
        byte[] bytes = Base64.decode(encoded, Base64.NO_WRAP);
        return new String(cipher.doFinal(bytes));
    } catch (IllegalBlockSizeException | BadPaddingException exception) {
        throw new RuntimeException(""Failed to decrypt password"", exception);
    }
}
",3
36022815,0,"public class sample{
 public void foo(){
KeyPairGenerator kpg = KeyPairGenerator.getInstance(
        KeyProperties.KEY_ALGORITHM_RSA, ""AndroidKeyStore"");
kpg.initialize(new KeyGenParameterSpec.Builder(
        ""mykey"", KeyProperties.PURPOSE_SIGN)
        .setDigests(KeyProperties.DIGEST_SHA256)
        .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PSS)
        .build());

}",3
36129174,0,"        expand.init(new SecretKeySpec(prk, ""HmacSHA256""));

        //aes algorithm
        String info = ""Content-Encoding: aesgcm128"";
        expand.update(info.getBytes(StandardCharsets.US_ASCII));
        expand.update((byte) 1);
        final byte[] key_bytes = expand.doFinal();",4
36129174,0,"        expand.init(new SecretKeySpec(prk, ""HmacSHA256""));
        String nonceinfo = ""Content-Encoding: nonce"";
        expand.update(nonceinfo.getBytes(StandardCharsets.US_ASCII));
        expand.update((byte) 1);
        final byte[] nonce_bytes = expand.doFinal();",4
36129174,0,"        final BigInteger x = new BigInteger(1, Arrays.copyOfRange(
                uncompressedPoint, offset, offset + keySizeBytes));
        offset += keySizeBytes;
        final BigInteger y = new BigInteger(1, Arrays.copyOfRange(
                uncompressedPoint, offset, offset + keySizeBytes));
        final ECPoint w = new ECPoint(x, y);
        final ECPublicKeySpec ecPublicKeySpec = new ECPublicKeySpec(w, params);
        final KeyFactory keyFactory = KeyFactory.getInstance(""EC"");",3
36149674,1,"                for (Signature signature : info.signatures) {
                    MessageDigest md = MessageDigest.getInstance(""SHA"");
                    md.update(signature.toByteArray());
                    Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                    }",4
36152757,1,"if (websocketEndPointUrl.indexOf(""wss"") == 0) 
{
    try {
        SSLContext sslContext = SSLContext.getDefault();
        mWebSocketClient.setWebSocketFactory(new DefaultSSLWebSocketClientFactory(sslContext));
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    }
} 

mWebSocketClient.connect();
",1
36162946,3,"public class Sha256hash 
{

    public static String generate(String input) throws NoSuchAlgorithmException 
    {
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
            md.reset();
            byte[] buffer = input.getBytes(""UTF-8"");
            md.update(buffer);
            byte[] digest = md.digest();

            String hexStr = """";
            for (int i = 0; i < digest.length; i++) {
                hexStr +=  Integer.toString( ( digest[i] & 0xff ) + 0x100, 16).substring( 1 );
            }
            return hexStr;
    }

}",4
36162946,6,"public class Sha256hash 
{

    public static String generate(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException 
    {
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
            md.reset();
            byte[] buffer = input.getBytes(""UTF-8"");
            md.update(buffer);
            byte[] digest = md.digest();

            String hexStr = """";
            for (int i = 0; i < digest.length; i++) {
                hexStr +=  Integer.toString( ( digest[i] & 0xff ) + 0x100, 16).substring( 1 );
            }
            return hexStr;
    }

}",4
36302749,0,"        mac = Mac.getInstance( ""HmacSHA512"" );
        mac.init( secretKey );
        final byte[] macData = mac.doFinal( datas.getBytes( ) );
        byte[] hex = new Hex( ).encode( macData );
        result = new String( hex, ""ISO-8859-1"" );",4
36330582,0,"public class sample{
 public void foo(){
OkHttpClient client = new OkHttpClient();
SSLContext sslContext = SslUtils.getSslContextForCertificateFile(context, ""BPClass2RootCA-sha2.cer"");
client.setSslSocketFactory(sslContext.getSocketFactory());

}",1
36330656,0,"public class sample{
 public void foo(){
OkHttpClient client = new OkHttpClient();
SSLContext sslContext = SslUtils.getSslContextForCertificateFile(context, ""BPClass2RootCA-sha2.cer"");
client.setSslSocketFactory(sslContext.getSocketFactory());

}",1
36383069,2,"public class sample{
/**
 * Encode PublicKey (DSA or RSA encoded) to authorized_keys like string
 *
 * @param publicKey DSA or RSA encoded
 * @param user username for output authorized_keys like string
 * @return authorized_keys like string
 * @throws IOException
 */
public static String encodePublicKey(PublicKey publicKey, String user)
        throws IOException {
    String publicKeyEncoded;
    if(publicKey.getAlgorithm().equals(""RSA"")){
        RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
        ByteArrayOutputStream byteOs = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(byteOs);
        dos.writeInt(""ssh-rsa"".getBytes().length);
        dos.write(""ssh-rsa"".getBytes());
        dos.writeInt(rsaPublicKey.getPublicExponent().toByteArray().length);
        dos.write(rsaPublicKey.getPublicExponent().toByteArray());
        dos.writeInt(rsaPublicKey.getModulus().toByteArray().length);
        dos.write(rsaPublicKey.getModulus().toByteArray());
        publicKeyEncoded = new String(
                Base64.encodeBase64(byteOs.toByteArray()));
        return ""ssh-rsa "" + publicKeyEncoded + "" "" + user;
    }
    else if(publicKey.getAlgorithm().equals(""DSA"")){
        DSAPublicKey dsaPublicKey = (DSAPublicKey) publicKey;
        DSAParams dsaParams = dsaPublicKey.getParams();

        ByteArrayOutputStream byteOs = new ByteArrayOutputStream();
        DataOutputStream dos = new DataOutputStream(byteOs);
        dos.writeInt(""ssh-dss"".getBytes().length);
        dos.write(""ssh-dss"".getBytes());
        dos.writeInt(dsaParams.getP().toByteArray().length);
        dos.write(dsaParams.getP().toByteArray());
        dos.writeInt(dsaParams.getQ().toByteArray().length);
        dos.write(dsaParams.getQ().toByteArray());
        dos.writeInt(dsaParams.getG().toByteArray().length);
        dos.write(dsaParams.getG().toByteArray());
        dos.writeInt(dsaPublicKey.getY().toByteArray().length);
        dos.write(dsaPublicKey.getY().toByteArray());
        publicKeyEncoded = new String(
                Base64.encodeBase64(byteOs.toByteArray()));
        return ""ssh-dss "" + publicKeyEncoded + "" "" + user;
    }
    else{
        throw new IllegalArgumentException(
                ""Unknown public key encoding: "" + publicKey.getAlgorithm());
    }
}
",3
36383069,2,"        dos.writeInt(rsaPublicKey.getModulus().toByteArray().length);
        dos.write(rsaPublicKey.getModulus().toByteArray());
        publicKeyEncoded = new String(
                Base64.encodeBase64(byteOs.toByteArray()));
        return ""ssh-rsa "" + publicKeyEncoded + "" "" + user;",3
36383069,2,"        dos.writeInt(dsaPublicKey.getY().toByteArray().length);
        dos.write(dsaPublicKey.getY().toByteArray());
        publicKeyEncoded = new String(
                Base64.encodeBase64(byteOs.toByteArray()));
        return ""ssh-dss "" + publicKeyEncoded + "" "" + user;",3
36459647,1,"    } catch (Exception e) {
        throw new RuntimeException(e);
    }

    for (TrustManagerFactory tmf : factories) {
        for (TrustManager tm : tmf.getTrustManagers()) {
            if (tm instanceof X509TrustManager) {
                x509TrustManagers.add((X509TrustManager) tm);
            }
        }
    }
",1
36459647,1,"public X509Certificate[] getAcceptedIssuers() {
    final ArrayList<X509Certificate> list = new ArrayList<X509Certificate>();

    for( X509TrustManager tm : x509TrustManagers ) {
        list.addAll(Arrays.asList(tm.getAcceptedIssuers()));
    }

    return list.toArray(new X509Certificate[list.size()]);
}

",1
36461989,0,"            byte[] key = encodekey.getBytes(""UTF-8"");
            MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
            key = sha.digest(key);
            key = Arrays.copyOf(key, 16); // use only first 128 bit

            SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");

            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
",4
36461989,0,"            byte[] key = encodekey.getBytes(""UTF-8"");
            MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
            key = sha.digest(key);
            key = Arrays.copyOf(key, 16); // use only first 128 bit

            SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");

            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
",4
36461989,0,"              byte[] key = encodekey.getBytes(""UTF-8"");
              MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
              key = sha.digest(key);
              key = Arrays.copyOf(key, 16); // use only first 128 bit

              SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");

              dcipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
            // decode with base64 to get bytes
",4
36461989,0,"              byte[] key = encodekey.getBytes(""UTF-8"");
              MessageDigest sha = MessageDigest.getInstance(""SHA-1"");
              key = sha.digest(key);
              key = Arrays.copyOf(key, 16); // use only first 128 bit

              SecretKeySpec secretKeySpec = new SecretKeySpec(key, ""AES"");

              dcipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
            // decode with base64 to get bytes
",4
36461989,0,"              dcipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
            // decode with base64 to get bytes

              byte[] dec = Base64Utils.decode(encrptedStr.getBytes());  
              byte[] utf8 = dcipher.doFinal(dec);

              // create new string based on the specified charset
              return new String(utf8, ""UTF8"");
",2
36463724,0,"        KeyStore ks = KeyStore.getInstance(""JKS"");
        ks.load(keyStore.getInputStream(), keyStorePass.toCharArray());
        logger.info(""Loaded keyStore: ""+keyStore.getURI().toString());
        try { keyStore.getInputStream().close(); } catch(IOException e) {}
        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());",-1
36463724,0,"        KeyStore ts = KeyStore.getInstance(""JKS"");
        ts.load(trustStore.getInputStream(), trustStorePass.toCharArray());
        logger.info(""Loaded trustStore: ""+trustStore.getURI().toString());
        try { trustStore.getInputStream().close(); } catch(IOException e) {}
        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());",-1
36648437,0,"public class sample{
public byte[] signMobileConfig(byte[] mobileconfig) 
        throws CertificateEncodingException, PEMException, FileNotFoundException, IOException, CertificateException, OperatorCreationException, CMSException {
    Security.addProvider(new BouncyCastleProvider());

    X509CertificateHolder caCertificate = loadCertfile();

    JcaX509CertificateConverter certificateConverter = new JcaX509CertificateConverter();
    X509Certificate serverCertificate = certificateConverter.getCertificate(loadSigner());

    PrivateKeyInfo privateKeyInfo = loadInKey();
    PrivateKey inKey = new JcaPEMKeyConverter().getPrivateKey(privateKeyInfo);
    ContentSigner sha1Signer = new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(inKey);

    CMSSignedDataGenerator generator = new CMSSignedDataGenerator();
    JcaDigestCalculatorProviderBuilder digestProviderBuilder = new JcaDigestCalculatorProviderBuilder().setProvider(""BC"");
    JcaSignerInfoGeneratorBuilder generatotBuilder = new JcaSignerInfoGeneratorBuilder(digestProviderBuilder.build());

    generator.addSignerInfoGenerator(generatotBuilder.build(sha1Signer, serverCertificate));
    generator.addCertificate(new X509CertificateHolder(serverCertificate.getEncoded()));
    generator.addCertificate(new X509CertificateHolder(caCertificate.getEncoded()));

    CMSProcessableByteArray bytes = new CMSProcessableByteArray(mobileconfig);
    CMSSignedData signedData = generator.generate(bytes, true);

    return signedData.getEncoded();
}
",4
36648437,1,"public class sample{
public X509CertificateHolder loadSigner() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.crt"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (X509CertificateHolder) parser.readObject();
}

public PrivateKeyInfo loadInKey() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.key"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (PrivateKeyInfo) parser.readObject();
}

public X509CertificateHolder loadCertfile() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.crt"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (X509CertificateHolder) parser.readObject();
}
",3
36648437,1,"public X509CertificateHolder loadSigner() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.crt"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (X509CertificateHolder) parser.readObject();
}

public PrivateKeyInfo loadInKey() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.key"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (PrivateKeyInfo) parser.readObject();
}
",3
36648437,1,"public PrivateKeyInfo loadInKey() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.key"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (PrivateKeyInfo) parser.readObject();
}

public X509CertificateHolder loadCertfile() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.crt"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (X509CertificateHolder) parser.readObject();
}
",3
36648538,0,"public class sample{
public byte[] signMobileConfig(byte[] mobileconfig) 
            throws CertificateEncodingException, PEMException, FileNotFoundException, IOException, CertificateException, OperatorCreationException, CMSException {
    Security.addProvider(new BouncyCastleProvider());

    X509CertificateHolder caCertificate = loadCertfile();

    JcaX509CertificateConverter certificateConverter = new JcaX509CertificateConverter();
    X509Certificate serverCertificate = certificateConverter.getCertificate(loadSigner());

    PrivateKeyInfo privateKeyInfo = loadInKey();
    PrivateKey inKey = new JcaPEMKeyConverter().getPrivateKey(privateKeyInfo);
    ContentSigner sha1Signer = new JcaContentSignerBuilder(""SHA1withRSA"").setProvider(""BC"").build(inKey);

    CMSSignedDataGenerator generator = new CMSSignedDataGenerator();
    JcaDigestCalculatorProviderBuilder digestProviderBuilder = new JcaDigestCalculatorProviderBuilder().setProvider(""BC"");
    JcaSignerInfoGeneratorBuilder generatotBuilder = new JcaSignerInfoGeneratorBuilder(digestProviderBuilder.build());

    generator.addSignerInfoGenerator(generatotBuilder.build(sha1Signer, serverCertificate));
    generator.addCertificate(new X509CertificateHolder(serverCertificate.getEncoded()));
    generator.addCertificate(new X509CertificateHolder(caCertificate.getEncoded()));

    CMSProcessableByteArray bytes = new CMSProcessableByteArray(mobileconfig);
    CMSSignedData signedData = generator.generate(bytes, true);

    return signedData.getEncoded();
}
",4
36648538,1,"public class sample{
public X509CertificateHolder loadSigner() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.crt"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (X509CertificateHolder) parser.readObject();
}

public PrivateKeyInfo loadInKey() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.key"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (PrivateKeyInfo) parser.readObject();
}

public X509CertificateHolder loadCertfile() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.crt"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (X509CertificateHolder) parser.readObject();
}
",3
36648538,1,"public X509CertificateHolder loadSigner() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.crt"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (X509CertificateHolder) parser.readObject();
}

public PrivateKeyInfo loadInKey() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.key"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (PrivateKeyInfo) parser.readObject();
}
",3
36648538,1,"public PrivateKeyInfo loadInKey() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.key"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (PrivateKeyInfo) parser.readObject();
}

public X509CertificateHolder loadCertfile() throws FileNotFoundException, IOException {
    InputStream inputStream = externalResourcesFacade.getResourceAsStream(""path/to/.crt"");
    PEMParser parser = new PEMParser(new InputStreamReader(inputStream));
    return (X509CertificateHolder) parser.readObject();
}
",3
36680064,0,"        FileOutputStream fos = new FileOutputStream(ef);

        Log.d(""HIDEMYPICS"",""Decrypting: "" + f.toString());

        SecretKey key = generateKey(context, keyphrase.toCharArray());
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, key);
        // Wrap the output stream
        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        // Write bytes
        int b;
        byte[] d = new byte[8];
        while ((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }
        // Flush and close streams.
        cos.flush();
        cos.close();
        fis.close();

        Log.d(""HIDEMYPICS"",""Decrypted to: "" + ef.toString());
        return true;
    } catch (IOException e){
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (InvalidKeySpecException e) {
        e.printStackTrace();
    }
    return false;",2
36680064,0,"        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        // Write bytes
        int b;
        byte[] d = new byte[8];
        while ((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }
        // Flush and close streams.
        cos.flush();
        cos.close();
        fis.close();
",2
36680064,0,"        FileOutputStream fos = new FileOutputStream(ef);

        Log.d(""HIDEMYPICS"",""Encrypting: "" + f.toString());

        SecretKey key = generateKey(context, keyphrase.toCharArray());
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        // Wrap the output stream
        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        // Write bytes
        int b;
        byte[] d = new byte[8];
        while ((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }
        // Flush and close streams.
        cos.flush();
        cos.close();
        fis.close();
        Log.d(""HIDEMYPICS"",""Encrypted to: "" + ef.toString());
        return true;
    } catch (IOException e){
        e.printStackTrace();
    } catch (NoSuchPaddingException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (InvalidKeyException e) {
        e.printStackTrace();
    } catch (InvalidKeySpecException e) {
        e.printStackTrace();
    }
    return false;",2
36680064,0,"        CipherOutputStream cos = new CipherOutputStream(fos, cipher);
        // Write bytes
        int b;
        byte[] d = new byte[8];
        while ((b = fis.read(d)) != -1) {
            cos.write(d, 0, b);
        }
        // Flush and close streams.
        cos.flush();
        cos.close();
        fis.close();",2
36722168,0,"  public class Encrypter {

  public static void main(String[] args) throws Exception {
  String FileName = ""encryptedtext.txt"";
  String FileName2 = ""decryptedtext.txt"";

  Scanner input = new Scanner(System.in);

  System.out.println(""Enter your 16 character key here:"");
  String EncryptionKey = input.next();
  byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
  IvParameterSpec ivspec = new IvParameterSpec(iv);


  KeyGenerator KeyGen = KeyGenerator.getInstance(""AES"");
  KeyGen.init(128);


  Cipher AesCipher = Cipher.getInstance(""AES/CFB/NoPadding"");
  System.out.println(""Enter text to encrypt or decrypt:"");
  String Text = input.next();

  System.out.println(""Do you want to encrypt or decrypt (e/d)"");
  String answer = input.next();
  if (answer.equalsIgnoreCase(""e"")) {

   byte[] byteKey = (EncryptionKey.getBytes());
   byte[] byteText = (Text).getBytes();
   SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, ""AES"");
   AesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivspec);
   AesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivspec); // ERROR LINE
   byte[] byteCipherText = AesCipher.doFinal(byteText);
   Files.write(Paths.get(FileName), byteCipherText);


  } else if (answer.equalsIgnoreCase(""d"")) {

   byte[] byteKey = (EncryptionKey.getBytes());
   byte[] byteText = (Text).getBytes();
   byte[] cipherText = Files.readAllBytes(Paths.get(FileName));

   SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, ""AES"");
   AesCipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivspec); // ERROR LINE
   byte[] bytePlainText = AesCipher.doFinal(cipherText);
   Files.write(Paths.get(FileName2), bytePlainText);
  }
 }

}",2
36723150,0,"public class Encrypter {

public static void main(String[] args) throws Exception {
    String FileName = ""encryptedtext.txt"";
    String FileName2 = ""decryptedtext.txt"";

    Scanner input = new Scanner(System.in);

   System.out.println(""Enter your 16 character key here:"");
   String EncryptionKey = input.next();
   byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
   IvParameterSpec ivspec = new IvParameterSpec(iv);


    KeyGenerator KeyGen = KeyGenerator.getInstance(""AES"");
    KeyGen.init(128);


    Cipher AesCipher = Cipher.getInstance(""AES/CFB/NoPadding"");
    System.out.println(""Enter text to encrypt or decrypt:"");
    String Text = input.next();

    System.out.println(""Do you want to encrypt or decrypt (e/d)"");
    String answer = input.next();
    if (answer.equalsIgnoreCase(""e"")){

        byte[] byteKey = (EncryptionKey.getBytes());
        byte[] byteText = (Text).getBytes();
        SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, ""AES"");
        AesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec,ivspec );
        AesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec,ivspec); // ERROR LINE
        byte[] byteCipherText = AesCipher.doFinal(byteText);
        Files.write(Paths.get(FileName), byteCipherText);


          }
    else if (answer.equalsIgnoreCase(""d"")){

        byte[] byteKey = (EncryptionKey.getBytes());
        byte[] byteText = (Text).getBytes();
        byte[] cipherText = Files.readAllBytes(Paths.get(FileName));

        SecretKeySpec secretKeySpec = new SecretKeySpec(byteKey, ""AES"");
        AesCipher.init(Cipher.DECRYPT_MODE, secretKeySpec,ivspec); // ERROR LINE
        byte[] bytePlainText = AesCipher.doFinal(cipherText);
        Files.write(Paths.get(FileName2), bytePlainText);
    }
}

}",2
36731561,0,"    if (sslCert.IndexOf(applicationId, StringComparison.OrdinalIgnoreCase) >= 0)
    {
        Console.WriteLine(""This implies we can start running."");
        Console.WriteLine(ExecuteCommand(""netsh http delete sslcert ipport=0.0.0.0:4443""));
        //store.Remove(certs.First(x => x.Subject.Contains(certSubjectName)));
    }

    AsymmetricKeyParameter myCAprivateKey = null;
    Console.WriteLine(""Creating CA"");
    X509Certificate2 certificateAuthorityCertificate = CreateCertificateAuthorityCertificate(""CN="" + certSubjectName + ""CA"", ref myCAprivateKey);
    Console.WriteLine(""Adding CA to Store"");
    AddCertificateToSpecifiedStore(certificateAuthorityCertificate, StoreName.Root, StoreLocation.LocalMachine);

    Console.WriteLine(""Creating certificate based on CA"");
    X509Certificate2 certificate = CreateSelfSignedCertificateBasedOnCertificateAuthorityPrivateKey(""CN="" + certSubjectName, ""CN="" + certSubjectName + ""CA"", myCAprivateKey);
    Console.WriteLine(""Adding certificate to Store"");
    AddCertificateToSpecifiedStore(certificate, StoreName.My, StoreLocation.LocalMachine);

    Console.WriteLine(ExecuteCommand($""netsh http add sslcert ipport=0.0.0.0:4443 certhash={certificate.Thumbprint} appid={{{applicationId}}}""));

    // Check to see if our cert exists
    // If the cert does not exist create it then bind it to the port
    // If the cert does exist then check the port it is bound to
    // If the port and thumbprint match and applicationId match continue
    // Else throw exception
    // See here for more netsh commands https://msdn.microsoft.com/en-us/library/ms733791(v=vs.110).aspx",3
36731561,0,"    const int keyStrength = 2048;

    // Generating Random Numbers
    CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
    SecureRandom random = new SecureRandom(randomGenerator);
    ISignatureFactory signatureFactory = new Asn1SignatureFactory(""SHA512WITHRSA"", issuerPrivKey, random);
    // The Certificate Generator
    X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();",4
36731561,0,"    const int keyStrength = 2048;

    // Generating Random Numbers
    CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
    SecureRandom random = new SecureRandom(randomGenerator);
    ISignatureFactory signatureFactory = new Asn1SignatureFactory(""SHA512WITHRSA"", issuerPrivKey, random);
    // The Certificate Generator
    X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();
    certificateGenerator.AddExtension(X509Extensions.ExtendedKeyUsage, true, new ExtendedKeyUsage((new ArrayList() { new DerObjectIdentifier(""1.3.6.1.5.5.7.3.1"") })));

    // Serial Number
    BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
    certificateGenerator.SetSerialNumber(serialNumber);

    // Signature Algorithm
    //const string signatureAlgorithm = ""SHA512WITHRSA"";
    //certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

    // Issuer and Subject Name
    X509Name subjectDN = new X509Name(subjectName);
    X509Name issuerDN = new X509Name(issuerName);
    certificateGenerator.SetIssuerDN(issuerDN);
    certificateGenerator.SetSubjectDN(subjectDN);

    // Valid For",4
36731561,0,"    DateTime notAfter = notBefore.AddYears(2);

    certificateGenerator.SetNotBefore(notBefore);
    certificateGenerator.SetNotAfter(notAfter);

    // Subject Public Key
    AsymmetricCipherKeyPair subjectKeyPair;
    var keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
    var keyPairGenerator = new RsaKeyPairGenerator();
    keyPairGenerator.Init(keyGenerationParameters);
    subjectKeyPair = keyPairGenerator.GenerateKeyPair();

    certificateGenerator.SetPublicKey(subjectKeyPair.Public);

    // Generating the Certificate
    AsymmetricCipherKeyPair issuerKeyPair = subjectKeyPair;

    // selfsign certificate
    X509Certificate certificate = certificateGenerator.Generate(signatureFactory);

    // correcponding private key
    PrivateKeyInfo info = PrivateKeyInfoFactory.CreatePrivateKeyInfo(subjectKeyPair.Private);


    // merge into X509Certificate2
    X509Certificate2 x509 = new X509Certificate2(certificate.GetEncoded());

    Asn1Sequence seq = (Asn1Sequence)Asn1Object.FromByteArray(info.ParsePrivateKey().GetDerEncoded());
    if (seq.Count != 9)
    {
        //throw new PemException(""malformed sequence in RSA private key"");
    }

    RsaPrivateKeyStructure rsa = RsaPrivateKeyStructure.GetInstance(seq); //new RsaPrivateKeyStructure(seq);
    RsaPrivateCrtKeyParameters rsaparams = new RsaPrivateCrtKeyParameters(
        rsa.Modulus, rsa.PublicExponent, rsa.PrivateExponent, rsa.Prime1, rsa.Prime2, rsa.Exponent1, rsa.Exponent2, rsa.Coefficient);

    x509.PrivateKey = DotNetUtilities.ToRSA(rsaparams);
    return x509;

}
public static X509Certificate2 CreateCertificateAuthorityCertificate(string subjectName, ref AsymmetricKeyParameter CaPrivateKey)
{
    const int keyStrength = 2048;

    // Generating Random Numbers
    CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
    SecureRandom random = new SecureRandom(randomGenerator);

    // The Certificate Generator
    X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

    // Serial Number
    BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
    certificateGenerator.SetSerialNumber(serialNumber);

    // Signature Algorithm
    //const string signatureAlgorithm = ""SHA256WithRSA"";
    //certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

    // Issuer and Subject Name
    X509Name subjectDN = new X509Name(subjectName);
    X509Name issuerDN = subjectDN;
    certificateGenerator.SetIssuerDN(issuerDN);
    certificateGenerator.SetSubjectDN(subjectDN);

    // Valid For",4
36731561,0,"    const int keyStrength = 2048;

    // Generating Random Numbers
    CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
    SecureRandom random = new SecureRandom(randomGenerator);

    // The Certificate Generator
    X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

    // Serial Number
    BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
    certificateGenerator.SetSerialNumber(serialNumber);

    // Signature Algorithm
    //const string signatureAlgorithm = ""SHA256WithRSA"";
    //certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

    // Issuer and Subject Name",4
36731561,0,"    DateTime notAfter = notBefore.AddYears(2);

    certificateGenerator.SetNotBefore(notBefore);
    certificateGenerator.SetNotAfter(notAfter);

    // Subject Public Key
    AsymmetricCipherKeyPair subjectKeyPair;
    KeyGenerationParameters keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
    RsaKeyPairGenerator keyPairGenerator = new RsaKeyPairGenerator();
    keyPairGenerator.Init(keyGenerationParameters);
    subjectKeyPair = keyPairGenerator.GenerateKeyPair();

    certificateGenerator.SetPublicKey(subjectKeyPair.Public);

    // Generating the Certificate
    AsymmetricCipherKeyPair issuerKeyPair = subjectKeyPair;
    ISignatureFactory signatureFactory = new Asn1SignatureFactory(""SHA512WITHRSA"", issuerKeyPair.Private, random);
    // selfsign certificate
    X509Certificate certificate = certificateGenerator.Generate(signatureFactory);
    X509Certificate2 x509 = new X509Certificate2(certificate.GetEncoded());

    CaPrivateKey = issuerKeyPair.Private;

    return x509;
    //return issuerKeyPair.Private;

}
public static bool AddCertificateToSpecifiedStore(X509Certificate2 cert, StoreName st, StoreLocation sl)
{
    bool bRet = false;

    try
    {
        X509Store store = new X509Store(st, sl);
        store.Open(OpenFlags.ReadWrite);
        store.Add(cert);

        store.Close();
    }
    catch
    {
        Console.WriteLine(""An error occured"");
    }

    return bRet;
}
public static string ExecuteCommand(string action)
{
    StringBuilder stringBuilder = new StringBuilder();
    using (Process process = new Process
    {
        StartInfo = new ProcessStartInfo
        {
            WindowStyle = ProcessWindowStyle.Normal,
            FileName = ""cmd.exe"",
            UseShellExecute = false,
            RedirectStandardOutput = true,
            Arguments = ""/c "" + action
        }
    })
    {
        Console.WriteLine(""Executing Command:"");
        Console.WriteLine(action);
        process.Start();
        while (!process.StandardOutput.EndOfStream)
        {
            stringBuilder.AppendLine(process.StandardOutput.ReadLine());
        }
        process.Close();
    }

    return stringBuilder.ToString();
}
",3
36736209,5,"            case INS_ENCRYPT:
                aesCipher.init(aesKey, Cipher.MODE_ENCRYPT);
                aesCipher.doFinal(buffer, ISO7816.OFFSET_CDATA, (short) 0x10, volatileMem, (short) 0x00);
                Util.arrayCopyNonAtomic(volatileMem, (short) 0x00, buffer, (short) 0x00, (short) 0x10);
                apdu.setOutgoingAndSend((short) 0x00, (short) 0x10);
                break;",2
36736209,5,"            case INS_DECRYPT:
                aesCipher.init(aesKey, Cipher.MODE_DECRYPT);
                aesCipher.doFinal(buffer, ISO7816.OFFSET_CDATA, (short) 0x10, volatileMem, (short) 0x00);
                Util.arrayCopyNonAtomic(volatileMem, (short) 0x00, buffer, (short) 0x00, (short) 0x10);
                apdu.setOutgoingAndSend((short) 0x00, (short) 0x10);
                break;",2
36738650,0,"    PackageManager pm = getPackageManager();
    int flags = PackageManager.GET_SIGNATURES;
    PackageInfo packageInfo = null;
    try {
        packageInfo = pm.getPackageInfo(packageName, flags);
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
    Signature[] signatures = packageInfo.signatures;
    byte[] cert = signatures[0].toByteArray();
    InputStream input = new ByteArrayInputStream(cert);
    CertificateFactory cf = null;
    try {
        cf = CertificateFactory.getInstance(""X509"");
    } catch (CertificateException e) {
        e.printStackTrace();
    }
    X509Certificate c = null;
    try {
        c = (X509Certificate) cf.generateCertificate(input);
    } catch (CertificateException e) {
        e.printStackTrace();
    }
    String hexString = null;
    try {
        MessageDigest md = MessageDigest.getInstance(""SHA1"");
        byte[] publicKey = md.digest(c.getEncoded());
        hexString = byte2HexFormatted(publicKey);
    } catch (NoSuchAlgorithmException e1) {
        e1.printStackTrace();
    } catch (CertificateEncodingException e) {
        e.printStackTrace();
    }
    return hexString;
}

public static String byte2HexFormatted(byte[] arr) {
    StringBuilder str = new StringBuilder(arr.length * 2);
    for (int i = 0; i < arr.length; i++) {
        String h = Integer.toHexString(arr[i]);
        int l = h.length();
        if (l == 1) h = ""0"" + h;
        if (l > 2) h = h.substring(l - 2, l);
        str.append(h.toUpperCase());
        if (i < (arr.length - 1)) str.append(':');
    }
    return str.toString();
}
",4
36738650,0,"    Signature[] signatures = packageInfo.signatures;
    byte[] cert = signatures[0].toByteArray();
    InputStream input = new ByteArrayInputStream(cert);
    CertificateFactory cf = null;
    try {
        cf = CertificateFactory.getInstance(""X509"");",3
36738650,0,"    byte[] cert = signatures[0].toByteArray();
    InputStream input = new ByteArrayInputStream(cert);
    CertificateFactory cf = null;
    try {
        cf = CertificateFactory.getInstance(""X509"");
    } catch (CertificateException e) {
        e.printStackTrace();
    }
    X509Certificate c = null;
    try {
        c = (X509Certificate) cf.generateCertificate(input);",3
36740546,0,"            Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
            int blockSize = cipher.getBlockSize();

            byte[] dataBytes = data.getBytes();
            int plaintextLength = dataBytes.length;
            if (plaintextLength % blockSize != 0) {
                plaintextLength = plaintextLength + (blockSize - (plaintextLength % blockSize));
            }

            byte[] plaintext = new byte[plaintextLength];
            System.arraycopy(dataBytes, 0, plaintext, 0, dataBytes.length);
",2
36740546,0,"            byte[] plaintext = new byte[plaintextLength];
            System.arraycopy(dataBytes, 0, plaintext, 0, dataBytes.length);

            SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), ""AES"");
            IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());

            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
            byte[] encrypted = cipher.doFinal(plaintext);

            return new sun.misc.BASE64Encoder().encode(encrypted);
",2
36740546,0,"            SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), ""AES"");
            IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());

            cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);
            byte[] encrypted = cipher.doFinal(plaintext);
",2
36740546,0,"            SecretKeySpec keyspec = new SecretKeySpec(key.getBytes(), ""AES"");
            IvParameterSpec ivspec = new IvParameterSpec(iv.getBytes());

            cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

            byte[] original = cipher.doFinal(encrypted1);",2
36755660,0,"            if (sslCert.IndexOf(applicationId, StringComparison.OrdinalIgnoreCase) >= 0)
            {
                Console.WriteLine(""This implies we can start running."");
                Console.WriteLine(ExecuteCommand(""netsh http delete sslcert ipport=0.0.0.0:4443""));
                //store.Remove(certs.First(x => x.Subject.Contains(certSubjectName)));
            }

            AsymmetricKeyParameter myCAprivateKey = null;
            Console.WriteLine(""Creating CA"");
            X509Certificate2 certificateAuthorityCertificate = CreateCertificateAuthorityCertificate(""CN="" + certSubjectName + ""CA"", ref myCAprivateKey);
            Console.WriteLine(""Adding CA to Store"");
            AddCertificateToSpecifiedStore(certificateAuthorityCertificate, StoreName.Root, StoreLocation.LocalMachine);

            Console.WriteLine(""Creating certificate based on CA"");
            X509Certificate2 certificate = CreateSelfSignedCertificateBasedOnCertificateAuthorityPrivateKey(""CN="" + certSubjectName, ""CN="" + certSubjectName + ""CA"", myCAprivateKey);
            Console.WriteLine(""Adding certificate to Store"");
            AddCertificateToSpecifiedStore(certificate, StoreName.My, StoreLocation.LocalMachine);

            Console.WriteLine(ExecuteCommand($""netsh http add sslcert ipport=0.0.0.0:4443 certhash={certificate.Thumbprint} appid={{{applicationId}}}""));

            // Check to see if our cert exists
            // If the cert does not exist create it then bind it to the port
            // If the cert does exist then check the port it is bound to
            // If the port and thumbprint match and applicationId match continue
            // Else throw exception
            // See here for more netsh commands https://msdn.microsoft.com/en-us/library/ms733791(v=vs.110).aspx
",3
36755660,0,"            const int keyStrength = 2048;

            // Generating Random Numbers
            CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
            SecureRandom random = new SecureRandom(randomGenerator);
            ISignatureFactory signatureFactory = new Asn1SignatureFactory(""SHA512WITHRSA"", issuerPrivKey, random);
            // The Certificate Generator
            X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();",4
36755660,0,"            const int keyStrength = 2048;

            // Generating Random Numbers
            CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
            SecureRandom random = new SecureRandom(randomGenerator);
            ISignatureFactory signatureFactory = new Asn1SignatureFactory(""SHA512WITHRSA"", issuerPrivKey, random);
            // The Certificate Generator
            X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();
            certificateGenerator.AddExtension(X509Extensions.ExtendedKeyUsage, true, new ExtendedKeyUsage((new ArrayList() { new DerObjectIdentifier(""1.3.6.1.5.5.7.3.1"") })));

            // Serial Number
            BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
            certificateGenerator.SetSerialNumber(serialNumber);

            // Signature Algorithm
            //const string signatureAlgorithm = ""SHA512WITHRSA"";
            //certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

            // Issuer and Subject Name
            X509Name subjectDN = new X509Name(subjectName);
            X509Name issuerDN = new X509Name(issuerName);
            certificateGenerator.SetIssuerDN(issuerDN);
            certificateGenerator.SetSubjectDN(subjectDN);

            // Valid For",4
36755660,0,"            DateTime notAfter = notBefore.AddYears(8);

            certificateGenerator.SetNotBefore(notBefore);
            certificateGenerator.SetNotAfter(notAfter);

            // Subject Public Key
            AsymmetricCipherKeyPair subjectKeyPair;
            var keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
            var keyPairGenerator = new RsaKeyPairGenerator();
            keyPairGenerator.Init(keyGenerationParameters);
            subjectKeyPair = keyPairGenerator.GenerateKeyPair();

            certificateGenerator.SetPublicKey(subjectKeyPair.Public);

            // Generating the Certificate
            AsymmetricCipherKeyPair issuerKeyPair = subjectKeyPair;

            // selfsign certificate
            X509Certificate certificate = certificateGenerator.Generate(signatureFactory);

            // correcponding private key
            PrivateKeyInfo info = PrivateKeyInfoFactory.CreatePrivateKeyInfo(subjectKeyPair.Private);


            // merge into X509Certificate2
            X509Certificate2 x509 = new X509Certificate2(certificate.GetEncoded());

            Asn1Sequence seq = (Asn1Sequence)Asn1Object.FromByteArray(info.ParsePrivateKey().GetDerEncoded());
            if (seq.Count != 9)
            {
                //throw new PemException(""malformed sequence in RSA private key"");
            }

            RsaPrivateKeyStructure rsa = RsaPrivateKeyStructure.GetInstance(seq); //new RsaPrivateKeyStructure(seq);
            RsaPrivateCrtKeyParameters rsaparams = new RsaPrivateCrtKeyParameters(
                rsa.Modulus, rsa.PublicExponent, rsa.PrivateExponent, rsa.Prime1, rsa.Prime2, rsa.Exponent1, rsa.Exponent2, rsa.Coefficient);

            x509.PrivateKey = DotNetUtilities.ToRSA(rsaparams);
            return x509;

        }
        public static X509Certificate2 CreateCertificateAuthorityCertificate(string subjectName, ref AsymmetricKeyParameter CaPrivateKey)
        {
            const int keyStrength = 2048;

            // Generating Random Numbers
            CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
            SecureRandom random = new SecureRandom(randomGenerator);

            // The Certificate Generator
            X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

            // Serial Number
            BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
            certificateGenerator.SetSerialNumber(serialNumber);

            // Signature Algorithm
            //const string signatureAlgorithm = ""SHA256WithRSA"";
            //certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

            // Issuer and Subject Name
            X509Name subjectDN = new X509Name(subjectName);
            X509Name issuerDN = subjectDN;
            certificateGenerator.SetIssuerDN(issuerDN);
            certificateGenerator.SetSubjectDN(subjectDN);

            // Valid For",4
36755660,0,"            const int keyStrength = 2048;

            // Generating Random Numbers
            CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
            SecureRandom random = new SecureRandom(randomGenerator);

            // The Certificate Generator
            X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

            // Serial Number
            BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
            certificateGenerator.SetSerialNumber(serialNumber);

            // Signature Algorithm
            //const string signatureAlgorithm = ""SHA256WithRSA"";
            //certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

            // Issuer and Subject Name",4
36755660,0,"            DateTime notAfter = notBefore.AddYears(8);

            certificateGenerator.SetNotBefore(notBefore);
            certificateGenerator.SetNotAfter(notAfter);

            // Subject Public Key
            AsymmetricCipherKeyPair subjectKeyPair;
            KeyGenerationParameters keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
            RsaKeyPairGenerator keyPairGenerator = new RsaKeyPairGenerator();
            keyPairGenerator.Init(keyGenerationParameters);
            subjectKeyPair = keyPairGenerator.GenerateKeyPair();

            certificateGenerator.SetPublicKey(subjectKeyPair.Public);

            // Generating the Certificate
            AsymmetricCipherKeyPair issuerKeyPair = subjectKeyPair;
            ISignatureFactory signatureFactory = new Asn1SignatureFactory(""SHA512WITHRSA"", issuerKeyPair.Private, random);
            // selfsign certificate
            X509Certificate certificate = certificateGenerator.Generate(signatureFactory);
            X509Certificate2 x509 = new X509Certificate2(certificate.GetEncoded());

            CaPrivateKey = issuerKeyPair.Private;

            return x509;
            //return issuerKeyPair.Private;

        }
        public static bool AddCertificateToSpecifiedStore(X509Certificate2 cert, StoreName st, StoreLocation sl)
        {
            bool bRet = false;

            try
            {
                X509Store store = new X509Store(st, sl);
                store.Open(OpenFlags.ReadWrite);
                store.Add(cert);

                store.Close();
            }
            catch
            {
                Console.WriteLine(""An error occured"");
            }

            return bRet;
        }
        public static string ExecuteCommand(string action)
        {
            StringBuilder stringBuilder = new StringBuilder();
            using (Process process = new Process
            {
                StartInfo = new ProcessStartInfo
                {
                    WindowStyle = ProcessWindowStyle.Normal,
                    FileName = ""cmd.exe"",
                    UseShellExecute = false,
                    RedirectStandardOutput = true,
                    Arguments = ""/c "" + action
                }
            })
            {
                Console.WriteLine(""Executing Command:"");
                Console.WriteLine(action);
                process.Start();
                while (!process.StandardOutput.EndOfStream)
                {
                    stringBuilder.AppendLine(process.StandardOutput.ReadLine());
                }
                process.Close();
            }

            return stringBuilder.ToString();
        }
",3
36836658,0,"        const int keyStrength = 2048;

        // Generating Random Numbers
        CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
        SecureRandom random = new SecureRandom(randomGenerator);
        ISignatureFactory signatureFactory = new Asn1SignatureFactory(""SHA512WITHRSA"", issuerPrivKey, random);

        // The Certificate Generator
        X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();",4
36836658,0,"        const int keyStrength = 2048;

        // Generating Random Numbers
        CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
        SecureRandom random = new SecureRandom(randomGenerator);

        // The Certificate Generator
        X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Issuer and Subject Name",4
36836889,0,"        Certificate ca;
        try {
            ca = cf.generateCertificate(caInput);
            System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
        } finally {
            caInput.close();
        }
        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);
        // Create a TrustManager that trusts the CAs in our KeyStore",1
36836889,0,"        Certificate ca;
        try {
            ca = cf.generateCertificate(caInput);
            System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
        } finally {
            caInput.close();
        }
        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);
        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);
        // Create an SSLContext that uses our TrustManager",1
36843409,0,"            KeyStore ks = null;
            if ( keyStore != null )
            {
              ks = KeyStore.getInstance( KeyStore.getDefaultType() );
              FileInputStream ksfis = new FileInputStream( keyStore );
              try
              {
                ks.load( ksfis, keyStorePasswd );
              }
              finally
              {
                ksfis.close();
              }
            }
            KeyManagerFactory kmf = KeyManagerFactory.getInstance( KeyManagerFactory
                .getDefaultAlgorithm() );",1
36843409,0,"            KeyStore ts = null;
            if ( trustStore != null )
            {
              ts = KeyStore.getInstance( KeyStore.getDefaultType() );
              FileInputStream tsfis = new FileInputStream( trustStore );
              try
              {
                ts.load( tsfis, trustStorePasswd );
              }
              finally
              {
                tsfis.close();
              }
            }
            TrustManagerFactory tmf = TrustManagerFactory.getInstance( TrustManagerFactory
                .getDefaultAlgorithm() );",1
36856719,0,"public static String encrypt(String seed, String cleartext) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException,
        IllegalBlockSizeException, BadPaddingException {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext.getBytes());
    return toHex(result);
}

public static String decrypt(String seed, String encrypted) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException,
        IllegalBlockSizeException, BadPaddingException {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] enc = toByte(encrypted);
    byte[] result = decrypt(rawKey, enc);
    return new String(result);
}
",2
36856719,0,"private static byte[] encrypt(byte[] raw, byte[] clear) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
        IllegalBlockSizeException, BadPaddingException {
    SecretKeySpec secretKeySpec = new SecretKeySpec(raw, ALGORITHM);
    Cipher cipher = Cipher.getInstance(ALGORITHM);
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}
",2
36856719,0,"private static byte[] decrypt(byte[] raw, byte[] encrypted) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException,
        IllegalBlockSizeException, BadPaddingException {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ALGORITHM);
    Cipher cipher = Cipher.getInstance(ALGORITHM);
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
    return decrypted;
}
",2
36874647,0,"    X509Certificate[] chain = tm.chain;
    if (chain == null) {
        System.out.println(""Could not obtain server certificate chain"");
        return;
    }

    BufferedReader reader =
        new BufferedReader(new InputStreamReader(System.in));

    System.out.println();
    System.out.println(""Server sent "" + chain.length + "" certificate(s):"");
    System.out.println();
    MessageDigest sha1 = MessageDigest.getInstance(""SHA1"");
    MessageDigest md5 = MessageDigest.getInstance(""MD5"");
    for (int i = 0; i < chain.length; i++) {
        X509Certificate cert = chain[i];
        System.out.println
            ("" "" + (i + 1) + "" Subject "" + cert.getSubjectDN());
        System.out.println(""   Issuer  "" + cert.getIssuerDN());
        sha1.update(cert.getEncoded());
        System.out.println(""   sha1    "" + toHexString(sha1.digest()));
        md5.update(cert.getEncoded());
        System.out.println(""   md5     "" + toHexString(md5.digest()));
        System.out.println();
    }

    System.out.println(""Enter certificate to add to trusted keystore or 'q' to quit: [1]"");
    String line = reader.readLine().trim();
    int k;
    try {
        k = (line.length() == 0) ? 0 : Integer.parseInt(line) - 1;
    } catch (NumberFormatException e) {
        System.out.println(""KeyStore not changed"");
        return;
    }

    X509Certificate cert = chain[k];
    String alias = host + ""-"" + (k + 1);
    ks.setCertificateEntry(alias, cert);
",4
36874647,0,"    private static String toHexString(byte[] bytes) {
    StringBuilder sb = new StringBuilder(bytes.length * 3);
    for (int b : bytes) {
        b &= 0xff;
        sb.append(HEXDIGITS[b >> 4]);
        sb.append(HEXDIGITS[b & 15]);
        sb.append(' ');
    }
    return sb.toString();
    }

    private static class SavingTrustManager implements X509TrustManager {

    private final X509TrustManager tm;
    private X509Certificate[] chain;

    SavingTrustManager(X509TrustManager tm) {
        this.tm = tm;
    }

    public X509Certificate[] getAcceptedIssuers() {
        throw new UnsupportedOperationException();
    }

    public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        throw new UnsupportedOperationException();
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        this.chain = chain;
        tm.checkServerTrusted(chain, authType);
    }
    }
",1
36874647,0,"    public void checkClientTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        throw new UnsupportedOperationException();
    }

    public void checkServerTrusted(X509Certificate[] chain, String authType)
        throws CertificateException {
        this.chain = chain;
        tm.checkServerTrusted(chain, authType);
    }",1
36881248,0,"Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());

    byte[] input = new byte[] { (byte) 0xbe, (byte) 0xef };
    Cipher cipher = Cipher.getInstance(""RSA/None/NoPadding"", ""BC"");

    KeyFactory keyFactory = KeyFactory.getInstance(""RSA"", ""BC"");
    RSAPublicKeySpec pubKeySpec = new RSAPublicKeySpec(new BigInteger(
        ""12345678"", 16), new BigInteger(""11"", 16));
    RSAPrivateKeySpec privKeySpec = new RSAPrivateKeySpec(new BigInteger(
        ""12345678"", 16), new BigInteger(""12345678"",
        16));

    RSAPublicKey pubKey = (RSAPublicKey) keyFactory.generatePublic(pubKeySpec);
    RSAPrivateKey privKey = (RSAPrivateKey) keyFactory.generatePrivate(privKeySpec);

    cipher.init(Cipher.ENCRYPT_MODE, pubKey);
",3
36881248,0,"    RSAPrivateKey privKey = (RSAPrivateKey) keyFactory.generatePrivate(privKeySpec);

    cipher.init(Cipher.ENCRYPT_MODE, pubKey);

    byte[] cipherText = cipher.doFinal(input);
    System.out.println(""cipher: "" + new String(cipherText));
",3
36881248,0,"    System.out.println(""cipher: "" + new String(cipherText));

    cipher.init(Cipher.DECRYPT_MODE, privKey);
    byte[] plainText = cipher.doFinal(cipherText);
    System.out.println(""plain : "" + new String(plainText));
",2
37012277,6,"public class sample{
 public void foo(){
key1 = (AESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_AES_TRANSIENT_DESELECT,
 KeyBuilder.LENGTH_AES_128, false);
...
cipher.init(key1, Cipher.MODE_DECRYPT);
cipher.init(key1, Cipher.MODE_ENCRYPT);

}",2
37012277,8,"public class sample{
 public void foo(){
key1 = (AESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_AES_TRANSIENT_DESELECT,
     KeyBuilder.LENGTH_AES_128, false);
key2 = (AESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_AES_TRANSIENT_DESELECT,
     KeyBuilder.LENGTH_AES_128, false);
...
cipher.init(key1, Cipher.MODE_DECRYPT);
cipher.init(key2, Cipher.MODE_ENCRYPT);

}",2
37012277,10,"public class sample{
 public void foo(){
key1 = (AESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_AES,
 KeyBuilder.LENGTH_AES_128, false);
...
cipher.init(key1, Cipher.MODE_DECRYPT);
cipher.init(key1, Cipher.MODE_ENCRYPT);

}",2
37012277,12,"public class sample{
 public void foo(){
key1 = (AESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_AES,
     KeyBuilder.LENGTH_AES_128, false);
key2 = (AESKey) KeyBuilder.buildKey(KeyBuilder.TYPE_AES,
     KeyBuilder.LENGTH_AES_128, false);
...
cipher.init(key1, Cipher.MODE_DECRYPT);
cipher.init(key2, Cipher.MODE_ENCRYPT);

}",2
37068325,0,"public class sample{
 public void foo(){
KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());
keyStore.load(new FileInputStream(new File(""keystore.jks"")),
        ""secret"".toCharArray());
SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory(
        new SSLContextBuilder()
                .loadTrustMaterial(null, new TrustSelfSignedStrategy())
                .loadKeyMaterial(keyStore, ""password"".toCharArray()).build());
HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build();
ClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(
        httpClient);
RestTemplate restTemplate = new RestTemplate(requestFactory);
ResponseEntity<String> response = restTemplate.getForEntity(
        ""https://localhost:8443"", String.class);

}",1
37119790,1,"InputStream is = connection.getInputStream();
InputStreamReader reader = new InputStreamReader(is);
            StringBuilder builder = new StringBuilder();
            int c = 0;",3
37154788,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());

             Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
37278997,0,"    byte[] ciphertextBytes = Base64.decodeBase64(encrypted.getBytes());

    IvParameterSpec iv = new IvParameterSpec(ciphertextBytes, 0, 16);

    ciphertextBytes = Arrays.copyOfRange(ciphertextBytes, 16,
            ciphertextBytes.length);

    SecretKeySpec skeySpec = new SecretKeySpec(key, ""AES"");

    Cipher cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
    byte[] original = cipher.doFinal(ciphertextBytes);

    // Remove zero bytes at the end.
    int lastLength = original.length;
    for (int i = original.length - 1; i > original.length - 16; i--) {
        if (original[i] == (byte) 0) {
            lastLength--;
        } else {
            break;
        }
    }

    return new String(original, 0, lastLength); 
",2
37406189,3,"    SecretKeySpec secretKey = new SecretKeySpec(passphrase16.getBytes(), SIMMETRICAL_ALGORITHM);
    Cipher cipher = Cipher.getInstance(SIMMETRICAL_ALGORITHM);
    cipher.init(Cipher.ENCRYPT_MODE, secretKey);
    byte[] encoded = cipher.doFinal(message);
",2
37430901,0,"                keyspec = new SecretKeySpec(key.getBytes(), ""AES"");

                try {
                        cipher = Cipher.getInstance(""AES/CBC/NoPadding"");
                } catch (NoSuchAlgorithmException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                } catch (NoSuchPaddingException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                }",2
37430901,0,"                byte[] encrypted = null;

                try {
                        cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);

                        encrypted = cipher.doFinal(padString(text).getBytes());
                } catch (Exception e)
                {                       
                        throw new Exception(""[encrypt] "" + e.getMessage());
                }

                return encrypted;",2
37430901,0,"                try {
                        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

                        decrypted = cipher.doFinal(hexToBytes(code));
                } catch (Exception e)
                {
                        throw new Exception(""[decrypt] "" + e.getMessage());
                }
                return decrypted;
        }



        public static String bytesToHex(byte[] data)
        {
                if (data==null)
                {
                        return null;
                }

                int len = data.length;
                String str = """";
                for (int i=0; i<len; i++) {
                        if ((data[i]&0xFF)<16)
                                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
                        else
                                str = str + java.lang.Integer.toHexString(data[i]&0xFF);
                }
                return str;
        }


        public static byte[] hexToBytes(String str) {
                if (str==null) {
                        return null;
                } else if (str.length() < 2) {
                        return null;
                } else {
                        int len = str.length() / 2;
                        byte[] buffer = new byte[len];
                        for (int i=0; i<len; i++) {
                                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
                        }
                        return buffer;
                }
        }


",2
37430901,0,"                try {
                        cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);

                        decrypted = cipher.doFinal(hexToBytes(code));
                } catch (Exception e)
                {
                        throw new Exception(""[decrypt] "" + e.getMessage());
                }
                return decrypted;
        }



        public static String bytesToHex(byte[] data)
        {
                if (data==null)
                {
                        return null;
                }

                int len = data.length;
                String str = """";
                for (int i=0; i<len; i++) {
                        if ((data[i]&0xFF)<16)
                                str = str + ""0"" + java.lang.Integer.toHexString(data[i]&0xFF);
                        else
                                str = str + java.lang.Integer.toHexString(data[i]&0xFF);
                }
                return str;
        }


        public static byte[] hexToBytes(String str) {
                if (str==null) {
                        return null;
                } else if (str.length() < 2) {
                        return null;
                } else {
                        int len = str.length() / 2;
                        byte[] buffer = new byte[len];
                        for (int i=0; i<len; i++) {
                                buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);
                        }
                        return buffer;
                }
        }



        private static String padString(String source)
        {
          char paddingChar = ' ';
          int size = 16;
          int x = source.length() % size;
          int padLength = size - x;

          for (int i = 0; i < padLength; i++)
          {
                  source += paddingChar;
          }

          return source;
        }

        public static String padRight(String s, int n) {
            return String.format(""%1$-"" + n + ""s"", s);  
          }",2
37593463,0,"public class sample{
 public void foo(){
/* Decrypt the message, given derived key and initialization vector. */
Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));
String plaintext = new String(cipher.doFinal(ciphertext), ""UTF-8"");
System.out.println(plaintext);

}",2
37765170,0,"private HostnameVerifier getHostnameVerifier() {
    return new HostnameVerifier() {
        @Override
        public boolean verify(String hostname, SSLSession session) {            
            HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();
            return hv.verify("".vk.com"", session);
        }
    };
}
",1
37807649,16,"        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
        if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
            throw new IllegalStateException(""Unexpected default trust managers:"" + Arrays.toString(trustManagers));
        }
        return (X509TrustManager) trustManagers[0];",1
37871600,0,"private static Registry<ConnectionSocketFactory> getRegistry() throws KeyManagementException, NoSuchAlgorithmException {
    SSLContext sslContext = SSLContexts.custom().build();
    SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory(sslContext,
            new String[]{""TLSv1.2""}, null, SSLConnectionSocketFactory.getDefaultHostnameVerifier());
    return RegistryBuilder.<ConnectionSocketFactory>create()
            .register(""http"", PlainConnectionSocketFactory.getSocketFactory())
            .register(""https"", sslConnectionSocketFactory)
            .build();
}
",1
37878305,0,"private static TrustManager[] getTrustManagers(KeyStore trustStore)
        throws NoSuchAlgorithmException, KeyStoreException {
    String alg = KeyManagerFactory.getDefaultAlgorithm();
    TrustManagerFactory fac = TrustManagerFactory.getInstance(alg);
    fac.init(trustStore);
    return fac.getTrustManagers();
}

private static KeyManager[] getKeyManagers(KeyStore keyStore, String keyPassword)
        throws GeneralSecurityException, IOException {
    String alg = KeyManagerFactory.getDefaultAlgorithm();
    char[] keyPass = keyPassword != null ? keyPassword.toCharArray() : null;
    KeyManagerFactory fac = KeyManagerFactory.getInstance(alg);
    fac.init(keyStore, keyPass);
    return fac.getKeyManagers();
}",1
37884790,0,"public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
}
",1
37884790,0,"public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
}

@Override",1
37983438,1,"  generator.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().build()).build(signer, cacert));
  generator.addCertificate(new X509CertificateHolder(certencoded));
  generator.addCertificate(new X509CertificateHolder(cacert.getEncoded()));
  CMSTypedData content = new CMSProcessableByteArray(certencoded);
  CMSSignedData signeddata = generator.generate(content, true);
",1
38011353,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.i(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
38162621,1,"public class sample{
 public void foo(){
KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(
                              KeyManagerFactory.getDefaultAlgorithm());
kmfactory.init(trustStore, ""password"".toCharArray());
KeyManager[] keymanagers =  kmfactory.getKeyManagers();

TrustManagerFactory tmf=TrustManagerFactory
  .getInstance(TrustManagerFactory.getDefaultAlgorithm());

tmf.init(trustStore);

SSLContext sslContext=SSLContext.getInstance(""TLSv1.2"");

sslContext.init(keymanagers, tmf.getTrustManagers(), new SecureRandom());

SSLSocketFactory factory=sslContext.getSocketFactory();

}",1
38210193,3,"public class sample{
 public void foo(){
KeyPairGenerator kpg = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_RSA, ""AndroidKeyStore"");


kpg.initialize(new KeyGenParameterSpec.Builder(
                alias,
                KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_VERIFY)
                .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)
                .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PKCS1)
                .build());

KeyPair keyPair = kpg.generateKeyPair();

}",34
38252933,0,"        KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
        keyGen.init(256);
        SecretKey secretKey = keyGen.generateKey();

        final int AES_KEYLENGTH = 256;
        byte[] iv = new byte[AES_KEYLENGTH / 16];
        SecureRandom prng = new SecureRandom();
        prng.nextBytes(iv);
",5
38298823,0,"    byte[] outputText = new byte[cipher.getOutputSize(inputData.length)];
    int outputLen = cipher.processBytes(inputData, 0, inputData.length,
            outputText , 0);
    cipher.doFinal(outputText, outputLen);

//      outputText and mac are in bytes ",2
38459497,3,"public static String getSignatureHash(Context ctxt, String packageName)
  throws NameNotFoundException, NoSuchAlgorithmException {
    MessageDigest md=MessageDigest.getInstance(""SHA-256"");
    Signature sig=
        ctxt.getPackageManager()
            .getPackageInfo(packageName, PackageManager.GET_SIGNATURES).signatures[0];

    return(toHexStringWithColons(md.digest(sig.toByteArray())));
  }

  // based on https://stackoverflow.com/a/2197650/115145

  public static String toHexStringWithColons(byte[] bytes) {
    char[] hexArray=
        { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B',
            'C', 'D', 'E', 'F' };
    char[] hexChars=new char[(bytes.length * 3) - 1];
    int v;

    for (int j=0; j < bytes.length; j++) {
      v=bytes[j] & 0xFF;
      hexChars[j * 3]=hexArray[v / 16];
      hexChars[j * 3 + 1]=hexArray[v % 16];

      if (j < bytes.length - 1) {
        hexChars[j * 3 + 2]=':';
      }
    }

    return new String(hexChars);
  }
",4
38459497,3,"public static String getSignatureHash(Context ctxt, String packageName)
  throws NameNotFoundException, NoSuchAlgorithmException {
    MessageDigest md=MessageDigest.getInstance(""SHA-256"");
    Signature sig=
        ctxt.getPackageManager()
            .getPackageInfo(packageName, PackageManager.GET_SIGNATURES).signatures[0];

    return(toHexStringWithColons(md.digest(sig.toByteArray())));",4
38459653,0,"            byte[] certificates = packageInfo.signatures[0].toByteArray();
            InputStream input = new ByteArrayInputStream(certificates);
            CertificateFactory factory = CertificateFactory.getInstance(""X509"");
            X509Certificate certificate = (X509Certificate) factory.generateCertificate(input);
",3
38477450,0,"        digest.update(secret.getBytes(""UTF-8""));
        byte[] keyBytes = new byte[32];
        System.arraycopy(digest.digest(), 0, keyBytes, 0, keyBytes.length);

        cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
        key = new SecretKeySpec(keyBytes, ""AES"");
        spec = getIV();",2
38492575,0,"        byte[] nData = urlDecoder.decode(nString);
        byte[] eData = urlDecoder.decode(eString);

        // convert to *positive* integers
        BigInteger n = new BigInteger(1, nData);
        BigInteger e = new BigInteger(1, eData);

        // create RSA specification and convert to key
        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(n, e);
        KeyFactory kf = KeyFactory.getInstance(""RSA"");",3
38541195,0,"public class sample{
 public void foo(){
PackageInfo info;
try {
    info = getPackageManager().getPackageInfo(""com.package.name"", PackageManager.GET_SIGNATURES);
    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String hash= new String(Base64.encode(md.digest(), 0));
        Log.e(""hash"", hash);
    }
} catch (NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}

}",4
38541195,0,"    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String hash= new String(Base64.encode(md.digest(), 0));
        Log.e(""hash"", hash);
    }",4
38541195,0,"    for (Signature signature : info.signatures) {
        MessageDigest md;
        md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        String hash= new String(Base64.encode(md.digest(), 0));
        Log.e(""hash"", hash);
    }
} catch (NameNotFoundException e1) {
    Log.e(""name not found"", e1.toString());
} catch (NoSuchAlgorithmException e) {
    Log.e(""no such an algorithm"", e.toString());
} catch (Exception e) {
    Log.e(""exception"", e.toString());
}
",4
38612444,2,"    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
    }
",1
38612444,2,"    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
    }

    private Socket enableTLSOnSocket(Socket socket) {
        if(socket != null && (socket instanceof SSLSocket)) {
            ((SSLSocket)socket).setEnabledProtocols(new String[] {""TLSv1.1"", ""TLSv1.2""});
        }
        return socket;
    }",1
38612444,2,"    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override",1
38635319,2,"generator.addSignerInfoGenerator(new JcaSignerInfoGeneratorBuilder(new JcaDigestCalculatorProviderBuilder().build()).build(signer, cacert));
generator.addCertificate(new X509CertificateHolder(certencoded));
generator.addCertificate(new X509CertificateHolder(cacert.getEncoded()));
CMSTypedData content = new CMSProcessableByteArray(certencoded);
CMSSignedData signeddata = generator.generate(content, true);",1
38675082,4,"        aesCBCPadded.init(true, paramsWithIV); // problem here

        // encrypt
        byte[] ciphertext = new byte[aesCBCPadded.getOutputSize(plaintext.length)];
        int bytesWrittenOut = aesCBCPadded.processBytes(
            plaintext, 0, plaintext.length, ciphertext, 0);
        aesCBCPadded.doFinal(ciphertext, bytesWrittenOut);

        // that's great, but where is your IV now? you need to include it in the returned ciphertext!",2
38675082,4,"        aesCBCPadded.init(true, paramsWithIV); // problem here

        // encrypt
        byte[] ciphertext = new byte[aesCBCPadded.getOutputSize(plaintext.length)];
        int bytesWrittenOut = aesCBCPadded.processBytes(
            plaintext, 0, plaintext.length, ciphertext, 0);
        aesCBCPadded.doFinal(ciphertext, bytesWrittenOut);

        // that's great, but where is your IV now? you need to include it in the returned ciphertext!
        return ciphertext;",2
38675082,4,"        byte[] ciphertext = new byte[aesCBCPadded.getOutputSize(plaintext.length)];
        int bytesWrittenOut = aesCBCPadded.processBytes(
            plaintext, 0, plaintext.length, ciphertext, 0);
        aesCBCPadded.doFinal(ciphertext, bytesWrittenOut);

        // that's great, but where is your IV now? you need to include it in the returned ciphertext!",2
38782208,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.i(""KeyHash:"",
                        Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
38861687,0,"    byte[] bytes = messageDigest.digest();
    StringBuilder stringBuilder = new StringBuilder();
    for (byte aByte : bytes) {
        stringBuilder.append(Integer.toString((aByte & 0xff) + 0x100, 16).substring(1));
    }",4
38863705,1,"    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
    }
",1
38863705,1,"    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
    }

    private Socket enableTLSOnSocket(Socket socket) {
        if(socket != null && (socket instanceof SSLSocket)) {
            ((SSLSocket)socket).setEnabledProtocols(new String[] {""TLSv1.1"", ""TLSv1.2""});
        }
        return socket;
    }",1
38863705,1,"    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override",1
38893978,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
39002997,0,"        byte[] iv = generateIv(cipher.getBlockSize());
        IvParameterSpec ivParams = new IvParameterSpec(iv);
        cipher.init(Cipher.ENCRYPT_MODE, key, ivParams);
        byte[] cipherText = cipher.doFinal(plaintext.getBytes(""UTF-8""));
",2
39002997,0,"        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        IvParameterSpec ivParams = new IvParameterSpec(iv);
        cipher.init(Cipher.DECRYPT_MODE, key, ivParams);
        byte[] plaintext = cipher.doFinal(cipherBytes);",2
39002997,0,"        KeySpec keySpec = new PBEKeySpec(password.toCharArray(), salt, ITERATION_COUNT, KEY_LENGTH);
        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(PBKDF2_DERIVATION_ALGORITHM);
        byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();",2
39139257,1,"    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }",4
39265878,0,"        for (android.content.pm.Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
39280323,0,"    KeySpec spec = new PBEKeySpec(key.toCharArray(), s, ITERATIONS, dkLen);
    SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    byte[] dk = factory.generateSecret(spec).getEncoded();",2
39291151,0,"CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
// From https://www.washington.edu/itconnect/security/ca/load-der.crt
InputStream caInput = new BufferedInputStream(new FileInputStream(""load-der.crt""));
Certificate ca;
try {
    ca = cf.generateCertificate(caInput);
    System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
} finally {
    caInput.close();
}

// Create a KeyStore containing our trusted CAs",1
39291151,0,"Certificate ca;
try {
    ca = cf.generateCertificate(caInput);
    System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
} finally {
    caInput.close();
}

// Create a KeyStore containing our trusted CAs
String keyStoreType = KeyStore.getDefaultType();
KeyStore keyStore = KeyStore.getInstance(keyStoreType);
keyStore.load(null, null);
keyStore.setCertificateEntry(""ca"", ca);

// Create a TrustManager that trusts the CAs in our KeyStore",1
39291151,0,"Certificate ca;
try {
    ca = cf.generateCertificate(caInput);
    System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
} finally {
    caInput.close();
}

// Create a KeyStore containing our trusted CAs
String keyStoreType = KeyStore.getDefaultType();
KeyStore keyStore = KeyStore.getInstance(keyStoreType);
keyStore.load(null, null);
keyStore.setCertificateEntry(""ca"", ca);

// Create a TrustManager that trusts the CAs in our KeyStore
String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
tmf.init(keyStore);

// Create an SSLContext that uses our TrustManager",1
39311251,3,"    public class Demo {

        public static final String PRIVATE_KEY=""/home/user/private.der"";
        public static final String PUBLIC_KEY=""/home/user/public.der"";

        public static void main(String[] args) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {
            //get the private key
            File file = new File(PRIVATE_KEY);
            FileInputStream fis = new FileInputStream(file);
            DataInputStream dis = new DataInputStream(fis);

            byte[] keyBytes = new byte[(int) file.length()];
            dis.readFully(keyBytes);
            dis.close();

            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory kf = KeyFactory.getInstance(""RSA"");
            RSAPrivateKey privKey = (RSAPrivateKey) kf.generatePrivate(spec);
            System.out.println(""Exponent :"" + privKey.getPrivateExponent());
            System.out.println(""Modulus"" + privKey.getModulus());

            //get the public key
            File file1 = new File(PUBLIC_KEY);
            FileInputStream fis1 = new FileInputStream(file1);
            DataInputStream dis1 = new DataInputStream(fis1);
            byte[] keyBytes1 = new byte[(int) file1.length()];
            dis1.readFully(keyBytes1);
            dis1.close();

            X509EncodedKeySpec spec1 = new X509EncodedKeySpec(keyBytes1);
            KeyFactory kf1 = KeyFactory.getInstance(""RSA"");
            RSAPublicKey pubKey = (RSAPublicKey) kf1.generatePublic(spec1);

            System.out.println(""Exponent :"" + pubKey.getPublicExponent());
            System.out.println(""Modulus"" + pubKey.getModulus());
        }
    }",3
39311251,3,"            File file = new File(PRIVATE_KEY);
            FileInputStream fis = new FileInputStream(file);
            DataInputStream dis = new DataInputStream(fis);

            byte[] keyBytes = new byte[(int) file.length()];
            dis.readFully(keyBytes);
            dis.close();

            PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
            KeyFactory kf = KeyFactory.getInstance(""RSA"");
            RSAPrivateKey privKey = (RSAPrivateKey) kf.generatePrivate(spec);
            System.out.println(""Exponent :"" + privKey.getPrivateExponent());
            System.out.println(""Modulus"" + privKey.getModulus());

            //get the public key",3
39311251,3,"            File file1 = new File(PUBLIC_KEY);
            FileInputStream fis1 = new FileInputStream(file1);
            DataInputStream dis1 = new DataInputStream(fis1);
            byte[] keyBytes1 = new byte[(int) file1.length()];
            dis1.readFully(keyBytes1);
            dis1.close();

            X509EncodedKeySpec spec1 = new X509EncodedKeySpec(keyBytes1);
            KeyFactory kf1 = KeyFactory.getInstance(""RSA"");
            RSAPublicKey pubKey = (RSAPublicKey) kf1.generatePublic(spec1);

            System.out.println(""Exponent :"" + pubKey.getPublicExponent());
            System.out.println(""Modulus"" + pubKey.getModulus());",3
39356436,0,"        byte [] byteKey = key.getBytes(""UTF-8"");
        final String HMAC_SHA256 = ""HmacSHA512"";
        sha512_HMAC = Mac.getInstance(HMAC_SHA256);      
        SecretKeySpec keySpec = new SecretKeySpec(byteKey, HMAC_SHA256);
        sha512_HMAC.init(keySpec);
        byte [] mac_data = sha512_HMAC.",4
39456955,0,"        const int keyStrength = 2048;

        // Generating Random Numbers
        CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
        SecureRandom random = new SecureRandom(randomGenerator);

        // The Certificate Generator
        X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Signature Algorithm",4
39456955,0,"        const int keyStrength = 2048;

        // Generating Random Numbers
        CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
        SecureRandom random = new SecureRandom(randomGenerator);

        // The Certificate Generator
        X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Signature Algorithm
        const string signatureAlgorithm = ""SHA256WithRSA"";
        certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

        // Issuer and Subject Name
        X509Name subjectDN = new X509Name(subjectName);",4
39456955,0,"        const int keyStrength = 2048;

        // Generating Random Numbers
        CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
        SecureRandom random = new SecureRandom(randomGenerator);

        // The Certificate Generator
        X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Signature Algorithm
        const string signatureAlgorithm = ""SHA256WithRSA"";
        certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

        // Issuer and Subject Name
        X509Name subjectDN = new X509Name(subjectName);
        X509Name issuerDN = new X509Name(issuerName);
        certificateGenerator.SetIssuerDN(issuerDN);
        certificateGenerator.SetSubjectDN(subjectDN);

        // Valid For
        DateTime notBefore = DateTime.UtcNow.Date;
        DateTime notAfter = notBefore.AddYears(2);

        certificateGenerator.SetNotBefore(notBefore);
        certificateGenerator.SetNotAfter(notAfter);

        // Subject Public Key
        AsymmetricCipherKeyPair subjectKeyPair;
        var keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
        var keyPairGenerator = new RsaKeyPairGenerator();
        keyPairGenerator.Init(keyGenerationParameters);
        subjectKeyPair = keyPairGenerator.GenerateKeyPair();

        certificateGenerator.SetPublicKey(subjectKeyPair.Public);

        // Generating the Certificate
        AsymmetricCipherKeyPair issuerKeyPair = subjectKeyPair;

        // selfsign certificate
        Org.BouncyCastle.X509.X509Certificate certificate = certificateGenerator.Generate(issuerPrivKey, random);


        // correcponding private key
        PrivateKeyInfo info = PrivateKeyInfoFactory.CreatePrivateKeyInfo(subjectKeyPair.Private);


        // merge into X509Certificate2
        X509Certificate2 x509 = new System.Security.Cryptography.X509Certificates.X509Certificate2(certificate.GetEncoded());

        Asn1Sequence seq = (Asn1Sequence)Asn1Object.FromByteArray(info.PrivateKey.GetDerEncoded());
        if (seq.Count != 9)
        {
            //throw new PemException(""malformed sequence in RSA private key"");
        }

        RsaPrivateKeyStructure rsa = new RsaPrivateKeyStructure(seq);
        RsaPrivateCrtKeyParameters rsaparams = new RsaPrivateCrtKeyParameters(
            rsa.Modulus, rsa.PublicExponent, rsa.PrivateExponent, rsa.Prime1, rsa.Prime2, rsa.Exponent1, rsa.Exponent2, rsa.Coefficient);
",4
39456955,0,"    public static X509Certificate2 GenerateCACertificate(string subjectName, ref AsymmetricKeyParameter CaPrivateKey)
    {
        const int keyStrength = 2048;

        // Generating Random Numbers
        CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
        SecureRandom random = new SecureRandom(randomGenerator);

        // The Certificate Generator
        X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Signature Algorithm
        const string signatureAlgorithm = ""SHA256WithRSA"";
        certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

        // Issuer and Subject Name
        X509Name subjectDN = new X509Name(subjectName);
        X509Name issuerDN = subjectDN;
        certificateGenerator.SetIssuerDN(issuerDN);
        certificateGenerator.SetSubjectDN(subjectDN);

        // Valid For
        DateTime notBefore = DateTime.UtcNow.Date;
        DateTime notAfter = notBefore.AddYears(2);

        certificateGenerator.SetNotBefore(notBefore);
        certificateGenerator.SetNotAfter(notAfter);

        // Subject Public Key
        AsymmetricCipherKeyPair subjectKeyPair;
        KeyGenerationParameters keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
        RsaKeyPairGenerator keyPairGenerator = new RsaKeyPairGenerator();
        keyPairGenerator.Init(keyGenerationParameters);
        subjectKeyPair = keyPairGenerator.GenerateKeyPair();

        certificateGenerator.SetPublicKey(subjectKeyPair.Public);

        // Generating the Certificate
        AsymmetricCipherKeyPair issuerKeyPair = subjectKeyPair;

        // selfsign certificate
        Org.BouncyCastle.X509.X509Certificate certificate = certificateGenerator.Generate(issuerKeyPair.Private, random);
        X509Certificate2 x509 = new System.Security.Cryptography.X509Certificates.X509Certificate2(certificate.GetEncoded());

        CaPrivateKey = issuerKeyPair.Private;

        return x509;
        //return issuerKeyPair.Private;

    }

    public static bool addCertToStore(System.Security.Cryptography.X509Certificates.X509Certificate2 cert, System.Security.Cryptography.X509Certificates.StoreName st, System.Security.Cryptography.X509Certificates.StoreLocation sl)
    {
        bool bRet = false;

        try
        {
            X509Store store = new X509Store(st, sl);
            store.Open(OpenFlags.ReadWrite);
            store.Add(cert);

            store.Close();
        }
        catch
        {

        }

        return bRet;
    }
",4
39456955,0,"        const int keyStrength = 2048;

        // Generating Random Numbers
        CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
        SecureRandom random = new SecureRandom(randomGenerator);

        // The Certificate Generator
        X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Signature Algorithm",4
39456955,0,"        const int keyStrength = 2048;

        // Generating Random Numbers
        CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
        SecureRandom random = new SecureRandom(randomGenerator);

        // The Certificate Generator
        X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Signature Algorithm
        const string signatureAlgorithm = ""SHA256WithRSA"";
        certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

        // Issuer and Subject Name
        X509Name subjectDN = new X509Name(subjectName);",4
39456955,0,"        const int keyStrength = 2048;

        // Generating Random Numbers
        CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
        SecureRandom random = new SecureRandom(randomGenerator);

        // The Certificate Generator
        X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Signature Algorithm
        const string signatureAlgorithm = ""SHA256WithRSA"";
        certificateGenerator.SetSignatureAlgorithm(signatureAlgorithm);

        // Issuer and Subject Name
        X509Name subjectDN = new X509Name(subjectName);
        X509Name issuerDN = subjectDN;
        certificateGenerator.SetIssuerDN(issuerDN);
        certificateGenerator.SetSubjectDN(subjectDN);

        // Valid For
        DateTime notBefore = DateTime.UtcNow.Date;
        DateTime notAfter = notBefore.AddYears(2);

        certificateGenerator.SetNotBefore(notBefore);
        certificateGenerator.SetNotAfter(notAfter);

        // Subject Public Key
        AsymmetricCipherKeyPair subjectKeyPair;
        KeyGenerationParameters keyGenerationParameters = new KeyGenerationParameters(random, keyStrength);
        RsaKeyPairGenerator keyPairGenerator = new RsaKeyPairGenerator();
        keyPairGenerator.Init(keyGenerationParameters);
        subjectKeyPair = keyPairGenerator.GenerateKeyPair();

        certificateGenerator.SetPublicKey(subjectKeyPair.Public);

        // Generating the Certificate
        AsymmetricCipherKeyPair issuerKeyPair = subjectKeyPair;

        // selfsign certificate
        Org.BouncyCastle.X509.X509Certificate certificate = certificateGenerator.Generate(issuerKeyPair.Private, random);",4
39473602,0,"    for (Signature signature : info.signatures) {
        MessageDigest md = MessageDigest.getInstance(""SHA"");
        md.update(signature.toByteArray());
        Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
    }",4
39474381,1,"        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init((KeyStore) null);
        X509TrustManager xtm = (X509TrustManager) tmf.getTrustManagers()[0];",1
39486787,0,"public class EncryptionProvider2 {
    private final String characterEncoding = ""UTF-8"";
    private final String cipherTransformation = ""AES/CBC/PKCS5Padding"";
    private final String aesEncryptionAlgorithm = ""AES"";

    public  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
    {
        Cipher cipher = Cipher.getInstance(cipherTransformation);
        SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);
        cipherText = cipher.doFinal(cipherText);
        return cipherText;
    }

    public byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
    {
        Cipher cipher = Cipher.getInstance(cipherTransformation);
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
        plainText = cipher.doFinal(plainText);
        return plainText;
    }

    private byte[] getKeyBytes(String key) throws UnsupportedEncodingException {
        byte[] keyBytes= new byte[16];
        byte[] parameterKeyBytes= key.getBytes(characterEncoding);
        System.arraycopy(parameterKeyBytes, 0, keyBytes, 0, Math.min(parameterKeyBytes.length, keyBytes.length));
        return keyBytes;
    }


    public String encrypt(String plainText, String key) throws UnsupportedEncodingException, InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException{
        byte[] plainTextbytes = plainText.getBytes(characterEncoding);
        byte[] keyBytes = getKeyBytes(key);
        return Base64.encodeToString(encrypt(plainTextbytes,keyBytes, keyBytes), Base64.NO_WRAP);
    }


    public String decrypt(String encryptedText, String key) throws KeyException, GeneralSecurityException, GeneralSecurityException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, IOException {
        byte[] cipheredBytes = Base64.decode(encryptedText, Base64.NO_WRAP);
        byte[] keyBytes = getKeyBytes(key);
        return new String(decrypt(cipheredBytes, keyBytes, keyBytes), characterEncoding);
    }
}",2
39486787,0,"    public  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
    {
        Cipher cipher = Cipher.getInstance(cipherTransformation);
        SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);
        cipherText = cipher.doFinal(cipherText);
        return cipherText;
    }
",2
39486787,0,"    public  byte[] decrypt(byte[] cipherText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
    {
        Cipher cipher = Cipher.getInstance(cipherTransformation);
        SecretKeySpec secretKeySpecy = new SecretKeySpec(key, aesEncryptionAlgorithm);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);
        cipherText = cipher.doFinal(cipherText);
        return cipherText;
    }

    public byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
    {
        Cipher cipher = Cipher.getInstance(cipherTransformation);
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
        plainText = cipher.doFinal(plainText);
        return plainText;
    }
",2
39486787,0,"    public byte[] encrypt(byte[] plainText, byte[] key, byte [] initialVector) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException
    {
        Cipher cipher = Cipher.getInstance(cipherTransformation);
        SecretKeySpec secretKeySpec = new SecretKeySpec(key, aesEncryptionAlgorithm);
        IvParameterSpec ivParameterSpec = new IvParameterSpec(initialVector);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
        plainText = cipher.doFinal(plainText);
        return plainText;
    }
",2
39487469,0,"        KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
        keyGen.init(128);
        SecretKey secretKey = keyGen.generateKey();

        final int AES_KEYLENGTH = 128;  
        byte[] iv = new byte[AES_KEYLENGTH / 8];    
        SecureRandom prng = new SecureRandom();
        prng.nextBytes(iv);
",5
39487469,0,"        byte[] byteDataToEncrypt = bigIntToEncrypt.toByteArray();
        byte[] byteCipherText = aesCipherForEncryption.doFinal(byteDataToEncrypt);

        BigInteger chipherBigInt = new BigInteger(byteCipherText);
        System.out.println(""Cipher Int generated using AES is "" + chipherBigInt);


        Cipher aesCipherForDecryption = Cipher.getInstance(""AES/CBC/PKCS5PADDING""); 

        aesCipherForDecryption.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
        byte[] byteDecryptedText = aesCipherForDecryption.doFinal(byteCipherText);",2
39487469,0,"        BigInteger chipherBigInt = new BigInteger(byteCipherText);
        System.out.println(""Cipher Int generated using AES is "" + chipherBigInt);


        Cipher aesCipherForDecryption = Cipher.getInstance(""AES/CBC/PKCS5PADDING""); 

        aesCipherForDecryption.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
        byte[] byteDecryptedText = aesCipherForDecryption.doFinal(byteCipherText);
        BigInteger decryptedInt = new BigInteger(byteDecryptedText);

        System.out.println("" Decrypted Text message is "" + decryptedInt);

    } catch (NoSuchAlgorithmException noSuchAlgo) {
        System.out.println("" No Such Algorithm exists "" + noSuchAlgo);
    } catch (NoSuchPaddingException noSuchPad) {
        System.out.println("" No Such Padding exists "" + noSuchPad);
    } catch (InvalidKeyException invalidKey) {
        System.out.println("" Invalid Key "" + invalidKey);
    } catch (BadPaddingException badPadding) {
        System.out.println("" Bad Padding "" + badPadding);
    } catch (IllegalBlockSizeException illegalBlockSize) {
        System.out.println("" Illegal Block Size "" + illegalBlockSize);
    } catch (InvalidAlgorithmParameterException invalidParam) {
        System.out.println("" Invalid Parameter "" + invalidParam);
    }
",2
39487469,1,"        KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");
        keyGen.init(128);
        SecretKey secretKey = keyGen.generateKey();

        final int AES_KEYLENGTH = 128;  
        byte[] iv = new byte[AES_KEYLENGTH / 8];    
        SecureRandom prng = new SecureRandom();
        prng.nextBytes(iv);
",5
39487469,1,"        byte[] byteDataToEncrypt = dataToEncrypt.getBytes();
        byte[] byteCipherText = aesCipherForEncryption.doFinal(byteDataToEncrypt);

        BigInteger chipherBigInt = new BigInteger(byteCipherText);
        System.out.println(""Cipher Int generated using AES is "" + chipherBigInt);


        Cipher aesCipherForDecryption = Cipher.getInstance(""AES/CBC/PKCS5PADDING""); 

        aesCipherForDecryption.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
        byte[] byteDecryptedText = aesCipherForDecryption.doFinal(byteCipherText);",2
39487469,1,"        BigInteger chipherBigInt = new BigInteger(byteCipherText);
        System.out.println(""Cipher Int generated using AES is "" + chipherBigInt);


        Cipher aesCipherForDecryption = Cipher.getInstance(""AES/CBC/PKCS5PADDING""); 

        aesCipherForDecryption.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(iv));
        byte[] byteDecryptedText = aesCipherForDecryption.doFinal(byteCipherText);
        String decryptedInt = new String(byteDecryptedText);

        System.out.println("" Decrypted Text message is "" + decryptedInt);

    } catch (NoSuchAlgorithmException noSuchAlgo) {
        System.out.println("" No Such Algorithm exists "" + noSuchAlgo);
    } catch (NoSuchPaddingException noSuchPad) {
        System.out.println("" No Such Padding exists "" + noSuchPad);
    } catch (InvalidKeyException invalidKey) {
        System.out.println("" Invalid Key "" + invalidKey);
    } catch (BadPaddingException badPadding) {
        System.out.println("" Bad Padding "" + badPadding);
    } catch (IllegalBlockSizeException illegalBlockSize) {
        System.out.println("" Illegal Block Size "" + illegalBlockSize);
    } catch (InvalidAlgorithmParameterException invalidParam) {
        System.out.println("" Invalid Parameter "" + invalidParam);
    }
",2
39515446,1,"    private static PrivateKey loadPrivateKeyFromPemFile(KeyFactory factory, String filename)
            throws InvalidKeySpecException, FileNotFoundException, IOException {
        PemFile pemFile = new PemFile(filename);
        byte[] content = pemFile.getPemObject().getContent();
        PKCS8EncodedKeySpec privKeySpec = new PKCS8EncodedKeySpec(content);
        return factory.generatePrivate(privKeySpec);
    }
",3
39565618,3,"        byte[] a = encryptCipher.doFinal(seed.getBytes());
        byte[] encodeUrl = Base64.getEncoder().encode(a);
//      byte[] encodeUrl = Base64.encodeBase64(sEncription.encrypt(m));
        String finalUrl = new String(encodeUrl);
        String finalResult = finalUrl.substring(2, 8) + finalUrl.substring(10, 13);
        System.out.println(finalUrl);
        System.out.println(finalResult);",2
39565618,8,"        byte[] a = encryptCipher.doFinal(seedMd5.getBytes());
        byte[] encodeUrl = Base64.getEncoder().encode(a);
        String finalUrl = new String(encodeUrl);
        String finalResult = finalUrl.substring(2, 8) + finalUrl.substring(10, 13);
        System.out.println(finalUrl);
        System.out.println(finalResult);",2
39615507,0,"    public static byte[] encrypt(byte[] publicKey, byte[] inputData)
            throws Exception {

        PublicKey key = KeyFactory.getInstance(ALGORITHM)
                .generatePublic(new X509EncodedKeySpec(publicKey));

        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.PUBLIC_KEY, key);

        byte[] encryptedBytes = cipher.doFinal(inputData);

        return encryptedBytes;
    }
",3
39615507,0,"    public static byte[] decrypt(byte[] privateKey, byte[] inputData)
            throws Exception {

        PrivateKey key = KeyFactory.getInstance(ALGORITHM)
                .generatePrivate(new PKCS8EncodedKeySpec(privateKey));

        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.PRIVATE_KEY, key);

        byte[] decryptedBytes = cipher.doFinal(inputData);

        return decryptedBytes;
    }
",3
39674438,0,"        for (Signature signature: info.signatures){
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.e(""Your System KEYHASH : "", Base64.encodeToString(md.digest(), Base64.DEFAULT));
        }",4
39773109,0,"    Mac shaMac = Mac.getInstance(""HmacSHA512"");
    SecretKeySpec keySpec = new SecretKeySpec(secret.getBytes(), ""HmacSHA512"");
    shaMac.init(keySpec);
    final byte[] macData = shaMac.doFinal(queryArgs.getBytes());",4
39823641,0,"private static KeyStore buildKeyStore(Context context, int certRawResId){
    // init a default key store
    String keyStoreType = KeyStore.getDefaultType();
    KeyStore keyStore = null;
    try {
        keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);

        // read and add certificate authority
        Certificate cert = readCert(context, certRawResId);
        keyStore.setCertificateEntry(""ca"", cert);


    } catch (CertificateException e) {
        e.printStackTrace();
    } catch (NoSuchAlgorithmException e) {
        e.printStackTrace();
    } catch (KeyStoreException e) {
        e.printStackTrace();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return keyStore;

}
",1
39823641,0,"    InputStream caInput = context.getResources().openRawResource(certResourceId);

    Certificate ca = null;
    try {
        // generate a certificate
        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        ca = cf.generateCertificate(caInput);
    } catch (CertificateException e) {
        e.printStackTrace();",1
39883606,0,"public class sample{
 public void foo(){
OkHttpClient client = new OkHttpClient();
SSLContext sslContext = SslUtils.getSslContextForCertificateFile(context, ""BPClass2RootCA-sha2.cer"");
client.setSslSocketFactory(sslContext.getSocketFactory());

}",1
39920756,0,"                public static PGPPublicKey readPublicKey( 
                        InputStream    in) 
                        throws IOException, PGPException 
                    { 
                        in = PGPUtil.getDecoderStream(in); 

                        PGPPublicKeyRingCollection        pgpPub = new PGPPublicKeyRingCollection(in); 

                        // 
                        // we just loop through the collection till we find a key suitable for encryption, in the real 
                        // world you would probably want to be a bit smarter about this. 
                        // 

                        // 
                        // iterate through the key rings. 
                        // 
                        Iterator<?> rIt = pgpPub.getKeyRings(); 

                        while (rIt.hasNext()) 
                        { 
                            PGPPublicKeyRing    kRing = (PGPPublicKeyRing)rIt.next();     
                            Iterator<?>                        kIt = kRing.getPublicKeys(); 

                            while (kIt.hasNext()) 
                            { 
                                PGPPublicKey    k = (PGPPublicKey)kIt.next(); 

                                if (k.isEncryptionKey()) 
                                { 
                                    return k; 
                                } 
                            } 
                        } 

                        throw new IllegalArgumentException(""Can't find encryption key in key ring.""); 
                    } 
",4
39920756,0,"                        Iterator<?> rIt = pgpPub.getKeyRings(); 

                        while (rIt.hasNext()) 
                        { 
                            PGPPublicKeyRing    kRing = (PGPPublicKeyRing)rIt.next();     
                            Iterator<?>                        kIt = kRing.getPublicKeys(); 

                            while (kIt.hasNext()) 
                            { 
                                PGPPublicKey    k = (PGPPublicKey)kIt.next(); 

                                if (k.isEncryptionKey()) 
                                { 
                                    return k; 
                                } 
                            } 
                        } 

                        throw new IllegalArgumentException(""Can't find encryption key in key ring.""); ",4
39920756,0,"                            Iterator<?>                        kIt = kRing.getPublicKeys(); 

                            while (kIt.hasNext()) 
                            { 
                                PGPPublicKey    k = (PGPPublicKey)kIt.next(); 

                                if (k.isEncryptionKey()) 
                                { 
                                    return k; 
                                } 
                            } ",4
39960166,0,"    Cipher cipher = Cipher.getInstance(ENC_ALG);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALG);

    KeySpec keySpec = new PBEKeySpec(PASSWORD.toCharArray(), SALT, 65536, 256);
    SecretKey key = keyFactory.generateSecret(keySpec);

    IvParameterSpec ivSpec = new IvParameterSpec(IV);    
    PBEParameterSpec paramSpec = new PBEParameterSpec(SALT, 0,ivSpec);

    cipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);",2
39960166,0,"    Cipher cipher = Cipher.getInstance(ENC_ALG);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(KEY_ALG);

    KeySpec keySpec = new PBEKeySpec(PASSWORD.toCharArray(), SALT, 65536, 256);
    SecretKey key = keyFactory.generateSecret(keySpec);
    IvParameterSpec ivSpec = new IvParameterSpec(IV);    
    PBEParameterSpec paramSpec = new PBEParameterSpec(SALT, 0, ivSpec);
    cipher.init(Cipher.DECRYPT_MODE, key, paramSpec);",2
39974172,0,"    public static final void jumpToOffset(final Cipher c, final SecretKeySpec aesKey, final IvParameterSpec iv, final long offset) {
        if (!c.getAlgorithm().toUpperCase().startsWith(""AES/CTR"")) {
            throw new IllegalArgumentException(""Invalid algorithm, only AES/CTR mode supported"");
        }
        if (offset < 0) {
            throw new IllegalArgumentException(""Invalid offset"");
        }
        final int skip = (int) (offset % AES_BLOCK_SIZE);
        final IvParameterSpec calculatedIVForOffset = calculateIVForOffset(iv, offset - skip);
        try {
            c.init(Cipher.ENCRYPT_MODE, aesKey, calculatedIVForOffset);
            final byte[] skipBuffer = new byte[skip];
            c.update(skipBuffer, 0, skip, skipBuffer);
            Arrays.fill(skipBuffer, (byte) 0);
        } catch (ShortBufferException | InvalidKeyException | InvalidAlgorithmParameterException e) {
            throw new IllegalStateException(e);
        }
    }

    private static IvParameterSpec calculateIVForOffset(final IvParameterSpec iv, final long blockOffset) {

        final BigInteger ivBI = new BigInteger(1, iv.getIV());
        final BigInteger ivForOffsetBI = ivBI.add(BigInteger.valueOf(blockOffset / AES_BLOCK_SIZE));
        final byte[] ivForOffsetBA = ivForOffsetBI.toByteArray();
        final IvParameterSpec ivForOffset;
        if (ivForOffsetBA.length >= AES_BLOCK_SIZE) {
            ivForOffset = new IvParameterSpec(ivForOffsetBA, ivForOffsetBA.length - AES_BLOCK_SIZE, AES_BLOCK_SIZE);
        } else {
            final byte[] ivForOffsetBASized = new byte[AES_BLOCK_SIZE];
            System.arraycopy(ivForOffsetBA, 0, ivForOffsetBASized, AES_BLOCK_SIZE - ivForOffsetBA.length, ivForOffsetBA.length);
            ivForOffset = new IvParameterSpec(ivForOffsetBASized);
        }
        return ivForOffset;
    }
",2
39994873,0,"    KeyParameter keyParam = new KeyParameter(Convert.FromBase64String(keyStringBase64));
    ParametersWithIV keyParamWithIV = new ParametersWithIV(keyParam, iv, 0, 16);

    // Encrypt
    cipher.Init(true, keyParamWithIV);
    byte[] outputBytes = new byte[cipher.GetOutputSize(inputBytes.Length)];
    int length = cipher.ProcessBytes(inputBytes, outputBytes, 0);
    cipher.DoFinal(outputBytes, length); //Do the final block",2
39996033,0,"    if (url.indexOf(""wss"") == 0) {
        try {
            SSLContext sslContext = SSLContext.getDefault();
            mWebSocketClient.setWebSocketFactory(new DefaultSSLWebSocketClientFactory(sslContext));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
",1
40082847,0,"public class sample{
 public void foo(){
KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(
                              KeyManagerFactory.getDefaultAlgorithm());
kmfactory.init(trustStore, ""password"".toCharArray());
KeyManager[] keymanagers =  kmfactory.getKeyManagers();

TrustManagerFactory tmf=TrustManagerFactory
  .getInstance(TrustManagerFactory.getDefaultAlgorithm());

tmf.init(trustStore);

SSLContext sslContext=SSLContext.getInstance(""TLSv1.2"");

sslContext.init(keymanagers, tmf.getTrustManagers(), new SecureRandom());

SSLSocketFactory factory=sslContext.getSocketFactory();

}",1
40092087,1,"public class sample{
private static String convertToHex(byte[] data) {
    StringBuilder buf = new StringBuilder();
    for (byte b : data) {
        int halfbyte = (b >>> 4) & 0x0F;
        int two_halfs = 0;
        do {
            buf.append((0 <= halfbyte) && (halfbyte <= 9) ? (char) ('0' + halfbyte) : (char) ('a' + (halfbyte - 10)));
            halfbyte = b & 0x0F;
        } while (two_halfs++ < 1);
    }
    return buf.toString();
}

public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {
    MessageDigest md = MessageDigest.getInstance(""SHA-1"");
    byte[] textBytes = text.getBytes(""iso-8859-1"");
    md.update(textBytes, 0, textBytes.length);
    byte[] sha1hash = md.digest();
    return convertToHex(sha1hash);
}
SHA1(""test""); //a94a8fe5ccb19ba61c4c0873d391e987982fbbd3
",4
40092087,1,"    MessageDigest md = MessageDigest.getInstance(""SHA-1"");
    byte[] textBytes = text.getBytes(""iso-8859-1"");
    md.update(textBytes, 0, textBytes.length);
    byte[] sha1hash = md.digest();",4
40099635,0,"    CipherOutputStream cos = new CipherOutputStream(fos, cipher);
    // Write bytes
    int b;
    byte[] d = new byte[8];
    while((b = fis.read(d)) != -1) {
        cos.write(d, 0, b);
    }
    // Flush and close streams.
    cos.flush();
    cos.close();
    fis.close();",2
40141737,1,"        try {
            java.security.cert.Certificate[] certs = keyStore.getCertificateChain(alias);
            if (certs == null || certs.length == 0)
                return null;
            X509Certificate[] x509 = new X509Certificate[certs.length];
            for (int i = 0; i < certs.length; i++)
                x509[i] = (X509Certificate)certs[i];
            return x509;",1
40175319,1,"public static byte[] encryptMsg(String message, SecretKey secret)
    throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException 
{ 
   /* Encrypt the message. */
   Cipher cipher = null; 
   cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
   cipher.init(Cipher.ENCRYPT_MODE, secret); 
   byte[] cipherText = cipher.doFinal(message.getBytes(""UTF-8"")); 
   return cipherText; 
}

public static String decryptMsg(byte[] cipherText, SecretKey secret) 
    throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidParameterSpecException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException 
{
    /* Decrypt the message, given derived encContentValues and initialization vector. */
    Cipher cipher = null;
    cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, secret); 
    String decryptString = new String(cipher.doFinal(cipherText), ""UTF-8"");
    return decryptString; 
}
",2
40192264,0,"byte[] publicBytes = org.apache.commons.codec.binary.Hex.decodeHex(arg.toCharArray());

BigInteger modulus = new BigInteger(1, publicBytes);
BigInteger publicExponent = BigInteger.valueOf(65537L);

RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, publicExponent);

KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
PublicKey pubKey = keyFactory.generatePublic(keySpec);
",3
40192680,0,"        byte[] publicBytes = org.apache.commons.codec.binary.Hex.decodeHex(arg.toCharArray());

        BigInteger modulus = new BigInteger(1, publicBytes);
        BigInteger publicExponent = BigInteger.valueOf(65537L);

        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, publicExponent);

        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        PublicKey pubKey = keyFactory.generatePublic(keySpec);
",3
40198170,1,"    public Socket createSocket(InetAddress host, int port) throws IOException
    {
        SSLSocketFactory factory = mSSLContext.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);

        ss.setEnabledProtocols(mProtocols);
        ss.setEnabledCipherSuites(mCiphers);

        return ss;
    }
",1
40198170,1,"    public Socket createSocket(String host, int port) throws IOException
    {
        SSLSocketFactory factory = mSSLContext.getSocketFactory();
        SSLSocket ss = (SSLSocket)factory.createSocket(host, port);

        ss.setEnabledProtocols(mProtocols);
        ss.setEnabledCipherSuites(mCiphers);

        return ss;
    }
",1
40213408,0,"public String getPublicKeyAsHex(PublicKey publicKey){

    ECPublicKey ecPublicKey = (ECPublicKey)publicKey;
    ECPoint ecPoint = ecPublicKey.getW();

    byte[] publicKeyBytes = new byte[PUBLIC_KEY_LENGTH];
    writeToStream(publicKeyBytes, 0, ecPoint.getAffineX(), PRIVATE_KEY_LENGTH);
    writeToStream(publicKeyBytes, PRIVATE_KEY_LENGTH, ecPoint.getAffineY(), PRIVATE_KEY_LENGTH);

    String hex = Hex.toHexString(publicKeyBytes);

    logger.debug(""Public key bytes: "" + Arrays.toString(publicKeyBytes));
    logger.debug(""Public key hex: "" + hex);

    return hex;
}

private void writeToStream(byte[] stream, int start, BigInteger value, int size) {
    byte[] data = value.toByteArray();
    int length = Math.min(size, data.length);
    int writeStart = start + size - length;
    int readStart = data.length - length;
    System.arraycopy(data, readStart, stream, writeStart, length);
}
",3
40339837,0,"        for (Signature signature : info.signatures) {
            MessageDigest md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
40372857,0,"MessageDigest md = MessageDigest.getInstance(""SHA-1"");
byte[] textBytes = text.getBytes(""UTF-8"");
md.update(textBytes, 0, textBytes.length);
byte[] sha1hash = md.digest();
",4
40372905,0,"public class sample{
String sha1Hash( String toHash )
{
    String hash = null;
    try
    {
        MessageDigest digest = MessageDigest.getInstance( ""SHA-1"" );
        byte[] bytes = toHash.getBytes(""UTF-8"");
        digest.update(bytes, 0, bytes.length);
        bytes = digest.digest();

        // This is ~55x faster than looping and String.formating()
        hash = bytesToHex( bytes );
    }
    catch( NoSuchAlgorithmException e )
    {
        e.printStackTrace();
    }
    catch( UnsupportedEncodingException e )
    {
        e.printStackTrace();
    }
    return hash;
}

// http://stackoverflow.com/questions/9655181/convert-from-byte-array-to-hex-string-in-java
final protected static char[] hexArray = ""0123456789ABCDEF"".toCharArray();
public static String bytesToHex( byte[] bytes )
{
    char[] hexChars = new char[ bytes.length * 2 ];
    for( int j = 0; j < bytes.length; j++ )
    {
        int v = bytes[ j ] & 0xFF;
        hexChars[ j * 2 ] = hexArray[ v >>> 4 ];
        hexChars[ j * 2 + 1 ] = hexArray[ v & 0x0F ];
    }
    return new String( hexChars );
}
",4
40427228,0,"public class sample{
 public void foo(){
PBKDF_SecretKeyFactory kf = new PBKDF_SecretKeyFactory(""HmacSHA512"");
KeySpec ks = new PBEKeySpec(password,salt,iterations,bitlen);
byte key[] = kf.engineGenerateSecret(ks).getEncoded();

}",2
40427228,1,"public class sample{
public byte[] hash(String password) throws NoSuchAlgorithmException
{   
    MessageDigest sha256 = MessageDigest.getInstance(""SHA-256"");        
    byte[] passBytes = password.getBytes();
    byte[] passHash = sha256.digest(passBytes);
    return passHash;
}
",4
40716134,0,"private String getPublicKeyAsHex(PublicKey publicKey) {

    ECPublicKey ecPublicKey = (ECPublicKey) publicKey;
    ECPoint ecPoint = ecPublicKey.getW();

    byte[] publicKeyBytes = new byte[PUBLIC_KEY_LENGTH];
    writeToStream(publicKeyBytes, 0, ecPoint.getAffineX(), PRIVATE_KEY_LENGTH);
    writeToStream(publicKeyBytes, PRIVATE_KEY_LENGTH, ecPoint.getAffineY(), PRIVATE_KEY_LENGTH);

    String hex = Hex.toHexString(publicKeyBytes);

    logger.debug(""Public key bytes: "" + Arrays.toString(publicKeyBytes));
    logger.debug(""Public key hex: "" + hex);

    return hex;
}

private void writeToStream(byte[] stream, int start, BigInteger value, int size) {
    byte[] data = value.toByteArray();
    int length = Math.min(size, data.length);
    int writeStart = start + size - length;
    int readStart = data.length - length;
    System.arraycopy(data, readStart, stream, writeStart, length);
}
",3
40727145,1,"public class sample{
 public void foo(){
Signature sig = Signature.getInstance(""SHA1withRSA"");
sig.initVerify(publicKey);
sig.update(challenge);
boolean verifies = sig.verify(signedchallenge);

}",4
40737563,0,"        Key key = generateKey();
        Cipher c = Cipher.getInstance(ALGORITHM);  
        c.init(Cipher.ENCRYPT_MODE, key);

        String valueToEnc = null;
        String eValue = value;",2
40737563,0,"        Key key = generateKey();
        Cipher c = Cipher.getInstance(ALGORITHM);
        c.init(Cipher.DECRYPT_MODE, key);

        String dValue = null;
        String valueToDecrypt = value;",2
40777866,8,"  MessageDigest mDigest = MessageDigest.getInstance(""SHA-256"");
  byte[] result = mDigest.digest(input.getBytes());
  StringBuffer sb = new StringBuffer();",4
40849582,1,"        const int keyStrength = 2048;

        // Generating Random Numbers
        CryptoApiRandomGenerator randomGenerator = new CryptoApiRandomGenerator();
        SecureRandom random = new SecureRandom(randomGenerator);

        // The Certificate Generator
        X509V3CertificateGenerator certificateGenerator = new X509V3CertificateGenerator();

        // Serial Number
        BigInteger serialNumber = BigIntegers.CreateRandomInRange(BigInteger.One, BigInteger.ValueOf(Int64.MaxValue), random);
        certificateGenerator.SetSerialNumber(serialNumber);

        // Signature Algorithm",4
40849582,1,"        Asn1Sequence seq = (Asn1Sequence)Asn1Object.FromByteArray(info.PrivateKey.GetDerEncoded());
        if (seq.Count != 9)
        {
            throw new PemException(""malformed sequence in RSA private key"");
        }

        RsaPrivateKeyStructure rsa = new RsaPrivateKeyStructure(seq);
        RsaPrivateCrtKeyParameters rsaparams = new RsaPrivateCrtKeyParameters(rsa.Modulus, rsa.PublicExponent, rsa.PrivateExponent, rsa.Prime1, rsa.Prime2, rsa.Exponent1, rsa.Exponent2, rsa.Coefficient);

        x509.PrivateKey = ToDotNetKey(rsaparams);
",3
40849582,1,"        Asn1Sequence seq = (Asn1Sequence)Asn1Object.FromByteArray(info.PrivateKey.GetDerEncoded());
        if (seq.Count != 9)
        {
            throw new PemException(""malformed sequence in RSA private key"");
        }

        RsaPrivateKeyStructure rsa = new RsaPrivateKeyStructure(seq);
        RsaPrivateCrtKeyParameters rsaparams = new RsaPrivateCrtKeyParameters(rsa.Modulus, rsa.PublicExponent, rsa.PrivateExponent, rsa.Prime1, rsa.Prime2, rsa.Exponent1, rsa.Exponent2, rsa.Coefficient);

        x509.PrivateKey = ToDotNetKey(rsaparams);
",3
40874952,2,"TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
trustManagerFactory.init((KeyStore) null);
TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
    throw new IllegalStateException(""Unexpected default trust managers:"" + Arrays.toString(trustManagers));
}",1
40878298,0,"    try {
        Mac hmac = Mac.getInstance(""HmacSHA256"");
        SecretKeySpec secret_key = new SecretKeySpec(key.getBytes(""UTF-8""), ""HmacSHA256"");
        hmac.init(secret_key);
        return new String(Hex.encodeHex(hmac.doFinal(data.getBytes(""UTF-8""))));",4
40881939,0,"        Signature rsaSign = Signature.getInstance(""SHA256withRSA"", ""BC"");
        rsaSign.initSign(pair.getPrivate());
        rsaSign.update(plaintext.getBytes(""UTF-8""));
        byte[] signature = rsaSign.sign();",4
40925092,0,"    InputStream caInput = context.getResources().openRawResource(keystoreResId);

    // creating a KeyStore containing trusted CAs

    if (keyStoreType == null || keyStoreType.length() == 0) {
        keyStoreType = KeyStore.getDefaultType();
    }
    KeyStore keyStore = KeyStore.getInstance(keyStoreType);",2
40978042,0,"            KeyFactory keyFac = KeyFactory.getInstance(""RSA"");
            KeySpec keySpec = new X509EncodedKeySpec(Base64.decode(publicKey.trim().getBytes(), Base64.DEFAULT));
            Key key = keyFac.generatePublic(keySpec);

            // get an RSA cipher object and print the provider
            final Cipher cipher = Cipher.getInstance(""RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING"");
            // encrypt the plain text using the public key
            cipher.init(Cipher.ENCRYPT_MODE, key);
",3
40978042,0,"            Key key = keyFac.generatePublic(keySpec);

            // get an RSA cipher object and print the provider
            final Cipher cipher = Cipher.getInstance(""RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING"");
            // encrypt the plain text using the public key
            cipher.init(Cipher.ENCRYPT_MODE, key);

            byte[] encryptedBytes = cipher.doFinal(clearText.getBytes(""UTF-8""));",3
40978042,0,"            KeyFactory keyFac = KeyFactory.getInstance(""RSA"");
            KeySpec keySpec = new PKCS8EncodedKeySpec(Base64.decode(privateKey.trim().getBytes(), Base64.DEFAULT));
            Key key = keyFac.generatePrivate(keySpec);

            // get an RSA cipher object and print the provider
            final Cipher cipher = Cipher.getInstance(""RSA/ECB/OAEPWITHSHA-256ANDMGF1PADDING"");
            // encrypt the plain text using the public key
            cipher.init(Cipher.DECRYPT_MODE, key);
",3
41162646,1,"        SecretKeySpec key = new SecretKeySpec((keyString).getBytes(""UTF-8""),
                ""HmacSHA1"");
        Mac mac = Mac.getInstance(""HmacSHA1"");
        mac.init(key);

        byte[] bytes = mac.doFinal(s.getBytes(""UTF-8""));
",4
41188412,1,"    private static Registry<ConnectionSocketFactory> getRegistry() throws KeyManagementException, NoSuchAlgorithmException {
        SSLContext sslContext = SSLContexts.custom().build();
        SSLConnectionSocketFactory sslConnectionSocketFactory = new SSLConnectionSocketFactory(sslContext,
                new String[]{""TLSv1.2""}, null, SSLConnectionSocketFactory.getDefaultHostnameVerifier());
        return RegistryBuilder.<ConnectionSocketFactory>create()
            .register(""http"", PlainConnectionSocketFactory.getSocketFactory())
            .register(""https"", sslConnectionSocketFactory)
            .build();
    }

   // for TLSv1.2 use:  ",1
41202589,1,"SecureRandom random = new SecureRandom();
byte[] salt = new byte[8];
random.nextBytes(salt);

// Create PBE parameter set
PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, count);
PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());",2
41223999,0,"        Key key = generateKey();
        Cipher cipher = Cipher.getInstance(AESCrypt.ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, key);
        byte[] decryptedValue64 = Base64.decode(value, Base64.DEFAULT);
        byte [] decryptedByteValue = cipher.doFinal(decryptedValue64);",2
41243646,0,"public static byte[] encrypt(String text, PublicKey key) {
    byte[] cipherText = null;
    try {
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, key);
        cipherText = cipher.doFinal(text.getBytes());
    }
    catch (Exception e) {
        e.printStackTrace();
    }
    return cipherText;
}
",3
41243646,1,"public static byte[] encrypt(String text, PublicKey key) {
    byte[] cipherText = null;
    try {
        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, key);
        cipherText = cipher.doFinal(text.getBytes());
    }
    catch (Exception e) {
        e.printStackTrace();
    }
    return cipherText;
}
",3
41259268,1,"public class sample{
 public void foo(){
Signature sig = Signature.getInstance(""SHA256withRSA""); 
sig.initVerify(publicKey);
sig.update(data);  
boolean verifies = sig.verify(signature);

}",4
41317358,1,"    public static byte[] encrypt(byte[] data, String initVector, String key) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
            Cipher c = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            SecretKeySpec k = new SecretKeySpec(Base64.decode(key, Base64.DEFAULT), ""AES"");
            c.init(Cipher.ENCRYPT_MODE, k, iv);
            return c.doFinal(data);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }
",2
41317358,1,"    public static byte[] decrypt(byte[] data, String initVector, String key) {
        try {
            IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
            Cipher c = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
            SecretKeySpec k = new SecretKeySpec(Base64.decode(key, Base64.DEFAULT), ""AES"");
            c.init(Cipher.DECRYPT_MODE, k, iv);
            return c.doFinal(data);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }
",2
41434590,2,"Cipher aesCBC = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
aesCBC.init(Cipher.DECRYPT_MODE, key, iv);
byte[] decryptedData = aesCBC.doFinal(encrypted);
String decryptedText = new String(decryptedData, StandardCharsets.UTF_8);

System.out.println(decryptedText);
",2
41441101,2,"public static SecretKey generateKey(char[] passphraseOrPin, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    // Number of PBKDF2 hardening rounds to use. Larger values increase
    // computation time. You should select a value that causes computation
    // to take >100ms.
    final int iterations = 1000; 

    // Generate a 256-bit key
    final int outputKeyLength = 256;

    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength);
    SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
    return secretKey;",2
41466557,1,"public static class TLSSocketFactory extends SSLSocketFactory {

    private SSLSocketFactory internalSSLSocketFactory;

    public TLSSocketFactory(SSLSocketFactory delegate) throws KeyManagementException, NoSuchAlgorithmException {
        internalSSLSocketFactory = delegate;
    }

    @Override
    public String[] getDefaultCipherSuites() {
        return internalSSLSocketFactory.getDefaultCipherSuites();
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return internalSSLSocketFactory.getSupportedCipherSuites();
    }

    @Override
    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
    }

    /*
     * Utility methods
     */

    private static Socket enableTLSOnSocket(Socket socket) {
        if (socket != null && (socket instanceof SSLSocket)
                && isTLSServerEnabled((SSLSocket) socket)) { // skip the fix if server doesn't provide there TLS version
            ((SSLSocket) socket).setEnabledProtocols(new String[]{TLS_v1_1, TLS_v1_2});
        }
        return socket;
    }

    private static boolean isTLSServerEnabled(SSLSocket sslSocket) {
        System.out.println(""__prova__ :: "" + sslSocket.getSupportedProtocols().toString());
        for (String protocol : sslSocket.getSupportedProtocols()) {
            if (protocol.equals(TLS_v1_1) || protocol.equals(TLS_v1_2)) {
                return true;
            }
        }
        return false;
    }
}",1
41466557,1,"    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
    }

    /*
     * Utility methods
     */
",1
41466557,1,"    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override",1
41466679,1,"public static class TLSSocketFactory extends SSLSocketFactory {

    private SSLSocketFactory internalSSLSocketFactory;

    public TLSSocketFactory(SSLSocketFactory delegate) throws KeyManagementException, NoSuchAlgorithmException {
        internalSSLSocketFactory = delegate;
    }

    @Override
    public String[] getDefaultCipherSuites() {
        return internalSSLSocketFactory.getDefaultCipherSuites();
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return internalSSLSocketFactory.getSupportedCipherSuites();
    }

    @Override
    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
    }

    /*
     * Utility methods
     */

    private static Socket enableTLSOnSocket(Socket socket) {
        if (socket != null && (socket instanceof SSLSocket)
                && isTLSServerEnabled((SSLSocket) socket)) { // skip the fix if server doesn't provide the TLS version
            ((SSLSocket) socket).setEnabledProtocols(new String[]{TLS_v1_1, TLS_v1_2});
        }
        return socket;
    }

    private static boolean isTLSServerEnabled(SSLSocket sslSocket) {
        System.out.println(""__prova__ :: "" + sslSocket.getSupportedProtocols().toString());
        for (String protocol : sslSocket.getSupportedProtocols()) {
            if (protocol.equals(TLS_v1_1) || protocol.equals(TLS_v1_2)) {
                return true;
            }
        }
        return false;
    }
}",1
41466679,1,"    public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
    }

    /*
     * Utility methods
     */
",1
41466679,1,"    public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
        return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
    }

    @Override",1
41495143,0,"    final SecretKeySpec key = new SecretKeySpec(keyValue, ""AES"");

    final Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
    cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));
    byte[] data = cipher.doFinal(inBytes);",2
41495143,0,"    final byte[] salt = Arrays.copyOfRange(inBytes, SALTED_MAGIC.length, SALTED_MAGIC.length + 8);

    final byte[] passAndSalt = array_concat(pass, salt);

    byte[] hash = new byte[0];
    byte[] keyAndIv = new byte[0];",2
41527822,4,"TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(
        TrustManagerFactory.getDefaultAlgorithm());
trustManagerFactory.init((KeyStore) null);

// Find first X509TrustManager in the TrustManagerFactory
X509TrustManager x509TrustManager = null;
for (TrustManager trustManager : trustManagerFactory.getTrustManagers()) {
    if (trustManager instanceof X509TrustManager) {
        x509TrustManager = (X509TrustManager) trustManager;
        break;
    }
}

X509TrustManagerExtensions x509TrustManagerExtensions = ",1
41556163,0,"            Cipher aesCipherForDecryption = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");

            aesCipherForDecryption.init(Cipher.DECRYPT_MODE, secretKey, new IvParameterSpec(initializationVector));
            byte[] decryptedByteCipherText = Base64.getDecoder().decode(base64CipherText);
            byte[] byteDecryptedMessage = aesCipherForDecryption.doFinal(decryptedByteCipherText);",2
41696151,0,"    KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmf.init(clientStore, ""pfxPass"".toCharArray());
    KeyManager[] kms = kmf.getKeyManagers();

    // Assuming that you imported the CA Cert ""Subject: CN=MBIIS CA, OU=MBIIS, O=DAIMLER, C=DE""
    // to your cacerts Store.
    KeyStore trustStore = KeyStore.getInstance(""JKS"");
    trustStore.load(new FileInputStream(""cacerts""), ""changeit"".toCharArray());

    TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
    tmf.init(trustStore);
    TrustManager[] tms = tmf.getTrustManagers();
",-1
41752783,2,"var rawData = atob(data);
var iv = rawData.substring(0,16);
var crypttext = rawData.substring(16);

// Decrypt...
var plaintextArray = CryptoJS.AES.decrypt(
  { ciphertext: CryptoJS.enc.Latin1.parse(crypttext) },
  CryptoJS.enc.Hex.parse(key),
  { iv: CryptoJS.enc.Latin1.parse(iv) }
);
",2
41779927,3,"byte[] encrypted    = new byte[cipher.getOutputSize(data.length)];
int updateSize = cipher.update(data, 0, data.length, encrypted, 0);
cipher.doFinal(encrypted, updateSize);
",2
41806934,0,"public class sample{
public KeyStore getKeyStore() {
    try {
        return KeyStore.getInstance(""AndroidKeyStore"");
    } catch (KeyStoreException exception) {
        throw new RuntimeException(""Failed to get an instance of KeyStore"", exception);
    }
}

public KeyPairGenerator getKeyPairGenerator() {
    try {
        return KeyPairGenerator.getInstance(""RSA"", ""AndroidKeyStore"");
    } catch(NoSuchAlgorithmException | NoSuchProviderException exception) {
        throw new RuntimeException(""Failed to get an instance of KeyPairGenerator"", exception);
    }
}

public Cipher getCipher() {
    try {
        return Cipher.getInstance(""RSA/ECB/OAEPWithSHA-256AndMGF1Padding"");
    } catch(NoSuchAlgorithmException | NoSuchPaddingException exception) {
        throw new RuntimeException(""Failed to get an instance of Cipher"", exception);
    }
}

private void createKeyPair() {
    try {
        mKeyPairGenerator.initialize(
                new KeyGenParameterSpec.Builder(KEY_ALIAS, KeyProperties.PURPOSE_DECRYPT)
                        .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)
                        .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_OAEP)
                        .setUserAuthenticationRequired(true)
                        .build());
        mKeyPairGenerator.generateKeyPair();
    } catch(InvalidAlgorithmParameterException exception) {
        throw new RuntimeException(""Failed to generate key pair"", exception);
    }
}

private boolean initCipher(int opmode) {
    try {
        mKeyStore.load(null);

        if(opmode == Cipher.ENCRYPT_MODE) {
            PublicKey key = mKeyStore.getCertificate(KEY_ALIAS).getPublicKey();

            PublicKey unrestricted = KeyFactory.getInstance(key.getAlgorithm())
                    .generatePublic(new X509EncodedKeySpec(key.getEncoded()));

            OAEPParameterSpec spec = new OAEPParameterSpec(
                    ""SHA-256"", ""MGF1"", MGF1ParameterSpec.SHA1, PSource.PSpecified.DEFAULT);

            mCipher.init(opmode, unrestricted, spec);
        } else {
            PrivateKey key = (PrivateKey) mKeyStore.getKey(KEY_ALIAS, null);
            mCipher.init(opmode, key);
        }

        return true;
    } catch (KeyPermanentlyInvalidatedException exception) {
        return false;
    } catch(KeyStoreException | CertificateException | UnrecoverableKeyException
            | IOException | NoSuchAlgorithmException | InvalidKeyException
            | InvalidAlgorithmParameterException exception) {
        throw new RuntimeException(""Failed to initialize Cipher"", exception);
    }
}

private void encrypt(String password) {
    try {
        initCipher(Cipher.ENCRYPT_MODE);
        byte[] bytes = mCipher.doFinal(password.getBytes());
        String encrypted = Base64.encodeToString(bytes, Base64.NO_WRAP);
        mPreferences.getString(""password"").set(encrypted);
    } catch(IllegalBlockSizeException | BadPaddingException exception) {
        throw new RuntimeException(""Failed to encrypt password"", exception);
    }
}

private String decrypt(Cipher cipher) {
    try {
        String encoded = mPreferences.getString(""password"").get();
        byte[] bytes = Base64.decode(encoded, Base64.NO_WRAP);
        return new String(cipher.doFinal(bytes));
    } catch (IllegalBlockSizeException | BadPaddingException exception) {
        throw new RuntimeException(""Failed to decrypt password"", exception);
    }
}
",3
41808147,1," private static KeyStore buildKeyStore(Context context, int certRawResId) {
        // init a default key store
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = null;
        try {
            keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            // read and add certificate authority
            Certificate cert = readCert(context, certRawResId);
            keyStore.setCertificateEntry(""ca"", cert);
        } catch (KeyStoreException e) {
            e.printStackTrace();
        } catch (CertificateException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return keyStore;
    }
",1
41808147,1,"        InputStream caInput = context.getResources().openRawResource(certResourceId);

        Certificate ca=null;
        try {
            // generate a certificate
            CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
            ca = cf.generateCertificate(caInput);
        } catch (CertificateException e) {
            e.printStackTrace();",1
41876053,0,"    static byte[] gcmDecrypt(byte[] ct, byte[] key, byte[] iv, byte[] aad) throws Exception {
        AEADParameters parameters = new AEADParameters(new KeyParameter(key), 128, iv, aad);
        GCMBlockCipher gcmEngine = new GCMBlockCipher(new AESFastEngine());
        gcmEngine.init(false, parameters);
        byte[] pt = new byte[gcmEngine.getOutputSize(ct.length)];
        int len = gcmEngine.processBytes(ct, 0, ct.length, pt, 0);
        gcmEngine.doFinal(pt, len);
        return pt;
    }
",2
41876053,0,"        GCMBlockCipher gcmEngine = new GCMBlockCipher(new AESFastEngine());
        gcmEngine.init(false, parameters);
        byte[] pt = new byte[gcmEngine.getOutputSize(ct.length)];
        int len = gcmEngine.processBytes(ct, 0, ct.length, pt, 0);
        gcmEngine.doFinal(pt, len);",2
41876053,0,"        GCMBlockCipher gcmEngine = new GCMBlockCipher(new AESFastEngine());
        gcmEngine.init(false, parameters);
        byte[] pt = new byte[gcmEngine.getOutputSize(ct.length)];
        int len = gcmEngine.processBytes(ct, 0, ct.length, pt, 0);
        gcmEngine.doFinal(pt, len);
        return pt;",2
41876053,0,"        gcmEngine.init(false, parameters);
        byte[] pt = new byte[gcmEngine.getOutputSize(ct.length)];
        int len = gcmEngine.processBytes(ct, 0, ct.length, pt, 0);
        gcmEngine.doFinal(pt, len);
        return pt;",2
41876053,0,"        byte[] pt = new byte[gcmEngine.getOutputSize(ct.length)];
        int len = gcmEngine.processBytes(ct, 0, ct.length, pt, 0);
        gcmEngine.doFinal(pt, len);",2
41876053,0,"    static byte[] gcmEncrypt(byte[] pt, byte[] key, byte[] iv, byte[] aad) throws Exception {
        AEADParameters parameters = new AEADParameters(new KeyParameter(key), 128, iv, aad);
        GCMBlockCipher gcmEngine = new GCMBlockCipher(new AESFastEngine());
        gcmEngine.init(true, parameters);
        byte[] ct = new byte[gcmEngine.getOutputSize(pt.length)];
        int len = gcmEngine.processBytes(pt, 0, pt.length, ct, 0);
        gcmEngine.doFinal(ct, len);
        return ct;
    }
",2
41876053,0,"        GCMBlockCipher gcmEngine = new GCMBlockCipher(new AESFastEngine());
        gcmEngine.init(true, parameters);
        byte[] ct = new byte[gcmEngine.getOutputSize(pt.length)];
        int len = gcmEngine.processBytes(pt, 0, pt.length, ct, 0);
        gcmEngine.doFinal(ct, len);",2
41876053,0,"        GCMBlockCipher gcmEngine = new GCMBlockCipher(new AESFastEngine());
        gcmEngine.init(true, parameters);
        byte[] ct = new byte[gcmEngine.getOutputSize(pt.length)];
        int len = gcmEngine.processBytes(pt, 0, pt.length, ct, 0);
        gcmEngine.doFinal(ct, len);
        return ct;",2
41876053,0,"        gcmEngine.init(true, parameters);
        byte[] ct = new byte[gcmEngine.getOutputSize(pt.length)];
        int len = gcmEngine.processBytes(pt, 0, pt.length, ct, 0);
        gcmEngine.doFinal(ct, len);
        return ct;",2
41876053,0,"        byte[] ct = new byte[gcmEngine.getOutputSize(pt.length)];
        int len = gcmEngine.processBytes(pt, 0, pt.length, ct, 0);
        gcmEngine.doFinal(ct, len);",2
41934100,2,"public class Ciphers
{
    public static void main(String[] args)
        throws Exception
    {
        SSLServerSocketFactory ssf = (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();

        String[] defaultCiphers = ssf.getDefaultCipherSuites();
        String[] availableCiphers = ssf.getSupportedCipherSuites();

        TreeMap ciphers = new TreeMap();

        for(int i=0; i<availableCiphers.length; ++i )
            ciphers.put(availableCiphers[i], Boolean.FALSE);

        for(int i=0; i<defaultCiphers.length; ++i )
            ciphers.put(defaultCiphers[i], Boolean.TRUE);

        System.out.println(""Default\tCipher"");
        for(Iterator i = ciphers.entrySet().iterator(); i.hasNext(); ) {
            Map.Entry cipher=(Map.Entry)i.next();

            if(Boolean.TRUE.equals(cipher.getValue()))
                System.out.print('*');
            else
                System.out.print(' ');

            System.out.print('\t');
            System.out.println(cipher.getKey());
        }
    }
}",1
42111319,3,"public class sample{
 public void foo(){
KeyPairGenerator kpg = KeyPairGenerator.getInstance(
                KeyProperties.KEY_ALGORITHM_RSA, ""AndroidKeyStore"");

kpg.initialize(new KeyGenParameterSpec.Builder(
                alias,
                KeyProperties.PURPOSE_SIGN | KeyProperties.PURPOSE_VERIFY)
                .setDigests(KeyProperties.DIGEST_SHA256, KeyProperties.DIGEST_SHA512)
                .setKeySize(keySize)
                .build());

KeyPair keyPair = kpg.generateKeyPair();

}",34
42125594,0,"            final KeyStore keyStore = (getKeyStoreProvider() != null) ? KeyStore.getInstance(
                    (getKeyStoreType() != null) ? getKeyStoreType() : KeyStore.getDefaultType(),
                    getKeyStoreProvider()) : KeyStore
                    .getInstance((getKeyStoreType() != null) ? getKeyStoreType() : KeyStore
                            .getDefaultType());
            FileInputStream keyStoreInputStream = null;

            try {
                keyStoreInputStream = ((getKeyStorePath() != null) && (!""NONE""
                        .equals(getKeyStorePath()))) ? new FileInputStream(getKeyStorePath())
                        : null;
                keyStore.load(keyStoreInputStream, getKeyStorePassword());
            } finally {
                if (keyStoreInputStream != null) {
                    keyStoreInputStream.close();
                }
            }

            // Creates the key-manager factory.
            kmf = javax.net.ssl.KeyManagerFactory.getInstance(getKeyManagerAlgorithm());",1
42125594,0,"            final KeyStore trustStore = (getTrustStoreProvider() != null) ? KeyStore
                    .getInstance(
                            (getTrustStoreType() != null) ? getTrustStoreType() : KeyStore
                                    .getDefaultType(), getTrustStoreProvider()) : KeyStore
                    .getInstance((getTrustStoreType() != null) ? getTrustStoreType() : KeyStore
                            .getDefaultType());
            FileInputStream trustStoreInputStream = null;

            try {
                trustStoreInputStream = ((getTrustStorePath() != null) && (!""NONE""
                        .equals(getTrustStorePath()))) ? new FileInputStream(getTrustStorePath())
                        : null;
                trustStore.load(trustStoreInputStream, getTrustStorePassword());
            } finally {
                if (trustStoreInputStream != null) {
                    trustStoreInputStream.close();
                }
            }

            // Creates the trust-manager factory.
            tmf = javax.net.ssl.TrustManagerFactory.getInstance(getTrustManagerAlgorithm());",1
42153463,0,"public class AESHelper {

public static String encrypt(String seed, String cleartext) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext.getBytes());
    return toHex(result);
}

public static String decrypt(String seed, String encrypted) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] enc = toByte(encrypted);
    byte[] result = decrypt(rawKey, enc);
    return new String(result);
}

private static byte[] getRawKey(byte[] seed) throws Exception {
    KeyGenerator kgen = KeyGenerator.getInstance(""AES"");
    SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"",""Crypto"");
    sr.setSeed(seed);
    kgen.init(128, sr); // 192 and 256 bits may not be available
    SecretKey skey = kgen.generateKey();
    byte[] raw = skey.getEncoded();
    return raw;
}


private static byte[] encrypt(byte[] raw, byte[] clear) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
    byte[] encrypted = cipher.doFinal(clear);
    return encrypted;
}

private static byte[] decrypt(byte[] raw, byte[] encrypted) throws Exception {
    SecretKeySpec skeySpec = new SecretKeySpec(raw, ""AES"");
    Cipher cipher = Cipher.getInstance(""AES"");
    cipher.init(Cipher.DECRYPT_MODE, skeySpec);
    byte[] decrypted = cipher.doFinal(encrypted);
    return decrypted;
}

public static String toHex(String txt) {
    return toHex(txt.getBytes());
}
public static String fromHex(String hex) {
    return new String(toByte(hex));
}

public static byte[] toByte(String hexString) {
    int len = hexString.length()/2;
    byte[] result = new byte[len];
    for (int i = 0; i < len; i++)
        result[i] = Integer.valueOf(hexString.substring(2*i, 2*i+2), 16).byteValue();
    return result;
}

public static String toHex(byte[] buf) {
    if (buf == null)
        return """";
    StringBuffer result = new StringBuffer(2*buf.length);
    for (int i = 0; i < buf.length; i++) {
        appendHex(result, buf[i]);
    }
    return result.toString();
}
private final static String HEX = ""0123456789ABCDEF"";
private static void appendHex(StringBuffer sb, byte b) {
    sb.append(HEX.charAt((b>>4)&0x0f)).append(HEX.charAt(b&0x0f));
}
}",5
42153463,0,"public static String encrypt(String seed, String cleartext) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] result = encrypt(rawKey, cleartext.getBytes());
    return toHex(result);
}

public static String decrypt(String seed, String encrypted) throws Exception {
    byte[] rawKey = getRawKey(seed.getBytes());
    byte[] enc = toByte(encrypted);
    byte[] result = decrypt(rawKey, enc);
    return new String(result);
}
",2
42275490,0,"X509Certificate cert = (X509Certificate)pem.readObject();
java.security.cert.Certificate X509Certificate =
        new JcaX509CertificateConverter().setProvider(""SC"")
            .getCertificate(cert);
pem.close();
reader.close();

// Put them into a PKCS12 keystore and write it to a byte[]
ByteArrayOutputStream bos = new ByteArrayOutputStream();
KeyStore ks = KeyStore.getInstance(""PKCS12"");
ks.load(null);
ks.setKeyEntry(""alias"", (Key)key, password.toCharArray(), new java.security.cert.Certificate[]{cert});
ks.store(bos, password.toCharArray());
bos.close();",1
42275490,0,"pem.close();
reader.close();

// Put them into a PKCS12 keystore and write it to a byte[]
ByteArrayOutputStream bos = new ByteArrayOutputStream();
KeyStore ks = KeyStore.getInstance(""PKCS12"");
ks.load(null);
ks.setKeyEntry(""alias"", (Key)key, password.toCharArray(), new java.security.cert.Certificate[]{cert});
ks.store(bos, password.toCharArray());
bos.close();",1
42275490,0,"ks.load(null);
ks.setKeyEntry(""alias"", (Key)key, password.toCharArray(), new java.security.cert.Certificate[]{cert});
ks.store(bos, password.toCharArray());
bos.close();",1
42291244,1,"public class sample{
 public void foo(){
try {
        SSLContext ctx = SSLContext.getInstance(""TLSv1.2"");
        ctx.init(null, null, null);
        SSLContext.setDefault(ctx);
} catch (Exception e) {
        System.out.println(e.getMessage());
}

}",1
42312190,0,"public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
    return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
}

@Override
public Socket createSocket() throws IOException {
    return sslContext.getSocketFactory().createSocket();
}

/**
 * Makes HttpsURLConnection trusts a set of certificates specified by the KeyStore
 */
public void fixHttpsURLConnection() {
    HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
}

/**
 * Gets a KeyStore containing the Certificate
 *
 * @param cert InputStream of the Certificate
 * @return KeyStore
 */",1
42417725,7,"        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j < 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } 
",4
42417725,7,"        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j < 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } 

        final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM); 
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]); 
        final Cipher cipher = Cipher.getInstance(TRANSFORMATION_PADDING); 
        cipher.init(Cipher.ENCRYPT_MODE, key, iv); 
",4
42417725,7,"        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j < 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } 
",4
42417725,7,"        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j < 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } 

        final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM); 
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]); 
        final Cipher decipher = Cipher.getInstance(TRANSFORMATION_PADDING); 
        decipher.init(Cipher.DECRYPT_MODE, key, iv); 
",4
42418031,0,"    final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
    final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
    final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
    for (int j = 0, k = 16; j < 8;) { 
            keyBytes[k++] = keyBytes[j++]; 
    } ",4
42418031,0,"    final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
    final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
    final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
    for (int j = 0, k = 16; j < 8;) { 
            keyBytes[k++] = keyBytes[j++]; 
    } 
    System.out.println(new String(keyBytes));
    final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM); 
    final IvParameterSpec iv = new IvParameterSpec(new byte[8]); 
    final Cipher cipher = Cipher.getInstance(TRANSFORMATION_PADDING); 
    cipher.init(Cipher.ENCRYPT_MODE, key, iv); 
",4
42418031,0,"        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j < 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } ",4
42418031,0,"        final MessageDigest md = MessageDigest.getInstance(ALGORITHM); 
        final byte[] digestOfPassword = md.digest(DIGEST_STRING.getBytes(CHARSET_UTF_8)); 
        final byte[] keyBytes = Arrays.copyOf(digestOfPassword, 24); 
        for (int j = 0, k = 16; j < 8;) { 
                keyBytes[k++] = keyBytes[j++]; 
        } 
        System.out.println(new String(keyBytes));
        final SecretKey key = new SecretKeySpec(keyBytes, SECRET_KEY_ALGORITHM); 
        final IvParameterSpec iv = new IvParameterSpec(new byte[8]); 
        final Cipher decipher = Cipher.getInstance(TRANSFORMATION_PADDING); 
        decipher.init(Cipher.DECRYPT_MODE, key, iv); 
",4
42455879,0,"     IvParameterSpec ivSpec = new IvParameterSpec(keyBytesiv);

     cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);

     byte[] results = cipher.doFinal(text.getBytes(""UTF-8""));
     BASE64Encoder encoder = new BASE64Encoder();
     return encoder.encode(results);",6
42596354,0,"        KeyStore clientStore = KeyStore.getInstance(""PKCS12"");
        clientStore.load(new FileInputStream(""d:\\certs\\api\\xx.p12""), ""W*53as_G"".toCharArray());

        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        kmf.init(clientStore, ""W*53as_G"".toCharArray());
        KeyManager[] kms = kmf.getKeyManagers();

        KeyStore trustStore = KeyStore.getInstance(""JKS"");
        trustStore.load(new FileInputStream(""c:\\jdk1.8.0_51\\jre\\lib\\security\\cacerts""), ""changeit"".toCharArray());

        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init(trustStore);
        TrustManager[] tms = tmf.getTrustManagers();
",1
42596354,0,"        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        kmf.init(clientStore, ""W*53as_G"".toCharArray());
        KeyManager[] kms = kmf.getKeyManagers();

        KeyStore trustStore = KeyStore.getInstance(""JKS"");
        trustStore.load(new FileInputStream(""c:\\jdk1.8.0_51\\jre\\lib\\security\\cacerts""), ""changeit"".toCharArray());

        TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        tmf.init(trustStore);
        TrustManager[] tms = tmf.getTrustManagers();
",-1
42655600,0,"        try {
            java.security.cert.Certificate[] certs = keyStore.getCertificateChain(alias);
            if (certs == null || certs.length == 0) return null;
            X509Certificate[] x509 = new X509Certificate[certs.length];
            for (int i = 0; i < certs.length; i++){
                x509[i] = (X509Certificate)certs[i];
            }
            return x509;
        } ",1
42716982,0,"        Cipher c;
        SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE);
        String publicIV = pref.getString(PUBLIC_IV, null);

        if(android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M){
            c = Cipher.getInstance(AES_MODE_M);
            try{
                c.init(Cipher.ENCRYPT_MODE, getAESKeyFromKS(), new GCMParameterSpec(128,Base64.decode(publicIV, Base64.DEFAULT)));
            } catch(Exception e){
                e.printStackTrace();
            }
        } else{
            c = Cipher.getInstance(AES_MODE_M);
            try{
                c.init(Cipher.ENCRYPT_MODE, getSecretKey(context),new GCMParameterSpec(128,Base64.decode(publicIV, Base64.DEFAULT)));
            } catch (Exception e){
                e.printStackTrace();
            }
        }",2
42716982,0,"        Cipher c;
        SharedPreferences pref = context.getSharedPreferences(SHARED_PREFENCE_NAME, Context.MODE_PRIVATE);
        String publicIV = pref.getString(PUBLIC_IV, null);


        if(android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.M){
            c = Cipher.getInstance(AES_MODE_M);
            try{
                c.init(Cipher.DECRYPT_MODE, getAESKeyFromKS(), new GCMParameterSpec(128,Base64.decode(publicIV, Base64.DEFAULT)));

            } catch(Exception e){
                e.printStackTrace();
            }
        } else{
            c = Cipher.getInstance(AES_MODE_M);
            try{
                c.init(Cipher.DECRYPT_MODE, getSecretKey(context), new GCMParameterSpec(128,Base64.decode(publicIV, Base64.DEFAULT)));
            } catch (Exception e){
                e.printStackTrace();
            }
        }
",2
42733858,0,"    if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format
        privateKeyPem = privateKeyPem.replace(PEM_PRIVATE_START, """").replace(PEM_PRIVATE_END, """");
        privateKeyPem = privateKeyPem.replaceAll(""\\s"", """");

        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(privateKeyPem);

        KeyFactory factory = KeyFactory.getInstance(""RSA"");
        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));
",3
42733858,0,"    } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) {  // PKCS#1 format

        privateKeyPem = privateKeyPem.replace(PEM_RSA_PRIVATE_START, """").replace(PEM_RSA_PRIVATE_END, """");
        privateKeyPem = privateKeyPem.replaceAll(""\\s"", """");

        DerInputStream derReader = new DerInputStream(Base64.getDecoder().decode(privateKeyPem));

        DerValue[] seq = derReader.getSequence(0);

        if (seq.length < 9) {
            throw new GeneralSecurityException(""Could not parse a PKCS1 private key."");
        }

        // skip version seq[0];
        BigInteger modulus = seq[1].getBigInteger();
        BigInteger publicExp = seq[2].getBigInteger();
        BigInteger privateExp = seq[3].getBigInteger();
        BigInteger prime1 = seq[4].getBigInteger();
        BigInteger prime2 = seq[5].getBigInteger();
        BigInteger exp1 = seq[6].getBigInteger();
        BigInteger exp2 = seq[7].getBigInteger();
        BigInteger crtCoef = seq[8].getBigInteger();

        RSAPrivateCrtKeySpec keySpec = new RSAPrivateCrtKeySpec(modulus, publicExp, privateExp, prime1, prime2,
                exp1, exp2, crtCoef);

        KeyFactory factory = KeyFactory.getInstance(""RSA"");

        return factory.generatePrivate(keySpec);
    }

    throw new GeneralSecurityException(""Not supported format of a private key"");",3
42739447,1,"    Cipher aesCBC = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

    byte[] ivBytes = new byte[aesCBC.getBlockSize()];
    rng.nextBytes(ivBytes);
    aesCBC.init(Cipher.ENCRYPT_MODE, aesKey, new IvParameterSpec(ivBytes));
",5
42739447,1,"    byte[] ivBytes = new byte[aesCBC.getBlockSize()];
    rng.nextBytes(ivBytes);
    aesCBC.init(Cipher.ENCRYPT_MODE, aesKey, new IvParameterSpec(ivBytes));

    byte[] cipherTextCBC = aesCBC.doFinal(utf8Chinese);",5
42739447,1,"    aesCBC.init(Cipher.ENCRYPT_MODE, aesKey, new IvParameterSpec(ivBytes));

    byte[] cipherTextCBC = aesCBC.doFinal(utf8Chinese);
    byte[] ivAndCipherTextCBC = Arrays.concatenate(ivBytes, cipherTextCBC);

    System.out.printf(""UTF-8, CBC    encoded : %d bytes: %s%n"", ivAndCipherTextCBC.length, Hex.toHexString(ivAndCipherTextCBC));",2
42739447,1,"    aesCTR.init(Cipher.ENCRYPT_MODE, aesKey, new IvParameterSpec(ivForCTR));

    byte[] cipherTextCTR = aesCTR.doFinal(utf16Chinese);
    byte[] ivAndCipherTextCTR = Arrays.concatenate(ivForCTR, cipherTextCTR);

    System.out.printf(""UTF-16BE, CTR encoded : %d bytes: %s%n"", ivAndCipherTextCTR.length, Hex.toHexString(ivAndCipherTextCTR));",2
42751419,0,"        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secret);

        AlgorithmParameters params = cipher.getParameters();
        iv = params.getParameterSpec(IvParameterSpec.class).getIV();
",2
42805788,0,"    } finally {
      caInput.close();
    }

    // Create a KeyStore containing our trusted CAs
    String keyStoreType = KeyStore.getDefaultType();
    KeyStore keyStore = KeyStore.getInstance(keyStoreType);
    keyStore.load(null, null);
    keyStore.setCertificateEntry(""ca"", ca);

    // Create a TrustManager that trusts the CAs in our KeyStore",1
42805788,0,"    } finally {
      caInput.close();
    }

    // Create a KeyStore containing our trusted CAs
    String keyStoreType = KeyStore.getDefaultType();
    KeyStore keyStore = KeyStore.getInstance(keyStoreType);
    keyStore.load(null, null);
    keyStore.setCertificateEntry(""ca"", ca);

    // Create a TrustManager that trusts the CAs in our KeyStore
    String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
    tmf.init(keyStore);

    // Create an SSLContext that uses our TrustManager",1
42805905,6,"    public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException {
        return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);
    }

    @Override
    public Socket createSocket() throws IOException {
        return sslContext.getSocketFactory().createSocket();
    }

    /**
     * Makes HttpsURLConnection trusts a set of certificates specified by the KeyStore
     */
    public void fixHttpsURLConnection() {
        HttpsURLConnection.setDefaultSSLSocketFactory(sslContext.getSocketFactory());
    }",1
42839925,0,"    Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1Padding"");

    RSAPrivateKeySpec privSpec = new RSAPrivateKeySpec(modules, d);
    PrivateKey privKey = factory.generatePrivate(privSpec);
    cipher.init(Cipher.DECRYPT_MODE, privKey);",3
42856564,0,"        byte[] keyBytes = key.getBytes(""UTF-8"");
        byte[] IvkeyBytes = initVector.getBytes(""UTF-8"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
        SecretKeySpec secretKeySpec = new SecretKeySpec(keyBytes, ""AES"");
        IvParameterSpec ivParameterSpec = new IvParameterSpec(IvkeyBytes);
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec, ivParameterSpec);
        plainTextbytes = cipher.doFinal(plainTextbytes);",2
42856564,0,"                byte[] keyBytes = key.getBytes(""UTF-8"");
                byte[] IvkeyBytes = initVector.getBytes(""UTF-8"");

                Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS7Padding"");
                SecretKeySpec secretKeySpecy = new SecretKeySpec(keyBytes, ""AES"");
                IvParameterSpec ivParameterSpec = new IvParameterSpec(IvkeyBytes);
                cipher.init(Cipher.DECRYPT_MODE, secretKeySpecy, ivParameterSpec);
                cipheredBytes = cipher.doFinal(cipheredBytes);
",2
42910006,2,"public class sample{
public static byte[] encryptWithAES(byte[] message, Key AESkey, byte[] iv) throws Exception {
byte[] decryptedMessage = null;
try {
    Cipher encrypt = Cipher.getInstance(""AES/CBC/PKCS5Padding"");  // here is the change
    encrypt.init(Cipher.ENCRYPT_MODE, AESkey,new IvParameterSpec(iv)); // and I add the iv for cbc
    decryptedMessage = encrypt.doFinal(message);
} catch (Exception ex) {
    System.err.println(ex.getMessage());
    throw ex;
}
return decryptedMessage;
}
",2
42956231,1,"public class sample{
    public static byte[] encryptWithAES(byte[] message, Key AESkey, byte[] iv) throws Exception {
byte[] decryptedMessage = null;
try {
    Cipher encrypt = Cipher.getInstance(""AES/CBC/PKCS5Padding"");  // here is the change
    encrypt.init(Cipher.ENCRYPT_MODE, AESkey,new IvParameterSpec(iv)); // and I add the iv for cbc
    decryptedMessage = encrypt.doFinal(message);
} catch (Exception ex) {
    System.err.println(ex.getMessage());
    throw ex;
}
return decryptedMessage;
}
",2
43102873,0,"private static byte[] createSha1(File file) throws Exception  {
    MessageDigest digest = MessageDigest.getInstance(""SHA-1"");
    InputStream fis = new FileInputStream(file);
    int n = 0;
    byte[] buffer = new byte[8192];
    while (n != -1) {
        n = fis.read(buffer);
        if (n > 0) {
            digest.update(buffer, 0, n);
        }
    }
    return digest.digest();
}
",4
43147199,0,"public class sample{
/**
 * Find a factor of n by following the algorithm outlined in Handbook of Applied Cryptography, section
 * 8.2.2(i). See http://cacr.uwaterloo.ca/hac/about/chap8.pdf.
 *
 */

private static BigInteger findFactor(BigInteger e, BigInteger d, BigInteger n) {
    BigInteger edMinus1 = e.multiply(d).subtract(BigInteger.ONE);
    int s = edMinus1.getLowestSetBit();
    BigInteger t = edMinus1.shiftRight(s);

    for (int aInt = 2; true; aInt++) {
        BigInteger aPow = BigInteger.valueOf(aInt).modPow(t, n);
        for (int i = 1; i <= s; i++) {
            if (aPow.equals(BigInteger.ONE)) {
                break;
            }
            if (aPow.equals(n.subtract(BigInteger.ONE))) {
                break;
            }
            BigInteger aPowSquared = aPow.multiply(aPow).mod(n);
            if (aPowSquared.equals(BigInteger.ONE)) {
                return aPow.subtract(BigInteger.ONE).gcd(n);
            }
            aPow = aPowSquared;
        }
    }

}

public static RSAPrivateCrtKey createCrtKey(RSAPublicKey rsaPub, RSAPrivateKey rsaPriv) throws NoSuchAlgorithmException, InvalidKeySpecException {

    BigInteger e = rsaPub.getPublicExponent();
    BigInteger d = rsaPriv.getPrivateExponent();
    BigInteger n = rsaPub.getModulus();
    BigInteger p = findFactor(e, d, n);
    BigInteger q = n.divide(p);
    if (p.compareTo(q) > 1) {
        BigInteger t = p;
        p = q;
        q = t;
    }
    BigInteger exp1 = d.mod(p.subtract(BigInteger.ONE));
    BigInteger exp2 = d.mod(q.subtract(BigInteger.ONE));
    BigInteger coeff = q.modInverse(p);
    RSAPrivateCrtKeySpec keySpec = new RSAPrivateCrtKeySpec(n, e, d, p, q, exp1, exp2, coeff);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");
    return (RSAPrivateCrtKey) kf.generatePrivate(keySpec);

}
",3
43172704,7,"KeySpec keySpec = new PBEKeySpec(submittedPassword.toCharArray(), salt, 1000, 256);
SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
byte[] keyBytes = keyFactory.generateSecret(keySpec).getEncoded();",2
43183297,0,"KeySpec spec = new PBEKeySpec(EncryptionKey.toCharArray(), salt, 65536, 128);
SecretKeyFactory f = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
byte[] keyBytes = f.generateSecret(spec).getEncoded();
",2
43190492,1,"        Cipher dec = Cipher.getInstance(""PBEWithHmacSHA256AndAES_128"");
        dec.init(Cipher.DECRYPT_MODE, secretKey, pbeParamSpec);
        byte[] decrypted = dec.doFinal(encrypted);
        String message = new String(decrypted, StandardCharsets.UTF_8);

        System.out.println(message);
",2
43315273,2,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
43355114,0,"public class sample{
 public void foo(){
PEMParser pemParser = new PEMParser(new StringReader(certPEMData));
    Object parsedObj = pemParser.readObject();
    System.out.println(""PemParser returned: "" + parsedObj);
    if (parsedObj instanceof X509CertificateHolder)
    {
        X509CertificateHolder x509CertificateHolder = (X509CertificateHolder) parsedObj;
        return x509CertificateHolder.getSubjectPublicKeyInfo().getPublicKeyData().getString();
    }
    else
    {
        throw new RuntimeException(""The parsed object was not an X509CertificateHolder."");
    }

}",1
43356995,2,"   protected void generateKey() {
       try {
           keyStore = KeyStore.getInstance(""AndroidKeyStore"");
       } catch (Exception e) {
           e.printStackTrace();
       }


       KeyGenerator keyGenerator;
       try {
           keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");
       } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
           throw new RuntimeException(""Failed to get KeyGenerator instance"", e);
       }


       try {
           keyStore.load(null);
           keyGenerator.init(new
                   KeyGenParameterSpec.Builder(KEY_NAME,
                   KeyProperties.PURPOSE_ENCRYPT |
                           KeyProperties.PURPOSE_DECRYPT)
                   .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
                   .setUserAuthenticationRequired(true)
                   .setEncryptionPaddings(
                           KeyProperties.ENCRYPTION_PADDING_PKCS7)
                   .build());
           keyGenerator.generateKey();
       } catch (NoSuchAlgorithmException |
               InvalidAlgorithmParameterException
               | CertificateException | IOException e) {
           throw new RuntimeException(e);
       }
   }


   @TargetApi(Build.VERSION_CODES.M)
   public boolean cipherInit() {
       try {
           cipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + ""/"" + KeyProperties.BLOCK_MODE_CBC + ""/"" + KeyProperties.ENCRYPTION_PADDING_PKCS7);
       } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
           throw new RuntimeException(""Failed to get Cipher"", e);
       }


       try {
           keyStore.load(null);
           SecretKey key = (SecretKey) keyStore.getKey(KEY_NAME,
                   null);
           cipher.init(Cipher.ENCRYPT_MODE, key);
           return true;
       } catch (KeyPermanentlyInvalidatedException e) {
           return false;
       } catch (KeyStoreException | CertificateException | UnrecoverableKeyException | IOException | NoSuchAlgorithmException | InvalidKeyException e) {
           throw new RuntimeException(""Failed to init Cipher"", e);
       }
   }",2
43467472,0,"public class sample{
 public void Get_hash_key() {
    PackageInfo info;
    try {
        info = getPackageManager().getPackageInfo(""com.your_packaage_name"", PackageManager.GET_SIGNATURES);
        for (Signature signature : info.signatures) {
            MessageDigest md;
            md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String something = new String(Base64.encode(md.digest(), 0));
            //String something = new String(Base64.encodeBytes(md.digest()));
            Log.e(""hash key"", something);
        }
    } catch (PackageManager.NameNotFoundException e1) {
        Log.e(""name not found"", e1.toString());
    } catch (NoSuchAlgorithmException e) {
        Log.e(""no such an algorithm"", e.toString());
    } catch (Exception e) {
        Log.e(""exception"", e.toString());
    }
}
",4
43467472,0,"        for (Signature signature : info.signatures) {
            MessageDigest md;
            md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String something = new String(Base64.encode(md.digest(), 0));
            //String something = new String(Base64.encodeBytes(md.digest()));
            Log.e(""hash key"", something);
        }",4
43467472,0,"        for (Signature signature : info.signatures) {
            MessageDigest md;
            md = MessageDigest.getInstance(""SHA"");
            md.update(signature.toByteArray());
            String something = new String(Base64.encode(md.digest(), 0));
            //String something = new String(Base64.encodeBytes(md.digest()));
            Log.e(""hash key"", something);
        }
    } catch (PackageManager.NameNotFoundException e1) {
        Log.e(""name not found"", e1.toString());
    } catch (NoSuchAlgorithmException e) {
        Log.e(""no such an algorithm"", e.toString());
    } catch (Exception e) {
        Log.e(""exception"", e.toString());
    }",4
43534042,0,"        byte[] publicBytes = Base64.decode(PUBLIC_KEY, Base64.DEFAULT);
        X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicBytes);
        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        PublicKey pubKey = keyFactory.generatePublic(keySpec);
        Cipher cipher = Cipher.getInstance(""RSA/ECB/PKCS1PADDING""); //or try with ""RSA""
        cipher.init(Cipher.ENCRYPT_MODE, pubKey);
        encrypted = cipher.doFinal(txt.getBytes());
        encoded = Base64.encodeToString(encrypted, Base64.DEFAULT);",3
43883819,0,"        CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
        InputStream caInput = new BufferedInputStream(inputStream);
        Certificate ca;
        try {
            ca = cf.generateCertificate(caInput);
            System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
        } finally {
            caInput.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();",1
43883819,0,"        Certificate ca;
        try {
            ca = cf.generateCertificate(caInput);
            System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
        } finally {
            caInput.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore and system CA",1
43883819,0,"        } finally {
            caInput.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore and system CA",1
43893412,0,"import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.x509.extension.X509ExtensionUtil;

X509Certificate cert = // end entity certificate

// get Authority Information Access extension (will be null if extension is not present)
byte[] extVal = cert.getExtensionValue(Extension.authorityInfoAccess.getId());
AuthorityInformationAccess aia = AuthorityInformationAccess.getInstance(X509ExtensionUtil.fromExtensionValue(extVal));

// check if there is a URL to issuer's certificate
AccessDescription[] descriptions = aia.getAccessDescriptions();",1
43918337,0,"public class sample{
public static Certificate selfSign(KeyPair keyPair, String subjectDN) throws OperatorCreationException, CertificateException, IOException
{
    Provider bcProvider = new BouncyCastleProvider();
    Security.addProvider(bcProvider);

    long now = System.currentTimeMillis();
    Date startDate = new Date(now);

    X500Name dnName = new X500Name(subjectDN);
    BigInteger certSerialNumber = new BigInteger(Long.toString(now)); // <-- Using the current timestamp as the certificate serial number

    Calendar calendar = Calendar.getInstance();
    calendar.setTime(startDate);
    calendar.add(Calendar.YEAR, 1); // <-- 1 Yr validity

    Date endDate = calendar.getTime();

    String signatureAlgorithm = ""SHA256WithRSA""; // <-- Use appropriate signature algorithm based on your keyPair algorithm.

    ContentSigner contentSigner = new JcaContentSignerBuilder(signatureAlgorithm).build(keyPair.getPrivate());

    JcaX509v3CertificateBuilder certBuilder = new JcaX509v3CertificateBuilder(dnName, certSerialNumber, startDate, endDate, dnName, keyPair.getPublic());

    // Extensions --------------------------

    // Basic Constraints
    BasicConstraints basicConstraints = new BasicConstraints(true); // <-- true for CA, false for EndEntity

    certBuilder.addExtension(new ASN1ObjectIdentifier(""2.5.29.19""), true, basicConstraints); // Basic Constraints is usually marked as critical.

    // -------------------------------------

    return new JcaX509CertificateConverter().setProvider(bcProvider).getCertificate(certBuilder.build(contentSigner));
}
",3
43918337,0,"    Provider bcProvider = new BouncyCastleProvider();
    Security.addProvider(bcProvider);

    long now = System.currentTimeMillis();
    Date startDate = new Date(now);

    X500Name dnName = new X500Name(subjectDN);
    BigInteger certSerialNumber = new BigInteger(Long.toString(now)); // <-- Using the current timestamp as the certificate serial number

    Calendar calendar = Calendar.getInstance();
    calendar.setTime(startDate);
    calendar.add(Calendar.YEAR, 1); // <-- 1 Yr validity

    Date endDate = calendar.getTime();

    String signatureAlgorithm = ""SHA256WithRSA""; // <-- Use appropriate signature algorithm based on your keyPair algorithm.
",3
43965528,0,"        Provider bcProvider = new BouncyCastleProvider();
        Security.addProvider(bcProvider);

        long now = System.currentTimeMillis();
        Date startDate = new Date(now);

        X500Name dnName = new X500Name(subjectDN);

        // Using the current timestamp as the certificate serial number
        BigInteger certSerialNumber = new BigInteger(Long.toString(now));

        Calendar calendar = Calendar.getInstance();
        calendar.setTime(startDate);
        // 1 Yr validity
        calendar.add(Calendar.YEAR, 1);

        Date endDate = calendar.getTime();

        // Use appropriate signature algorithm based on your keyPair algorithm.
        String signatureAlgorithm = ""SHA256WithRSA"";
",3
43965528,0,"        if (!(entry instanceof PrivateKeyEntry)) {
            throw new KeyStoreException(""That's not a private key!"");
        }
        PrivateKeyEntry privKeyEntry = (PrivateKeyEntry) entry;
        PublicKey publicKey = privKeyEntry.getCertificate().getPublicKey();
        PrivateKey privateKey = privKeyEntry.getPrivateKey();
        return new KeyPair(publicKey, privateKey);",3
43982316,3,"        RSAPublicKeySpec keySpec = new RSAPublicKeySpec(modulus, publicExponent);
        KeyFactory kf = KeyFactory.getInstance(""RSA"");
        PublicKey publicKey = kf.generatePublic(keySpec);

        System.out.printf(""Modulus: %X%n"", modulus);
        System.out.printf(""Public exponent: %d ... 17? Why?%n"", publicExponent);
        System.out.printf(""See, Java class result: %s, is RSAPublicKey: %b%n"", publicKey.getClass().getName(), publicKey instanceof RSAPublicKey);
",3
43984402,0,"    } else if (pk instanceof JCEECPublicKey) {
        final JCEECPublicKey ecpriv = (JCEECPublicKey) pk;
        final org.bouncycastle.jce.spec.ECParameterSpec spec = ecpriv.getParameters();
        if (spec != null) {
            len = spec.getN().bitLength();              
        } else {
            // We support the key, but we don't know the key length
            len = 0;
        }",3
43984402,0,"    } else if (pk instanceof ECPublicKey) {
        final ECPublicKey ecpriv = (ECPublicKey) pk;
        final java.security.spec.ECParameterSpec spec = ecpriv.getParams();
        if (spec != null) {
            len = spec.getOrder().bitLength(); // does this really return something we expect?
        } else {
            // We support the key, but we don't know the key length
            len = 0;
        }",3
44002966,4,"import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.x509.extension.X509ExtensionUtil;

X509Certificate cert = // a java.security.cert.X509Certificate
byte[] v = cert.getExtensionValue(Extension.subjectAlternativeName.getId());
GeneralNames gn = GeneralNames.getInstance(X509ExtensionUtil.fromExtensionValue(v));
GeneralName[] names = gn.getNames();",1
44004148,1,"public class sample{
public static Certificate selfSign(KeyPair keyPair, String subjectDN) throws OperatorCreationException, CertificateException, IOException
{
    Provider bcProvider = new BouncyCastleProvider();
    Security.addProvider(bcProvider);

    long now = System.currentTimeMillis();
    Date startDate = new Date(now);

    X500Name dnName = new X500Name(subjectDN);
    BigInteger certSerialNumber = new BigInteger(Long.toString(now)); // <-- Using the current timestamp as the certificate serial number

    Calendar calendar = Calendar.getInstance();
    calendar.setTime(startDate);
    calendar.add(Calendar.YEAR, 1); // <-- 1 Yr validity

    Date endDate = calendar.getTime();

    String signatureAlgorithm = ""SHA256WithRSA""; // <-- Use appropriate signature algorithm based on your keyPair algorithm.

    ContentSigner contentSigner = new JcaContentSignerBuilder(signatureAlgorithm).build(keyPair.getPrivate());

    JcaX509v3CertificateBuilder certBuilder = new JcaX509v3CertificateBuilder(dnName, certSerialNumber, startDate, endDate, dnName, keyPair.getPublic());

    // Extensions --------------------------

    // Basic Constraint
    BasicConstraints basicConstraints = new BasicConstraints(true); // <-- true for CA, false for EndEntity

    certBuilder.addExtension(new ASN1ObjectIdentifier(""2.5.29.19""), true, basicConstraints); // Basic Constraints is usually marked as critical.

    // -------------------------------------

    return new JcaX509CertificateConverter().setProvider(bcProvider).getCertificate(certBuilder.build(contentSigner));
}
",3
44004148,1,"    Provider bcProvider = new BouncyCastleProvider();
    Security.addProvider(bcProvider);

    long now = System.currentTimeMillis();
    Date startDate = new Date(now);

    X500Name dnName = new X500Name(subjectDN);
    BigInteger certSerialNumber = new BigInteger(Long.toString(now)); // <-- Using the current timestamp as the certificate serial number

    Calendar calendar = Calendar.getInstance();
    calendar.setTime(startDate);
    calendar.add(Calendar.YEAR, 1); // <-- 1 Yr validity

    Date endDate = calendar.getTime();

    String signatureAlgorithm = ""SHA256WithRSA""; // <-- Use appropriate signature algorithm based on your keyPair algorithm.
",3
44007183,0,"    TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
    if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
      throw new IllegalStateException(""Unexpected default trust managers:""
          + Arrays.toString(trustManagers));
    }
    return (X509TrustManager) trustManagers[0];",1
44016715,0,"public class sample{
 public void foo(){
KeyPairGenerator kpg = KeyPairGenerator.getInstance(
    KeyProperties.KEY_ALGORITHM_RSA, ""AndroidKeyStore"");
kpg.initialize(new KeyGenParameterSpec.Builder(
    ""mykey"", KeyProperties.PURPOSE_SIGN)
    .setDigests(KeyProperties.DIGEST_SHA256)
    .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PSS)
    .build());

}",3
44199907,3,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");        
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
            }",4
44241530,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                Log.d(""KeyHash:"", Base64.encodeToString(md.digest(), Base64.DEFAULT));
                }",4
44251884,1,"            IvParameterSpec initVector = new IvParameterSpec(iv.getBytes(""UTF-8""));
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(Java_AES_Cipher.CIPHER_NAME);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, initVector);
",2
44314542,0,"          System.out.println(""key ring size="" + pkCol.size());
          Iterator it = pkCol.getKeyRings();
          while (it.hasNext()) {
                  pkRing = (PGPPublicKeyRing) it.next();
                  Iterator pkIt = pkRing.getPublicKeys();
                  while (pkIt.hasNext()) {
                          PGPPublicKey key = (PGPPublicKey) pkIt.next();
                          System.out.println(""Encryption key = "" + key.isEncryptionKey() + "", Master key = "" + 
                                             key.isMasterKey());
                          if (key.isEncryptionKey())
                                  return key;
                  }
          }
          return null;",4
44585999,0,"    public static KeyPair loadKeysFromPKCS12File(String alias, String filename, char[] storePass, char[] entryPass) throws KeyStoreException,
            NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableEntryException {

        KeyStore pkcs12KeyStore = KeyStore.getInstance(""PKCS12"");
        try (FileInputStream fis = new FileInputStream(filename);) {
            pkcs12KeyStore.load(fis, storePass);
        }

        return loadKeyPair(pkcs12KeyStore, alias, entryPass);
    }

    public static KeyPair loadKeysFromPKCS12ByteArray(String alias, byte[] storeBytes, char[] storePass, char[] entryPass) throws KeyStoreException,
            NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableEntryException {

        KeyStore pkcs12KeyStore = KeyStore.getInstance(""PKCS12"");
        try (ByteArrayInputStream bis = new ByteArrayInputStream(storeBytes);) {
            pkcs12KeyStore.load(bis, storePass);
        }

        return loadKeyPair(pkcs12KeyStore, alias, entryPass);
    }

    private static KeyPair loadKeyPair(KeyStore ks, String alias, char[] entryPass)
            throws NoSuchAlgorithmException, UnrecoverableEntryException, KeyStoreException {
        KeyStore.ProtectionParameter param = new KeyStore.PasswordProtection(entryPass);
        Entry entry = ks.getEntry(alias, param);
        if (!(entry instanceof PrivateKeyEntry)) {
            throw new KeyStoreException(""That's not a private key!"");
        }
        PrivateKeyEntry privKeyEntry = (PrivateKeyEntry) entry;",3
44585999,0,"        if (!(entry instanceof PrivateKeyEntry)) {
            throw new KeyStoreException(""That's not a private key!"");
        }
        PrivateKeyEntry privKeyEntry = (PrivateKeyEntry) entry;
        PublicKey publicKey = privKeyEntry.getCertificate().getPublicKey();
        PrivateKey privateKey = privKeyEntry.getPrivateKey();
        return new KeyPair(publicKey, privateKey);",3
44585999,0,"    public static Certificate loadCertFromPKCS12File(String alias, String filename, char[] storePass, char[] entryPass) throws KeyStoreException,
            NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableEntryException {

        KeyStore pkcs12KeyStore = KeyStore.getInstance(""PKCS12"");
        try (FileInputStream fis = new FileInputStream(filename);) {
            pkcs12KeyStore.load(fis, storePass);
        }
        return loadCert(pkcs12KeyStore, alias, entryPass);
    }

    public static Certificate loadCertFromPKCS12ByteArray(String alias, byte[] storeBytes, char[] storePass, char[] entryPass)
            throws KeyStoreException, NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException,
            UnrecoverableEntryException {

        KeyStore pkcs12KeyStore = KeyStore.getInstance(""PKCS12"");
        try (ByteArrayInputStream bis = new ByteArrayInputStream(storeBytes);) {
            pkcs12KeyStore.load(bis, storePass);
        }
        return loadCert(pkcs12KeyStore, alias, entryPass);
    }

    private static Certificate loadCert(KeyStore ks, String alias, char[] entryPass)
            throws NoSuchAlgorithmException, UnrecoverableEntryException, KeyStoreException {

        KeyStore.ProtectionParameter param = new KeyStore.PasswordProtection(entryPass);
        Entry entry = ks.getEntry(alias, param);
        if (!(entry instanceof PrivateKeyEntry)) {
            throw new KeyStoreException(""That's not a private key!"");
        }
        PrivateKeyEntry privKeyEntry = (PrivateKeyEntry) entry;",3
44585999,3,"            ByteArrayInputStream bis = new ByteArrayInputStream(remoteCertBytes);
            X509Certificate remoteCert = (X509Certificate) CertificateFactory.getInstance(""X.509"").generateCertificate(new BufferedInputStream(bis));

            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
            ks.load(null, null);
            ks.setCertificateEntry(Integer.toString(1), remoteCert);

            TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
            tmf.init(ks);

            // 2 - Add the new trustmanager to the tls settings. ",1
44683080,1,"PEMParser pemParser = new PEMParser(new FileReader(keyFile));
Object object = pemParser.readObject();
JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(""BC"");

KeyPair kp;
if (object instanceof PEMEncryptedKeyPair) {
    // Encrypted key - we will use provided password
    PEMEncryptedKeyPair ckp = (PEMEncryptedKeyPair) object;
    // uses the password to decrypt the key
    PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(password.toCharArray());
    kp = converter.getKeyPair(ckp.decryptKeyPair(decProv));
} else {
    // Unencrypted key - no password needed
    PEMKeyPair ukp = (PEMKeyPair) object;
    kp = converter.getKeyPair(ukp);
}

// RSA
KeyFactory keyFac = KeyFactory.getInstance(""RSA"");
RSAPrivateCrtKeySpec privateKey = keyFac.getKeySpec(kp.getPrivate(), RSAPrivateCrtKeySpec.class);
",3
44721987,2,"            byte[] byteKey = key.getBytes(""UTF-8"");
            final String HMAC_SHA256 = ""HmacSHA512"";
            sha512_HMAC = Mac.getInstance(HMAC_SHA256);
            SecretKeySpec keySpec = new SecretKeySpec(byteKey, HMAC_SHA256);
            sha512_HMAC.init(keySpec);",4
44742094,1,"    public void testKeyPairGenerator(Blackhole bh) throws Exception {
        Signature rsaSign = Signature.getInstance(SIGNATURE_ALGORITHM_NAME, PROVIDER_NAME);
        rsaSign.initSign(keyPairGenerator);
        rsaSign.update(textToSign.getBytes());
        rsaSign.sign();

        bh.consume(rsaSign);
    }

    @Benchmark",3
44742094,1,"    public void testKeyPairGenerator(Blackhole bh) throws Exception {
        Signature rsaSign = Signature.getInstance(SIGNATURE_ALGORITHM_NAME, PROVIDER_NAME);
        rsaSign.initSign(keyPairGenerator);
        rsaSign.update(textToSign.getBytes());
        rsaSign.sign();

        bh.consume(rsaSign);
    }

    @Benchmark
    public void testKeySpec(Blackhole bh) throws Exception {
        Signature rsaSign = Signature.getInstance(SIGNATURE_ALGORITHM_NAME, PROVIDER_NAME);
        rsaSign.initSign(keySpec);
        rsaSign.update(textToSign.getBytes());
        rsaSign.sign();

        bh.consume(rsaSign);
    }

    @Benchmark",3
44742094,1,"    public void testKeySpec(Blackhole bh) throws Exception {
        Signature rsaSign = Signature.getInstance(SIGNATURE_ALGORITHM_NAME, PROVIDER_NAME);
        rsaSign.initSign(keySpec);
        rsaSign.update(textToSign.getBytes());
        rsaSign.sign();

        bh.consume(rsaSign);
    }

    @Benchmark
    public void testCrtKeySpec(Blackhole bh) throws Exception {
        Signature rsaSign = Signature.getInstance(SIGNATURE_ALGORITHM_NAME, PROVIDER_NAME);
        rsaSign.initSign(crtKey);
        rsaSign.update(textToSign.getBytes());
        rsaSign.sign();

        bh.consume(rsaSign);
    }
",3
44742094,1,"    public void testCrtKeySpec(Blackhole bh) throws Exception {
        Signature rsaSign = Signature.getInstance(SIGNATURE_ALGORITHM_NAME, PROVIDER_NAME);
        rsaSign.initSign(crtKey);
        rsaSign.update(textToSign.getBytes());
        rsaSign.sign();

        bh.consume(rsaSign);
    }
",3
44891805,2,"        SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        KeySpec spec = new PBEKeySpec(str.toCharArray(), salt, 65536, 256);
        SecretKey tmp = factory.generateSecret(spec);
        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secret);
        AlgorithmParameters params = cipher.getParameters();
        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();",2
44891805,2,"        SecretKey tmp = factory.generateSecret(spec);
        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secret);
        AlgorithmParameters params = cipher.getParameters();
        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();",2
44891805,2,"        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secret);
        AlgorithmParameters params = cipher.getParameters();
        byte[] iv = params.getParameterSpec(IvParameterSpec.class).getIV();",2
44891805,2,"        SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");

        cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));",2
44978626,0,"        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init((KeyStore) null);
        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
        if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
            throw new IllegalStateException(""Unexpected default trust managers:"" + Arrays.toString(trustManagers));
        }",1
44978626,0,"        TrustManager[] trustManagers = trustManagerFactory.getTrustManagers();
        if (trustManagers.length != 1 || !(trustManagers[0] instanceof X509TrustManager)) {
            throw new IllegalStateException(""Unexpected default trust managers:"" + Arrays.toString(trustManagers));
        }
        return (X509TrustManager) trustManagers[0];",1
45083824,3,"public class sample{
 public void foo(){
Cipher rsaCipher = Cipher.getInstance(""RSA/None/PKCS1Padding"", ""SC"");
rsaCipher.init(Cipher.ENCRYPT_MODE, apiPublicKey);
byte[] ENCRYPTED_YOUR_STRING = rsaCipher.doFinal(YOUR_STRING);

}",3
45179672,0,"    TrustManagerFactory tmFactory = TrustManagerFactory.getInstance(""SunX509"");
    tmFactory.init(keyStore); TrustManager[] tm = tmFactory.getTrustManagers();

    //Create SSLContext with protocol:
    SSLContext ctx = SSLContext.getInstance(""TLSv1.2"");",1
45182489,0,"private void generateKey() {
    try {
        keyStore = KeyStore.getInstance(""AndroidKeyStore"");
    } catch (Exception e) {
        e.printStackTrace();
    }

    KeyGenerator keyGenerator;
    try {
        keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, ""AndroidKeyStore"");
    } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
        throw new RuntimeException(""Failed to get KeyGenerator instance"", e);
    }

    try {
        keyStore.load(null);
        keyGenerator.init(new
                KeyGenParameterSpec.Builder(KEY_NAME,
                KeyProperties.PURPOSE_ENCRYPT |
                        KeyProperties.PURPOSE_DECRYPT)
                .setBlockModes(KeyProperties.BLOCK_MODE_CBC)
                .setUserAuthenticationRequired(true)
                .setEncryptionPaddings(
                        KeyProperties.ENCRYPTION_PADDING_PKCS7)
                .build());
        keyGenerator.generateKey();
    } catch (NoSuchAlgorithmException |
            InvalidAlgorithmParameterException
            | CertificateException | IOException e) {
        throw new RuntimeException(e);
    }
}


private boolean cipherInit() {
    try {
        cipher = Cipher.getInstance(KeyProperties.KEY_ALGORITHM_AES + ""/"" + KeyProperties.BLOCK_MODE_CBC + ""/"" + KeyProperties.ENCRYPTION_PADDING_PKCS7);
    } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {
        throw new RuntimeException(""Failed to get Cipher"", e);
    }

    try {
        keyStore.load(null);
        SecretKey key = (SecretKey) keyStore.getKey(KEY_NAME,
                null);
        cipher.init(Cipher.ENCRYPT_MODE, key);
        return true;
    } catch (KeyPermanentlyInvalidatedException e) {
        return false;
    } catch (KeyStoreException | CertificateException | UnrecoverableKeyException | IOException | NoSuchAlgorithmException | InvalidKeyException e) {
        throw new RuntimeException(""Failed to init Cipher"", e);
    }
}
",2
45208022,0,"                is = assManager.open(""certificate.cer"");
                InputStream caInput = new BufferedInputStream(is);
                Certificate ca;
                try {
                    ca = cf.generateCertificate(caInput);

                    System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
                } finally {
                    caInput.close();
                }

                // Create a KeyStore containing our trusted CAs
                String keyStoreType = KeyStore.getDefaultType();",1
45208022,0,"                Certificate ca;
                try {
                    ca = cf.generateCertificate(caInput);

                    System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
                } finally {
                    caInput.close();
                }

                // Create a KeyStore containing our trusted CAs
                String keyStoreType = KeyStore.getDefaultType();
                KeyStore keyStore = KeyStore.getInstance(keyStoreType);
                keyStore.load(null, null);
                keyStore.setCertificateEntry(""ca"", ca);

                // Create a TrustManager that trusts the CAs in our KeyStore",1
45208022,0,"                Certificate ca;
                try {
                    ca = cf.generateCertificate(caInput);

                    System.out.println(""ca="" + ((X509Certificate) ca).getSubjectDN());
                } finally {
                    caInput.close();
                }

                // Create a KeyStore containing our trusted CAs
                String keyStoreType = KeyStore.getDefaultType();
                KeyStore keyStore = KeyStore.getInstance(keyStoreType);
                keyStore.load(null, null);
                keyStore.setCertificateEntry(""ca"", ca);

                // Create a TrustManager that trusts the CAs in our KeyStore
                String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
                TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
                tmf.init(keyStore);

                // create CouchbaseLiteHttpClientFactory",1
45208022,0,"                } finally {
                    caInput.close();
                }

                // Create a KeyStore containing our trusted CAs
                String keyStoreType = KeyStore.getDefaultType();
                KeyStore keyStore = KeyStore.getInstance(keyStoreType);
                keyStore.load(null, null);
                keyStore.setCertificateEntry(""ca"", ca);

                // Create a TrustManager that trusts the CAs in our KeyStore
                String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
                TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
                tmf.init(keyStore);

                // create CouchbaseLiteHttpClientFactory",1
45279963,0,"    byte messageDigest[] = digest.digest();

    // Create Hex String
    StringBuffer hexString = new StringBuffer();
    for (int i=0; i<messageDigest.length; i++)
        hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
    return hexString.toString();
",4
45279963,0,"    byte messageDigest[] = digest.digest();

    // Create Hex String
    StringBuffer hexString = new StringBuffer();
    for (int i=0; i<messageDigest.length; i++)
        hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
    return hexString.toString();
",4
45279963,0,"    byte messageDigest[] = digest.digest();

    // Create Hex String
    StringBuffer hexString = new StringBuffer();
    for (int i=0; i<messageDigest.length; i++)
        hexString.append(Integer.toHexString(0xFF & messageDigest[i]));",4
45279963,0,"    byte messageDigest[] = digest.digest();

    // Create Hex String
    StringBuffer hexString = new StringBuffer();
    for (int i=0; i<messageDigest.length; i++)
        hexString.append(Integer.toHexString(0xFF & messageDigest[i]));
    return hexString.toString();
",4
45347297,1,"            byte[] buffer = message.getBytes();
            try {
                MessageDigest messageDigest = MessageDigest.getInstance(algorithm);
                messageDigest.reset();
                messageDigest.update(buffer);
                digest = messageDigest.digest();
            } catch (NoSuchAlgorithmException ex) {
                // Do something
            }",4
45488974,3,"    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    Certificate root;
    try (InputStream is = Files.newInputStream(certificate)) {
        root = cf.generateCertificate(is);
    }
    KeyStore pkcs12 = KeyStore.getInstance(""PKCS12"");
    pkcs12.load(null, null);",1
45488974,3,"    CertificateFactory cf = CertificateFactory.getInstance(""X.509"");
    Certificate pub;
    try (InputStream is = Files.newInputStream(certificate)) {
        pub = cf.generateCertificate(is);
    }
    KeyStore pkcs12 = KeyStore.getInstance(""PKCS12"");
    pkcs12.load(null, null);",1
45539657,1,"private static SecretKeySpec getKey(String password) throws UnsupportedEncodingException {
    int keyLength = 256;
    byte[] keyBytes = new byte[keyLength / 8];
    Arrays.fill(keyBytes, (byte) 0x0);
    byte[] passwordBytes = password.getBytes(""UTF-8"");
    int length = passwordBytes.length < keyBytes.length ? passwordBytes.length : keyBytes.length;
    System.arraycopy(passwordBytes, 0, keyBytes, 0, length);
    SecretKeySpec key = new SecretKeySpec(keyBytes, ""AES"");
    return key;
}
",2
45585600,1,"        IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));
        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""Rijndael"");
        Cipher cipher = Cipher.getInstance(""Rijndael/CBC/PKCS5PADDING"");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);",2
45680928,0,"    private static TrustManager[] getTrustManagers(KeyStore trustStore) throws NoSuchAlgorithmException, KeyStoreException {
        String alg = KeyManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory fac = TrustManagerFactory.getInstance(alg);
        fac.init(trustStore);
        return fac.getTrustManagers();
    }

    private static KeyManager[] getKeyManagers(KeyStore keyStore, String keyPassword) throws GeneralSecurityException, IOException {
        String alg = KeyManagerFactory.getDefaultAlgorithm();
        char[] keyPass = keyPassword != null ? keyPassword.toCharArray() : null;
        KeyManagerFactory fac = KeyManagerFactory.getInstance(alg);
        fac.init(keyStore, keyPass);
        return fac.getKeyManagers();
    }
",1
45685090,0,"public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(address, port, localAddress, localPort));
}
",1
45685090,0,"public Socket createSocket(String host, int port) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {
    return makeSocketSafe(delegate.createSocket(host, port, localHost, localPort));
}

@Override",1
45708369,0,"            for (Signature signature : info.signatures) {
                MessageDigest md = MessageDigest.getInstance(""SHA"");
                md.update(signature.toByteArray());
                String s = Base64.encodeToString(md.digest(),
                        Base64.NO_WRAP);

                Log.e(""HASH KEY "", s);
            }",4
45719212,0,"        public void checkClientTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            throw new UnsupportedOperationException();
        }

        public void checkServerTrusted(X509Certificate[] chain, String authType)
                throws CertificateException {
            this.chain = chain;
            tm.checkServerTrusted(chain, authType);
        }",1
45745017,1,"        socket.close();
        Cipher c = Cipher.getInstance(""RSA/ECB/OAEPWithSHA-1AndMGF1Padding"");
        c.init(Cipher.DECRYPT_MODE, rsaKeyPair.getPrivate());
        byte[] plain = c.doFinal(cipher);",3
45853669,0,"    public class MyTLSSocketFactory extends SSLSocketFactory {

        private SSLSocketFactory internalSSLSocketFactory;

        public MyTLSSocketFactory() throws KeyManagementException, NoSuchAlgorithmException {
            SSLContext context = SSLContext.getInstance(""TLS"");
            context.init(null, null, null);
            internalSSLSocketFactory = context.getSocketFactory();
        }

        @Override
        public String[] getDefaultCipherSuites() {
            return internalSSLSocketFactory.getDefaultCipherSuites();
        }

        @Override
        public String[] getSupportedCipherSuites() {
            return internalSSLSocketFactory.getSupportedCipherSuites();
        }

        @Override
        public Socket createSocket() throws IOException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket());
        }

        @Override
        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
        }

        @Override
        public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
        }

        @Override
        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
        }

        @Override
        public Socket createSocket(InetAddress host, int port) throws IOException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
        }

        @Override
        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
        }

        private Socket enableTLSOnSocket(Socket socket) {
            if(socket != null && (socket instanceof SSLSocket)) {
                ((SSLSocket)socket).setEnabledProtocols(new String[] {""TLSv1.1"", ""TLSv1.2""});
            }
            return socket;
        }
    }",1
45853669,0,"        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
        }

        @Override
        public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
        }

        @Override
        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
        }

        @Override
        public Socket createSocket(InetAddress host, int port) throws IOException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
        }

        @Override
        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
        }
",1
45853669,0,"        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
        }

        @Override
        public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
        }

        @Override
        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
        }

        @Override
        public Socket createSocket(InetAddress host, int port) throws IOException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
        }

        @Override
        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
        }

        private Socket enableTLSOnSocket(Socket socket) {
            if(socket != null && (socket instanceof SSLSocket)) {
                ((SSLSocket)socket).setEnabledProtocols(new String[] {""TLSv1.1"", ""TLSv1.2""});
            }
            return socket;
        }",1
45853669,0,"        public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
        }

        @Override
        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
            return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
        }

        @Override",1
45871887,5,"        KeyStore trusted = KeyStore.getInstance (""PKCS12"");

        // Get the raw resource, which contains the keystore with
        // your trusted certificates (root and any intermediate certs)
        InputStream in = mCtx.getApplicationContext().getAssets ().open (""cert_keystore.pkcs12"");
        try {
            // Initialize the keystore with the provided trusted certificates
            // Provide the password of the keystore
            trusted.load (in, ""password"".toCharArray ());",1
45920066,0,"            IvParameterSpec iv = new IvParameterSpec( initVector.getBytes(""UTF-8"") );
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(AES_TECHNIQUE);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);
",2
45920066,0,"            IvParameterSpec iv = new IvParameterSpec( initVector.getBytes(""UTF-8"") );
            SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");

            Cipher cipher = Cipher.getInstance(AES_TECHNIQUE);
            cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);
",2
45930765,0,"public class sample{
 public void foo(){
// generate a key pair
KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"", ""BC"");
keyPairGenerator.initialize(4096, new SecureRandom());
KeyPair keyPair = keyPairGenerator.generateKeyPair();

// build a certificate generator
X509V3CertificateGenerator certGen = new X509V3CertificateGenerator();
X500Principal dnName = new X500Principal(""cn=Example_CN"");

// add some options
certGen.setSerialNumber(BigInteger.valueOf(System.currentTimeMillis()));
certGen.setSubjectDN(new X509Name(""dc=Example_Name""));
certGen.setIssuerDN(dnName); // use the same
// yesterday
certGen.setNotBefore(new Date(System.currentTimeMillis() - 24 * 60 * 60 * 1000));
// in 2 years
certGen.setNotAfter(new Date(System.currentTimeMillis() + 2 * 365 * 24 * 60 * 60 * 1000));
certGen.setPublicKey(keyPair.getPublic());
certGen.setSignatureAlgorithm(""SHA256WithRSAEncryption"");
certGen.addExtension(X509Extensions.ExtendedKeyUsage, true, new ExtendedKeyUsage(KeyPurposeId.id_kp_timeStamping));

// finally, sign the certificate with the private key of the same KeyPair
X509Certificate cert = certGen.generate(keyPair.getPrivate(), ""BC"");

}",3
45948174,0,"public static SecretKey generateKey(char[] passphraseOrPin, byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException {
    // Number of PBKDF2 hardening rounds to use. Larger values increase
    // computation time. You should select a value that causes computation
    // to take >100ms.
    final int iterations = 1000; 

    // Generate a 512-bit key
    final int outputKeyLength = 512;

    SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
    KeySpec keySpec = new PBEKeySpec(passphraseOrPin, salt, iterations, outputKeyLength);
    SecretKey secretKey = secretKeyFactory.generateSecret(keySpec);
    return secretKey;",2
46025698,1,"public class TLSSocketFactory extends SSLSocketFactory {

private SSLSocketFactory delegate;

public TLSSocketFactory() throws KeyManagementException, NoSuchAlgorithmException {
    SSLContext context = SSLContext.getInstance(""TLS"");
    context.init(null, null, null);
    delegate = context.getSocketFactory();
}

@Override
public String[] getDefaultCipherSuites() {
    return delegate.getDefaultCipherSuites();
}

@Override
public String[] getSupportedCipherSuites() {
    return delegate.getSupportedCipherSuites();
}

@Override
public Socket createSocket() throws IOException {
    return enableTLSOnSocket(delegate.createSocket());
}

@Override
public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(address, port, localAddress, localPort));
}

private Socket enableTLSOnSocket(Socket socket) {
    if(socket != null && (socket instanceof SSLSocket)) {
        ((SSLSocket)socket).setEnabledProtocols(new String[] {""TLSv1.1"", ""TLSv1.2""});
    }
    return socket;
}

}",1
46025698,1,"public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(address, port, localAddress, localPort));
}
",1
46025698,1,"public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(address, port, localAddress, localPort));
}

private Socket enableTLSOnSocket(Socket socket) {
    if(socket != null && (socket instanceof SSLSocket)) {
        ((SSLSocket)socket).setEnabledProtocols(new String[] {""TLSv1.1"", ""TLSv1.2""});
    }
    return socket;
}
",1
46025698,1,"public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port, localHost, localPort));
}

@Override",1
46025832,1,"public class TLSSocketFactory extends SSLSocketFactory {

private SSLSocketFactory delegate;

public TLSSocketFactory() throws KeyManagementException, NoSuchAlgorithmException {
    SSLContext context = SSLContext.getInstance(""TLS"");
    context.init(null, null, null);
    delegate = context.getSocketFactory();
}

@Override
public String[] getDefaultCipherSuites() {
    return delegate.getDefaultCipherSuites();
}

@Override
public String[] getSupportedCipherSuites() {
    return delegate.getSupportedCipherSuites();
}

@Override
public Socket createSocket() throws IOException {
    return enableTLSOnSocket(delegate.createSocket());
}

@Override
public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(address, port, localAddress, localPort));
}

private Socket enableTLSOnSocket(Socket socket) {
    if(socket != null && (socket instanceof SSLSocket)) {
        ((SSLSocket)socket).setEnabledProtocols(new String[] {""TLSv1.1"", ""TLSv1.2""});
    }
    return socket;
}
}",1
46025832,1,"public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(address, port, localAddress, localPort));
}
",1
46025832,1,"public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return enableTLSOnSocket(delegate.createSocket(address, port, localAddress, localPort));
}

private Socket enableTLSOnSocket(Socket socket) {
    if(socket != null && (socket instanceof SSLSocket)) {
        ((SSLSocket)socket).setEnabledProtocols(new String[] {""TLSv1.1"", ""TLSv1.2""});
    }
    return socket;
}",1
46025832,1,"public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(delegate.createSocket(host, port, localHost, localPort));
}

@Override",1
46101812,1,"private static void signFile(String fileName, InputStream keyIn, OutputStream out, char[] pass, boolean armor)
        throws GeneralSecurityException, IOException, PGPException {
    if (armor) {
        out = new ArmoredOutputStream(out);
    }

    PGPSecretKey pgpSec = readSecretKey(keyIn);
    PGPPrivateKey pgpPrivKey = pgpSec
            .extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(""BC"").build(pass));
    PGPSignatureGenerator sGen = new PGPSignatureGenerator(
            new JcaPGPContentSignerBuilder(pgpSec.getPublicKey().getAlgorithm(), PGPUtil.SHA1).setProvider(""BC""));

    sGen.init(PGPSignature.BINARY_DOCUMENT, pgpPrivKey);

    BCPGOutputStream bOut = new BCPGOutputStream(out);

    InputStream fIn = new BufferedInputStream(new FileInputStream(fileName));

    byte[] buf = new byte[1024];
    int len;
    while ((len = fIn.read(buf)) > 0) {
        sGen.update(buf, 0, len);
    }

    //int ch;
    //while ((ch = fIn.read()) >= 0) {
    //  sGen.update((byte) ch);
    //}

    fIn.close();

    sGen.generate().encode(bOut);

    if (armor) {
        out.close();
    }

    out.close();
    bOut.close();
}
",4
46101812,5,"        System.out.println(""key ring size="" + pkCol.size());
        Iterator it = pkCol.getKeyRings();
        while (it.hasNext()) {
            pkRing = (PGPPublicKeyRing) it.next();
            Iterator pkIt = pkRing.getPublicKeys();
            while (pkIt.hasNext()) {
                PGPPublicKey key = (PGPPublicKey) pkIt.next();
                System.out.println(""Encryption key = "" + key.isEncryptionKey() + "", Master key = "" + key.isMasterKey());
                if (key.isEncryptionKey())
                    return key;
            }
        }
        return null;",4
46101812,5,"            PGPEncryptedDataList enc;
            Object o = pgpF.nextObject();
            //
            // the first object might be a PGP marker packet.
            //
            if (o instanceof PGPEncryptedDataList) {
                enc = (PGPEncryptedDataList) o;
            } else {
                enc = (PGPEncryptedDataList) pgpF.nextObject();
            }
            //
            // find the secret key
            //
            Iterator it = enc.getEncryptedDataObjects();
            PGPPrivateKey sKey = null;
            PGPPublicKeyEncryptedData pbe = null;",4
46101812,5,"            if (o instanceof PGPEncryptedDataList) {
                enc = (PGPEncryptedDataList) o;
            } else {
                enc = (PGPEncryptedDataList) pgpF.nextObject();
            }
            //
            // find the secret key
            //
            Iterator it = enc.getEncryptedDataObjects();
            PGPPrivateKey sKey = null;
            PGPPublicKeyEncryptedData pbe = null;",4
46101812,5,"        Iterator keyRingIter = pgpSec.getKeyRings();
        while (keyRingIter.hasNext()) {
            PGPSecretKeyRing keyRing = (PGPSecretKeyRing) keyRingIter.next();

            Iterator keyIter = keyRing.getSecretKeys();
            while (keyIter.hasNext()) {
                PGPSecretKey key = (PGPSecretKey) keyIter.next();

                if (key.isSigningKey()) {
                    return key;
                }
            }
        }

        throw new IllegalArgumentException(""Can't find signing key in key ring."");",4
46101812,5,"            Iterator keyIter = keyRing.getSecretKeys();
            while (keyIter.hasNext()) {
                PGPSecretKey key = (PGPSecretKey) keyIter.next();

                if (key.isSigningKey()) {
                    return key;
                }
            }",4
46101812,5,"    private static void signFile(String fileName, InputStream keyIn, OutputStream out, char[] pass, boolean armor)
            throws GeneralSecurityException, IOException, PGPException {
        if (armor) {
            out = new ArmoredOutputStream(out);
        }

        PGPSecretKey pgpSec = readSecretKey(keyIn);
        PGPPrivateKey pgpPrivKey = pgpSec
                .extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(""BC"").build(pass));
        PGPSignatureGenerator sGen = new PGPSignatureGenerator(
                new JcaPGPContentSignerBuilder(pgpSec.getPublicKey().getAlgorithm(), PGPUtil.SHA1).setProvider(""BC""));

        sGen.init(PGPSignature.BINARY_DOCUMENT, pgpPrivKey);

        BCPGOutputStream bOut = new BCPGOutputStream(out);

        InputStream fIn = new BufferedInputStream(new FileInputStream(fileName));

        byte[] buf = new byte[1024];
        int len;
        while ((len = fIn.read(buf)) > 0) {
            sGen.update(buf, 0, len);
        }

        //int ch;
        //while ((ch = fIn.read()) >= 0) {
        //  sGen.update((byte) ch);
        //}

        fIn.close();

        sGen.generate().encode(bOut);

        if (armor) {
            out.close();
        }

        out.close();
        bOut.close();
    }",4
46257585,23,"  public void testSimpleEncoder() {
    Encoder encoder = new CryptoUtils.EncoderNotWorking();
    Decoder decoder = new CryptoUtils.DecoderNotWorking();
    encoderDecoderTest(encoder, decoder);
  }

  /**
   * Shows that encoding a byte array into a String interpreting it as Latin1
   * should work.
   */
  @Test
  public void testLatin1Encoder() {
    Encoder encoder = new CryptoUtils.EncoderLatin1();
    Decoder decoder = new CryptoUtils.DecoderLatin1();
    encoderDecoderTest(encoder, decoder);
  }

  /** Shows that Base64 encoder should be used to encode random byte arrays. */
  @Test",2
46257585,23,"  public void testLatin1Encoder() {
    Encoder encoder = new CryptoUtils.EncoderLatin1();
    Decoder decoder = new CryptoUtils.DecoderLatin1();
    encoderDecoderTest(encoder, decoder);
  }

  /** Shows that Base64 encoder should be used to encode random byte arrays. */
  @Test
  public void testBase64Encoder() {
    Encoder encoder = new CryptoUtils.EncoderBase64();
    Decoder decoder = new CryptoUtils.DecoderBase64();
    encoderDecoderTest(encoder, decoder);
  }",2
46345901,0,"SecureRandom random = new SecureRandom();
byte[] salt = new byte[8];
random.nextBytes(salt);

// Create PBE parameter set
PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, count);
PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());",2
46465722,1,"public class CustomTrustManager implements X509TrustManager {

  private final TrustManager[] originalTrustManagers;
  private final KeyStore trustStore;

  /**
   * @param trustStore A KeyStore containing the server certificate that should be trusted
   * @throws NoSuchAlgorithmException
   * @throws KeyStoreException
   */
  public CustomTrustManager(KeyStore trustStore) throws NoSuchAlgorithmException, KeyStoreException {
    this.trustStore = trustStore;

    final TrustManagerFactory originalTrustManagerFactory = TrustManagerFactory.getInstance(""X509"");
    originalTrustManagerFactory.init(trustStore);

    originalTrustManagers = originalTrustManagerFactory.getTrustManagers();
  }

  /**
   * No-op. Never invoked by client, only used in server-side implementations
   * @return
   */
  public X509Certificate[] getAcceptedIssuers() {
    return new X509Certificate[0];
  }

  /**
   * No-op. Never invoked by client, only used in server-side implementations
   * @return
   */
  public void checkClientTrusted(X509Certificate[] chain, String authType) throws java.security.cert.CertificateException {
  }


  /**
   * Given the partial or complete certificate chain provided by the peer,
   * build a certificate path to a trusted root and return if it can be validated and is trusted
   * for client SSL authentication based on the authentication type. The authentication type is
   * determined by the actual certificate used. For instance, if RSAPublicKey is used, the authType should be ""RSA"".
   * Checking is case-sensitive.
   * Defers to the default trust manager first, checks the cert supplied in the ctor if that fails.
   * @param chain the server's certificate chain
   * @param authType the authentication type based on the client certificate
   * @throws java.security.cert.CertificateException
   */
  public void checkServerTrusted(X509Certificate[] chain, String authType) throws java.security.cert.CertificateException {
    try {
      for (TrustManager originalTrustManager : originalTrustManagers) {
        ((X509TrustManager) originalTrustManager).checkServerTrusted(chain, authType);
      }
    } catch(CertificateException originalException) {
      try {
        // Ordering issue?
        X509Certificate[] reorderedChain = reorderCertificateChain(chain);
        if (! Arrays.equals(chain, reorderedChain)) {
          checkServerTrusted(reorderedChain, authType);
          return;
        }
        for (int i = 0; i < chain.length; i++) {
          if (validateCert(reorderedChain[i])) {
            return;
          }
        }
        throw originalException;
      } catch(Exception ex) {
        ex.printStackTrace();
        throw originalException;
      }
    }

  }

  /**
   * Checks if we have added the certificate in the trustStore, if that's the case we trust the certificate
   * @param x509Certificate the certificate to check
   * @return true if we know the certificate, false otherwise
   * @throws KeyStoreException on problems accessing the key store
   */
  private boolean validateCert(final X509Certificate x509Certificate) throws KeyStoreException {
    return trustStore.getCertificateAlias(x509Certificate) != null;
  }

  /**
   * Puts the certificate chain in the proper order, to deal with out-of-order
   * certificate chains as are sometimes produced by Apache's mod_ssl
   * @param chain the certificate chain, possibly with bad ordering
   * @return the re-ordered certificate chain
   */
  private X509Certificate[] reorderCertificateChain(X509Certificate[] chain) {

    X509Certificate[] reorderedChain = new X509Certificate[chain.length];
    List<X509Certificate> certificates = Arrays.asList(chain);

    int position = chain.length - 1;
    X509Certificate rootCert = findRootCert(certificates);
    reorderedChain[position] = rootCert;

    X509Certificate cert = rootCert;
    while((cert = findSignedCert(cert, certificates)) != null && position > 0) {
      reorderedChain[--position] = cert;
    }

    return reorderedChain;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the root certificate in a possibly out-of-order certificate chain.
   * @param certificates the certificate change, possibly out-of-order
   * @return the root certificate, if any, that was found in the list of certificates
   */
  private X509Certificate findRootCert(List<X509Certificate> certificates) {
    X509Certificate rootCert = null;

    for(X509Certificate cert : certificates) {
      X509Certificate signer = findSigner(cert, certificates);
      if(signer == null || signer.equals(cert)) { // no signer present, or self-signed
        rootCert = cert;
        break;
      }
    }

    return rootCert;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the first certificate in the list of certificates that is signed by the sigingCert.
   */
  private X509Certificate findSignedCert(X509Certificate signingCert, List<X509Certificate> certificates) {
    X509Certificate signed = null;

    for(X509Certificate cert : certificates) {
      Principal signingCertSubjectDN = signingCert.getSubjectDN();
      Principal certIssuerDN = cert.getIssuerDN();
      if(certIssuerDN.equals(signingCertSubjectDN) && !cert.equals(signingCert)) {
        signed = cert;
        break;
      }
    }

    return signed;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the certificate in the list of certificates that signed the signedCert.
   */
  private X509Certificate findSigner(X509Certificate signedCert, List<X509Certificate> certificates) {
    X509Certificate signer = null;

    for(X509Certificate cert : certificates) {
      Principal certSubjectDN = cert.getSubjectDN();
      Principal issuerDN = signedCert.getIssuerDN();
      if(certSubjectDN.equals(issuerDN)) {
        signer = cert;
        break;
      }
    }

    return signer;
  }
}",1
46465722,3,"public class sample{
 public void foo(){
KeyPinStore keystore = KeyPinStore.getInstance();
SSLSocketFactory sslSF = keystore.getContext().getSocketFactory();
RequestQueue mRequestQueue = Volley.newRequestQueue(context, new HurlStack(null, sslSF));

}",-1
46465836,1,"public class CustomTrustManager implements X509TrustManager {

  private final TrustManager[] originalTrustManagers;
  private final KeyStore trustStore;

  /**
   * @param trustStore A KeyStore containing the server certificate that should be trusted
   * @throws NoSuchAlgorithmException
   * @throws KeyStoreException
   */
  public CustomTrustManager(KeyStore trustStore) throws NoSuchAlgorithmException, KeyStoreException {
    this.trustStore = trustStore;

    final TrustManagerFactory originalTrustManagerFactory = TrustManagerFactory.getInstance(""X509"");
    originalTrustManagerFactory.init(trustStore);

    originalTrustManagers = originalTrustManagerFactory.getTrustManagers();
  }

  /**
   * No-op. Never invoked by client, only used in server-side implementations
   * @return
   */
  public X509Certificate[] getAcceptedIssuers() {
    return new X509Certificate[0];
  }

  /**
   * No-op. Never invoked by client, only used in server-side implementations
   * @return
   */
  public void checkClientTrusted(X509Certificate[] chain, String authType) throws java.security.cert.CertificateException {
  }


  /**
   * Given the partial or complete certificate chain provided by the peer,
   * build a certificate path to a trusted root and return if it can be validated and is trusted
   * for client SSL authentication based on the authentication type. The authentication type is
   * determined by the actual certificate used. For instance, if RSAPublicKey is used, the authType should be ""RSA"".
   * Checking is case-sensitive.
   * Defers to the default trust manager first, checks the cert supplied in the ctor if that fails.
   * @param chain the server's certificate chain
   * @param authType the authentication type based on the client certificate
   * @throws java.security.cert.CertificateException
   */
  public void checkServerTrusted(X509Certificate[] chain, String authType) throws java.security.cert.CertificateException {
    try {
      for (TrustManager originalTrustManager : originalTrustManagers) {
        ((X509TrustManager) originalTrustManager).checkServerTrusted(chain, authType);
      }
    } catch(CertificateException originalException) {
      try {
        // Ordering issue?
        X509Certificate[] reorderedChain = reorderCertificateChain(chain);
        if (! Arrays.equals(chain, reorderedChain)) {
          checkServerTrusted(reorderedChain, authType);
          return;
        }
        for (int i = 0; i < chain.length; i++) {
          if (validateCert(reorderedChain[i])) {
            return;
          }
        }
        throw originalException;
      } catch(Exception ex) {
        ex.printStackTrace();
        throw originalException;
      }
    }

  }

  /**
   * Checks if we have added the certificate in the trustStore, if that's the case we trust the certificate
   * @param x509Certificate the certificate to check
   * @return true if we know the certificate, false otherwise
   * @throws KeyStoreException on problems accessing the key store
   */
  private boolean validateCert(final X509Certificate x509Certificate) throws KeyStoreException {
    return trustStore.getCertificateAlias(x509Certificate) != null;
  }

  /**
   * Puts the certificate chain in the proper order, to deal with out-of-order
   * certificate chains as are sometimes produced by Apache's mod_ssl
   * @param chain the certificate chain, possibly with bad ordering
   * @return the re-ordered certificate chain
   */
  private X509Certificate[] reorderCertificateChain(X509Certificate[] chain) {

    X509Certificate[] reorderedChain = new X509Certificate[chain.length];
    List<X509Certificate> certificates = Arrays.asList(chain);

    int position = chain.length - 1;
    X509Certificate rootCert = findRootCert(certificates);
    reorderedChain[position] = rootCert;

    X509Certificate cert = rootCert;
    while((cert = findSignedCert(cert, certificates)) != null && position > 0) {
      reorderedChain[--position] = cert;
    }

    return reorderedChain;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the root certificate in a possibly out-of-order certificate chain.
   * @param certificates the certificate change, possibly out-of-order
   * @return the root certificate, if any, that was found in the list of certificates
   */
  private X509Certificate findRootCert(List<X509Certificate> certificates) {
    X509Certificate rootCert = null;

    for(X509Certificate cert : certificates) {
      X509Certificate signer = findSigner(cert, certificates);
      if(signer == null || signer.equals(cert)) { // no signer present, or self-signed
        rootCert = cert;
        break;
      }
    }

    return rootCert;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the first certificate in the list of certificates that is signed by the sigingCert.
   */
  private X509Certificate findSignedCert(X509Certificate signingCert, List<X509Certificate> certificates) {
    X509Certificate signed = null;

    for(X509Certificate cert : certificates) {
      Principal signingCertSubjectDN = signingCert.getSubjectDN();
      Principal certIssuerDN = cert.getIssuerDN();
      if(certIssuerDN.equals(signingCertSubjectDN) && !cert.equals(signingCert)) {
        signed = cert;
        break;
      }
    }

    return signed;
  }

  /**
   * A helper method for certificate re-ordering.
   * Finds the certificate in the list of certificates that signed the signedCert.
   */
  private X509Certificate findSigner(X509Certificate signedCert, List<X509Certificate> certificates) {
    X509Certificate signer = null;

    for(X509Certificate cert : certificates) {
      Principal certSubjectDN = cert.getSubjectDN();
      Principal issuerDN = signedCert.getIssuerDN();
      if(certSubjectDN.equals(issuerDN)) {
        signer = cert;
        break;
      }
    }

    return signer;
  }
}",1
46465836,3,"public class sample{
 public void foo(){
KeyPinStore keystore = KeyPinStore.getInstance();
SSLSocketFactory sslSF = keystore.getContext().getSocketFactory();
RequestQueue mRequestQueue = Volley.newRequestQueue(context, new HurlStack(null, sslSF));

}",-1
46511719,2,"              KeyStore keystore = KeyStore.getInstance(keystoreType);       
              keystore.load(keystoreLocation, keystorePassword);
              KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
              kmfactory.init(keystore, keyPassword);
              InputStream truststoreLocation = null;
              char [] truststorePassword = null;",1
46583130,2,"public class sample{
 public void foo(){
Signature signature = Signature.getInstance(""NONEwithRSA"");
signature.initVerify(pubKey);
signature.update(data);
boolean verified = signature.verify(signatureBytes);

}",4
46583130,4,"public class sample{
 public void foo(){
Signature signature = Signature.getInstance(""SHA256withRSA"");
signature.initVerify(pubKey);
signature.update(data);
boolean verified = signature.verify(signatureBytes);

}",4
46605980,0,"            public void checkClientTrusted(      
                    java.security.cert.X509Certificate[] chain, String authType)      
                    throws java.security.cert.CertificateException {
                logwarn(""=====================checkServerTrusted==================="");
                if(chain != null)logwarn(""length = "" + chain.length);
                try {
                    CertificateFactory factory = CertificateFactory.getInstance(""X.509"");
                    X509Certificate cert = null;
                    X509Certificate ca;
                    ByteArrayInputStream bais;

                    if(chain != null && chain.length > 0){
                        bais = new ByteArrayInputStream(chain[0].getEncoded());
                        cert = (X509Certificate) factory.generateCertificate(bais);
                        bais.close();
                    } else {
                        throw new CertificateException(""There is no certificate"");
                    }
                    byte[] trust = RSASignature.readFileByBytes(context, ""trust01.crt"");
                    logwarn(""trust cert = "" + new String(trust));
                    bais = new ByteArrayInputStream(trust);
                    CertificateFactory myCertificateFactory;
                    ca = (X509Certificate)factory.generateCertificate(bais);
                    bais.close();
                    cert.verify(ca.getPublicKey());
                }catch (Exception e){
                    logwarn(""TrustManager checkServerTrusted failed!"");
                    e.printStackTrace();
                    throw new CertificateException(e);
                }
            }

            @Override      ",3
46605980,0,"            public void checkServerTrusted(      
                    java.security.cert.X509Certificate[] chain, String authType)      
                    throws java.security.cert.CertificateException {      
                logwarn(""=====================checkServerTrusted==================="");
                if(chain != null)logwarn(""length = "" + chain.length);
                try {
                    CertificateFactory factory = CertificateFactory.getInstance(""X.509"");
                    X509Certificate cert = null;
                    X509Certificate ca;
                    ByteArrayInputStream bais;
                    if(chain != null && chain.length > 0){
                        bais = new ByteArrayInputStream(chain[0].getEncoded());
                        cert = (X509Certificate) factory.generateCertificate(bais);
                        bais.close();
                    } else {
                        throw new CertificateException(""There is no certificate"");
                    }
                    byte[] trust =  RSASignature.readFileByBytes(context, ""trust01.crt"");
                    logwarn(""trust cert = "" + new String(trust));
                    bais = new ByteArrayInputStream(trust);
                    CertificateFactory myCertificateFactory;
                    ca = (X509Certificate)factory.generateCertificate(bais);
                    bais.close();
                    cert.verify(ca.getPublicKey());
                }catch (Exception e){
                    logwarn(""TrustManager checkServerTrusted failed!"");
                    e.printStackTrace();
                    throw new CertificateException(e);
                }
            }      ",3
46621925,1,"public class Ciphers
{
    public static void main(String[] args)
        throws Exception
    {
        SSLServerSocketFactory ssf = (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();

        String[] defaultCiphers = ssf.getDefaultCipherSuites();
        String[] availableCiphers = ssf.getSupportedCipherSuites();

        TreeMap ciphers = new TreeMap();

        for(int i=0; i<availableCiphers.length; ++i )
            ciphers.put(availableCiphers[i], Boolean.FALSE);

        for(int i=0; i<defaultCiphers.length; ++i )
            ciphers.put(defaultCiphers[i], Boolean.TRUE);

        System.out.println(""Default\tCipher"");
        for(Iterator i = ciphers.entrySet().iterator(); i.hasNext(); ) {
            Map.Entry cipher=(Map.Entry)i.next();

            if(Boolean.TRUE.equals(cipher.getValue()))
                System.out.print('*');
            else
                System.out.print(' ');

            System.out.print('\t');
            System.out.println(cipher.getKey());
        }
    }
}",1
46641194,2,"        IvParameterSpec iv = new IvParameterSpec(initVector.getBytes());
        SecretKeySpec keySpec = new SecretKeySpec(secret.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);",2
46641194,2,"        IvParameterSpec iv = new IvParameterSpec(initVector.getBytes());
        SecretKeySpec keySpec = new SecretKeySpec(secret.getBytes(), ""AES"");
        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);",2
46641194,2,"        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");
        cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);
        byte[] decrypted = cipher.doFinal(Base64.decodeBase64(str));
        return new String(decrypted);",2
46685754,2,"TrustManagerFactory tmf = TrustManagerFactory
    .getInstance(TrustManagerFactory.getDefaultAlgorithm());
// Using null here initialises the TMF with the default trust store.
tmf.init((KeyStore) null);

// Get hold of the default trust manager
X509TrustManager defaultTm = null;
for (TrustManager tm : tmf.getTrustManagers()) {
    if (tm instanceof X509TrustManager) {
        defaultTm = (X509TrustManager) tm;
        break;
    }
}
",1
46686825,0,"    public X509Certificate[] getCertificateChain(String s) {
        // You can use `s` to select the appropriate file

        try {
            File file = new File(""path to certificate"");

            try(InputStream is = new FileInputStream(file)) {
                CertificateFactory factory = CertificateFactory.getInstance(""X.509"");
                return new X509Certificate[] {
                        (X509Certificate) factory.generateCertificate(is)
                };
            }
        }
        catch (CertificateException| IOException  e) {
            e.printStackTrace();
        }

        return null;",1
46686825,0,"    public X509Certificate[] getAcceptedIssuers() {
        try {
            File file = new File(""path to certificate"");

            try(InputStream is = new FileInputStream(file)) {
                CertificateFactory factory = CertificateFactory.getInstance(""X.509"");
                return new X509Certificate[] {
                        (X509Certificate) factory.generateCertificate(is)
                };
            }
        }
        catch (CertificateException| IOException  e) {
            e.printStackTrace();
        }

        return null;",1
46705950,0,"public class sample{
 public void foo(){
try {
        SSLContext ctx = SSLContext.getInstance(""TLSv1.2"");
        ctx.init(null, null, null);
        SSLContext.setDefault(ctx);
    } catch (Exception e) {
            System.out.println(e.getMessage());
    }

}",1
46717754,4,"  String packageName = mContext.getPackageName();
  int flags = PackageManager.GET_SIGNATURES;
  PackageInfo packageInfo = null;
  try {
   packageInfo = pm.getPackageInfo(packageName, flags);
  } catch (PackageManager.NameNotFoundException e) {
   e.printStackTrace();
  }
  Signature[] signatures = packageInfo.signatures;
  byte[] cert = signatures[0].toByteArray();
  InputStream input = new ByteArrayInputStream(cert);
  CertificateFactory cf = null;
  try {
   cf = CertificateFactory.getInstance(""X509"");
  } catch (CertificateException e) {
   e.printStackTrace();
  }
  X509Certificate c = null;
  try {
   c = (X509Certificate) cf.generateCertificate(input);
  } catch (CertificateException e) {
   e.printStackTrace();
  }
  String hexString = null;
  try {
   MessageDigest md = MessageDigest.getInstance(""SHA1"");
   byte[] publicKey = md.digest(c.getEncoded());
   hexString = byte2HexFormatted(publicKey);
  } catch (NoSuchAlgorithmException e1) {
   e1.printStackTrace();
  } catch (CertificateEncodingException e) {
   e.printStackTrace();
  }
  return hexString;
 }

 public static String byte2HexFormatted(byte[] arr) 
 {
   StringBuilder str = new StringBuilder(arr.length * 2);
   for (int i = 0; i < arr.length; i++) 
   {
   String h = Integer.toHexString(arr[i]);
   int l = h.length();
   if (l == 1) h = ""0"" + h;
   if (l > 2) h = h.substring(l - 2, l);
   str.append(h.toUpperCase());
   if (i < (arr.length - 1)) str.append(':');
   }
  return str.toString();
 }",4
46717754,4,"  Signature[] signatures = packageInfo.signatures;
  byte[] cert = signatures[0].toByteArray();
  InputStream input = new ByteArrayInputStream(cert);
  CertificateFactory cf = null;
  try {
   cf = CertificateFactory.getInstance(""X509"");",3
46717754,4,"  byte[] cert = signatures[0].toByteArray();
  InputStream input = new ByteArrayInputStream(cert);
  CertificateFactory cf = null;
  try {
   cf = CertificateFactory.getInstance(""X509"");
  } catch (CertificateException e) {
   e.printStackTrace();
  }
  X509Certificate c = null;
  try {
   c = (X509Certificate) cf.generateCertificate(input);",3
46809793,0,"            System.out.println(""ENCRYPTED: "" + new String(encodedMessage));

            // doing decryption
            cipher.init(Cipher.DECRYPT_MODE, privateKey);
            byte[] decodedMessage = cipher.doFinal(encodedMessage);
            System.out.println(""DECRYPTED: "" + new String(decodedMessage));",2
46841131,0,"public class sample{
/**
 * Find a factor of n by following the algorithm outlined in Handbook of Applied Cryptography, section
 * 8.2.2(i). See http://cacr.uwaterloo.ca/hac/about/chap8.pdf.
 *
 */

private static BigInteger findFactor(BigInteger e, BigInteger d, BigInteger n) {
    BigInteger edMinus1 = e.multiply(d).subtract(BigInteger.ONE);
    int s = edMinus1.getLowestSetBit();
    BigInteger t = edMinus1.shiftRight(s);

    for (int aInt = 2; true; aInt++) {
        BigInteger aPow = BigInteger.valueOf(aInt).modPow(t, n);
        for (int i = 1; i <= s; i++) {
            if (aPow.equals(BigInteger.ONE)) {
                break;
            }
            if (aPow.equals(n.subtract(BigInteger.ONE))) {
                break;
            }
            BigInteger aPowSquared = aPow.multiply(aPow).mod(n);
            if (aPowSquared.equals(BigInteger.ONE)) {
                return aPow.subtract(BigInteger.ONE).gcd(n);
            }
            aPow = aPowSquared;
        }
    }

}

public static RSAPrivateCrtKey createCrtKey(RSAPublicKey rsaPub, RSAPrivateKey rsaPriv) throws NoSuchAlgorithmException, InvalidKeySpecException {

    BigInteger e = rsaPub.getPublicExponent();
    BigInteger d = rsaPriv.getPrivateExponent();
    BigInteger n = rsaPub.getModulus();
    BigInteger p = findFactor(e, d, n);
    BigInteger q = n.divide(p);
    if (p.compareTo(q) > 1) {
        BigInteger t = p;
        p = q;
        q = t;
    }
    BigInteger exp1 = d.mod(p.subtract(BigInteger.ONE));
    BigInteger exp2 = d.mod(q.subtract(BigInteger.ONE));
    BigInteger coeff = q.modInverse(p);
    RSAPrivateCrtKeySpec keySpec = new RSAPrivateCrtKeySpec(n, e, d, p, q, exp1, exp2, coeff);
    KeyFactory kf = KeyFactory.getInstance(""RSA"");
    return (RSAPrivateCrtKey) kf.generatePrivate(keySpec);

}
",3
46842540,0,"        HostnameVerifier hv = new HostnameVerifier() {
            public boolean verify(String urlHostName, SSLSession session) {
                if (!urlHostName.equalsIgnoreCase(session.getPeerHost())) {
                    System.out.println(""Ошибка: URL хост '"" + urlHostName + ""' отличается SSL хоста'"" + session.getPeerHost() + ""'."");
                }
                return true;
            }",1
46861817,0,"        using (MemoryStream ms = new MemoryStream())
        {
            using (CryptoStream cs = new CryptoStream(ms, des.CreateEncryptor(), CryptoStreamMode.Write))
            {
                cs.Write(clearBytes, 0, clearBytes.Length);
                cs.Close();
            }
            encryptedText = Convert.ToBase64String(ms.ToArray());
        }",2
46874098,0,"public class sample{
 public void foo(){
X509TrustManager manager = null;
FileInputStream fs = null;

TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());

try
{
    fs = new FileInputStream(System.getProperty(""javax.net.ssl.trustStore"")); 
    keyStore.load(fs, null);
}
finally
{
    if (fs != null) { fs.close(); }
}

trustManagerFactory.init(keyStore);
TrustManager[] managers = trustManagerFactory.getTrustManagers();

for (TrustManager tm : managers)
{
    if (tm instanceof X509TrustManager) 
    {
        manager = (X509TrustManager) tm;
        break;
    }
}

}",1
46969809,1,"        finally
        {
            cert.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore",1
46969809,1,"        finally
        {
            cert.close();
        }

        // Create a KeyStore containing our trusted CAs
        String keyStoreType = KeyStore.getDefaultType();
        KeyStore keyStore = KeyStore.getInstance(keyStoreType);
        keyStore.load(null, null);
        keyStore.setCertificateEntry(""ca"", ca);

        // Create a TrustManager that trusts the CAs in our KeyStore
        String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
        TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
        tmf.init(keyStore);

        // Create an SSLContext that uses our TrustManager",1
46984366,0,"public class EncryptionDecryption {

    private static String salt;
    private static int iterations = 65536  ;
    private static int keySize = 256;
    private static byte[] ivBytes;

    private static SecretKey secretKey;

    public static void main(String []args) throws Exception {

        salt = getSalt();

        char[] message = ""PasswordToEncrypt"".toCharArray();
        System.out.println(""Message: "" + String.valueOf(message));
        System.out.println(""Encrypted: "" + encrypt(message));
        System.out.println(""Decrypted: "" + decrypt(encrypt(message).toCharArray()));
    }

    public static String encrypt(char[] plaintext) throws Exception {
        byte[] saltBytes = salt.getBytes();

        SecretKeyFactory skf = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1"");
        PBEKeySpec spec = new PBEKeySpec(plaintext, saltBytes, iterations, keySize);
        secretKey = skf.generateSecret(spec);
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();
        byte[] encryptedTextBytes = cipher.doFinal(String.valueOf(plaintext).getBytes(""UTF-8""));

        return DatatypeConverter.printBase64Binary(encryptedTextBytes);
    }

    public static String decrypt(char[] encryptedText) throws Exception {

        System.out.println(encryptedText);

        byte[] encryptedTextBytes = DatatypeConverter.parseBase64Binary(new String(encryptedText));
        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        }   catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }   catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return new String(decryptedTextBytes);

    }

    public static String getSalt() throws Exception {

        SecureRandom sr = SecureRandom.getInstance(""SHA1PRNG"");
        byte[] salt = new byte[20];
        sr.nextBytes(salt);
        return new String(salt);
    }",25
46984366,0,"        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.ENCRYPT_MODE, secretSpec);
        AlgorithmParameters params = cipher.getParameters();
        ivBytes = params.getParameterSpec(IvParameterSpec.class).getIV();",2
46984366,0,"        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));
",2
46984366,0,"        SecretKeySpec secretSpec = new SecretKeySpec(secretKey.getEncoded(), ""AES"");

        Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
        cipher.init(Cipher.DECRYPT_MODE, secretSpec, new IvParameterSpec(ivBytes));

        byte[] decryptedTextBytes = null;

        try {
            decryptedTextBytes = cipher.doFinal(encryptedTextBytes);
        }   catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }   catch (BadPaddingException e) {
            e.printStackTrace();
        }

        return new String(decryptedTextBytes);
",2
46988906,0,"        public static byte[] encrypt(byte[] ivBytes, byte[] keyBytes, byte[] textBytes) 
                throws java.io.UnsupportedEncodingException, 
                    NoSuchAlgorithmException,
                    NoSuchPaddingException,
                    InvalidKeyException,
                    InvalidAlgorithmParameterException,
                    IllegalBlockSizeException,
                    BadPaddingException {

            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            SecretKeySpec newKey = new SecretKeySpec(keyBytes, ""AES"");
            Cipher cipher = null;
            cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.ENCRYPT_MODE, newKey, ivSpec);
            return cipher.doFinal(textBytes);",2
46988906,0,"        public static byte[] decrypt(byte[] ivBytes, byte[] keyBytes, byte[] textBytes) 
                throws java.io.UnsupportedEncodingException, 
                NoSuchAlgorithmException,
                NoSuchPaddingException,
                InvalidKeyException,
                InvalidAlgorithmParameterException,
                IllegalBlockSizeException,
                BadPaddingException {

            AlgorithmParameterSpec ivSpec = new IvParameterSpec(ivBytes);
            SecretKeySpec newKey = new SecretKeySpec(keyBytes, ""AES"");
            Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");
            cipher.init(Cipher.DECRYPT_MODE, newKey, ivSpec);
            return cipher.doFinal(textBytes);
        }",2
47029182,2,"public static byte[] encryptMsg(String message, SecretKey secret)
    throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, InvalidParameterSpecException, IllegalBlockSizeException, BadPaddingException, UnsupportedEncodingException 
{ 
   /* Encrypt the message. */
   Cipher cipher = null; 
   cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
   cipher.init(Cipher.ENCRYPT_MODE, secret); 
   byte[] cipherText = cipher.doFinal(message.getBytes(""UTF-8"")); 
   return cipherText; 
}

public static String decryptMsg(byte[] cipherText, SecretKey secret) 
    throws NoSuchPaddingException, NoSuchAlgorithmException, InvalidParameterSpecException, InvalidAlgorithmParameterException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException 
{
    /* Decrypt the message, given derived encContentValues and initialization vector. */
    Cipher cipher = null;
    cipher = Cipher.getInstance(""AES/ECB/PKCS5Padding"");
    cipher.init(Cipher.DECRYPT_MODE, secret); 
    String decryptString = new String(cipher.doFinal(cipherText), ""UTF-8"");
    return decryptString; 
}",2
47091365,0,"      e2.printStackTrace();
      InputStream input = new ByteArrayInputStream(cert);
      CertificateFactory cf = null;
      try {
        cf = CertificateFactory.getInstance(""X509"");
      } catch (CertificateException e3) {
        e3.printStackTrace();
      }
      X509Certificate c = null;
      try {
        c = (X509Certificate) cf.generateCertificate(input);",3
47103931,3,"        SecretKeySpec key = new SecretKeySpec(keyAndIV[INDEX_KEY], ""AES"");
        IvParameterSpec iv = new IvParameterSpec(keyAndIV[INDEX_IV]);

        // --- initialize cipher instance and decrypt ---
        aesCBC.init(Cipher.DECRYPT_MODE, key, iv);
        byte[] decrypted = aesCBC.doFinal(encrypted);
",2
47128415,0,"    private static boolean verify(byte[] data, byte[] signature, String publicKey) throws GeneralSecurityException{
        X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(DatatypeConverter.parseBase64Binary(publicKey));
        KeyFactory keyFactory = KeyFactory.getInstance(""RSA"");
        PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);
        Signature sig = Signature.getInstance(""SHA256withRSA"");
        sig.initVerify(pubKey);
        sig.update(data);
        return sig.verify(signature);
    }",34
47185952,0,"        PemObject obj2 = gen2.generate();
        StringWriter sw2 = new StringWriter();
        try (JcaPEMWriter pw = new JcaPEMWriter(sw2)) {
            pw.writeObject(obj2);
        }
        String pkcs8Key2 = sw2.toString();
        System.out.println(pkcs8Key2);
",3
47325067,0,"    public NoSSLv3SocketFactory(SSLSocketFactory delegate) {
        this.delegate = delegate;
    }

    @Override
    public String[] getDefaultCipherSuites() {
        return delegate.getDefaultCipherSuites();
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return delegate.getSupportedCipherSuites();
    }

    private Socket makeSocketSafe(Socket socket) {
        if (socket instanceof SSLSocket) {
            socket = new NoSSLv3SSLSocket((SSLSocket) socket);
        }
        return socket;
    }

    @Override
    public Socket createSocket(Socket s, String host, int port,
            boolean autoClose) throws IOException {
        return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost,
            int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port, localHost,
                localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port,
            InetAddress localAddress, int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(address, port,
                localAddress, localPort));
    }

    private class NoSSLv3SSLSocket extends DelegateSSLSocket {

        private NoSSLv3SSLSocket(SSLSocket delegate) {
            super(delegate);

        }

        @Override
        public void setEnabledProtocols(String[] protocols) {
            if (protocols != null && protocols.length == 1
                    && ""SSLv3"".equals(protocols[0])) {

                List<String> enabledProtocols = new ArrayList<String>(
                        Arrays.asList(delegate.getEnabledProtocols()));
                if (enabledProtocols.size() > 1) {
                    enabledProtocols.remove(""SSLv3"");
                    System.out.println(""Removed SSLv3 from enabled protocols"");
                } else {
                    System.out.println(""SSL stuck with protocol available for ""
                            + String.valueOf(enabledProtocols));
                }
                protocols = enabledProtocols
                        .toArray(new String[enabledProtocols.size()]);
            }

//          super.setEnabledProtocols(protocols);",1
47325067,0,"    private Socket makeSocketSafe(Socket socket) {
        if (socket instanceof SSLSocket) {
            socket = new NoSSLv3SSLSocket((SSLSocket) socket);
        }
        return socket;
    }

    @Override
    public Socket createSocket(Socket s, String host, int port,
            boolean autoClose) throws IOException {
        return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost,
            int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port, localHost,
                localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port,
            InetAddress localAddress, int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(address, port,
                localAddress, localPort));
    }
",1
47325067,0,"    public Socket createSocket(Socket s, String host, int port,
            boolean autoClose) throws IOException {
        return makeSocketSafe(delegate.createSocket(s, host, port, autoClose));
    }

    @Override
    public Socket createSocket(String host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost,
            int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port, localHost,
                localPort));
    }

    @Override
    public Socket createSocket(InetAddress host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(InetAddress address, int port,
            InetAddress localAddress, int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(address, port,
                localAddress, localPort));
    }
",1
47325067,0,"    public Socket createSocket(String host, int port) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port));
    }

    @Override
    public Socket createSocket(String host, int port, InetAddress localHost,
            int localPort) throws IOException {
        return makeSocketSafe(delegate.createSocket(host, port, localHost,
                localPort));
    }

    @Override",1
47325272,4,"        PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new RijndaelEngine(256)), new ZeroBytePadding());
        CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(key.getBytes()), iv.getBytes());
        cipher.init(true, ivAndKey);",2
47325272,4,"        PaddedBufferedBlockCipher aes = new PaddedBufferedBlockCipher(new CBCBlockCipher(new RijndaelEngine(256)), new ZeroBytePadding());

        CipherParameters ivAndKey = new ParametersWithIV(new KeyParameter(key.getBytes()), iv.getBytes());
        aes.init(false, ivAndKey);",2
47325272,4,"    int minSize = cipher.getOutputSize(data.length);
    byte[] outBuf = new byte[minSize];
    int length1 = cipher.processBytes(data, 0, data.length, outBuf, 0);
    int length2 = cipher.doFinal(outBuf, length1);
    int actualLength = length1 + length2;
    byte[] cipherArray = new byte[actualLength];",2
47411353,5,"public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
}
",1
47411353,5,"public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(s, host, port, autoClose));
}

@Override
public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
}

@Override
public Socket createSocket(InetAddress host, int port) throws IOException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
}

@Override
public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(address, port, localAddress, localPort));
}

private Socket enableTLSOnSocket(Socket socket) {
    if(socket != null && (socket instanceof SSLSocket)) {
        ((SSLSocket)socket).setEnabledProtocols(new String[] {""TLSv1.2"", ""TLSv1.1""});
    }
    return socket;
}",1
47411353,5,"public Socket createSocket(String host, int port) throws IOException, UnknownHostException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port));
}

@Override
public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {
    return enableTLSOnSocket(internalSSLSocketFactory.createSocket(host, port, localHost, localPort));
}

@Override",1
47518804,0,"        byte[] encrypted;
        try {
            cipher.init(Cipher.ENCRYPT_MODE,secretKeySpec,ivParameterSpec);
            encrypted = cipher.doFinal(toEncrypt.getBytes());
        } catch (Exception e) {
            //e.printStackTrace();
            return null;
        }
        return Base64.encodeToString(encrypted,Base64.DEFAULT);",2
47518804,0,"        byte[] encrypted;
        try {
            cipher.init(Cipher.ENCRYPT_MODE,secretKeySpec,ivParameterSpec);
            encrypted = cipher.doFinal(toEncrypt.getBytes());
        } catch (Exception e) {
            //e.printStackTrace();
            return null;
        }
        return Base64.encodeToString(encrypted,Base64.DEFAULT);",2
47588000,1,"Cipher decipher = Cipher.getInstance(""AES/CTR/NoPadding"");
decipher.init(Cipher.DECRYPT_MODE, aesKey,new IvParameterSpec(iv)); 
byte[] cipherTextInByteArr =Base64.getDecoder().decode(encodedText);
byte[] plainTextInByteArr = decipher.doFinal(cipherTextInByteArr);     ",2
